document_path,chunk_id,text
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\AUTHORS.md,AUTHORS.md_chunk0,"Credits  Development Leads  Audrey Roy Greenfeld (@audreyfeldroy)  Daniel Roy Greenfeld (@pydanny)  Raphael Pierzina (@hackebrot)  Core Committers  Michael Joseph (@michaeljoseph)  Paul Moore (@pfmoore)  Andrey Shpak (@insspb)  Sorin Sbarnea (@ssbarnea)  Fábio C. Barrionuevo da Luz (@luzfcb)  Simone Basso (@simobasso)  Jens Klein (@jensens)  Érico Andrei (@ericof)  Contributors  Steven Loria (@sloria)  Goran Peretin (@gperetin)  Hamish Downer (@foobacca)  Thomas Orozco (@krallin)  Jindrich Smitka (@s-m-i-t-a)  Benjamin Schwarze (@benjixx)  Raphi (@raphigaziano)  Thomas Chiroux (@ThomasChiroux)  Sergi Almacellas Abellana (@pokoli)  Alex Gaynor (@alex)  Rolo (@rolo)  Pablo (@oubiga)  Bruno Rocha (@rochacbruno)  Alexander Artemenko (@svetlyak40wt)  Mahmoud Abdelkader (@mahmoudimus)  Leonardo Borges Avelino (@lborgav)  Chris Trotman (@solarnz)  Rolf (@relekang)  Noah Kantrowitz (@coderanger)  Vincent Bernat (@vincentbernat)  Germán Moya (@pbacterio)  Ned Batchelder (@nedbat)  Dave Dash (@davedash)  Johan Charpentier (@cyberj)  Éric Araujo (@merwok)  saxix (@saxix)  Tzu-ping Chung (@uranusjr)  Caleb Hattingh (@cjrh)  Flavio Curella (@fcurella)  Adam Venturella (@aventurella)  Monty Taylor (@emonty)  schacki (@schacki)  Ryan Olson (@ryanolson)  Trey Hunner (@treyhunner)  Russell Keith-Magee (@freakboy3742)  Mishbah Razzaque (@mishbahr)  Robin Andeer (@robinandeer)  Rachel Sanders (@trustrachel)  Rémy Hubscher (@Natim)  Dino Petron3 (@dinopetrone)  Peter Inglesby (@inglesp)  Ramiro Batista da Luz (@ramiroluz)  Omer Katz (@thedrow)  lord63 (@lord63)  Randy Syring (@rsyring)  Mark Jones (@mark0978)  Marc Abramowitz (@msabramo)  Lucian Ursu (@LucianU)  Osvaldo Santana Neto (@osantana)  Matthias84 (@Matthias84)  Simeon Visser (@svisser)  Guruprasad (@lgp171188)  Charles-Axel Dein (@charlax)  Diego Garcia (@drgarcia1986)  maiksensi (@maiksensi)  Andrew Conti (@agconti)  Valentin Lab (@vaab)  Ilja Bauer (@iljabauer)  Elias Dorneles (@eliasdorneles)  Matias Saguir (@mativs)  Johannes (@johtso)  macrotim (@macrotim)  Will McGinnis (@wdm0006)  Cédric Krier (@cedk)  Tim Osborn (@ptim)  Aaron Gallagher (@habnabit)  mozillazg (@mozillazg)  Joachim Jablon (@ewjoachim)  Andrew Ittner (@tephyr)  Diane DeMers Chen (@purplediane)  zzzirk (@zzzirk)  Carol Willing (@willingc)  phoebebauer (@phoebebauer)  Adam Chainz (@adamchainz)  Sulé (@suledev)  Evan Palmer (@palmerev)  Bruce Eckel (@BruceEckel)  Robert Lyon (@ivanlyon)  Terry Bates (@terryjbates)  Brett Cannon (@brettcannon)  Michael Warkentin (@mwarkentin)  Bartłomiej Kurzeja (@B3QL)  Thomas O'Donnell (@andytom)  Jeremy Carbaugh (@jcarbaugh)  Nathan Cheung (@cheungnj)  Abdó Roig-Maranges (@aroig)  Steve Piercy (@stevepiercy)  Corey (@coreysnyder04)  Dmitry Evstratov (@devstrat)  Eyal Levin (@eyalev)  mathagician (@mathagician)  Guillaume Gelin (@ramnes)  @delirious-lettuce (@delirious-lettuce)  Gasper Vozel (@karantan)  Joshua Carp (@jmcarp)  @meahow (@meahow)  Andrea Grandi (@andreagrandi)  Issa Jubril (@jubrilissa)  Nytiennzo Madooray (@Nythiennzo)  Erik Bachorski (@dornheimer)  cclauss (@cclauss)  Andy Craze (@accraze)  Anthony Sottile (@asottile)  Jonathan Sick (@jonathansick)  Hugo (@hugovk)  Min ho Kim (@minho42)  Ryan Ly (@rly)  Akintola Rahmat (@mihrab34)  Jai Ram Rideout (@jairideout)  Diego Carrasco Gubernatis (@dacog)  Wagner Negrão (@wagnernegrao)  Josh Barnes (@jcb91)  Nikita Sobolev (@sobolevn)  Matt Stibbs (@mattstibbs)  MinchinWeb (@MinchinWeb)  kishan (@kishan)  tonytheleg (@tonytheleg)  Roman Hartmann (@RomHartmann)  DSEnvel (@DSEnvel)  kishan (@kishan)  Bruno Alla (@browniebroke)  nicain (@nicain)  Carsten Rösnick-Neugebauer (@croesnick)  igorbasko01 (@igorbasko01)  Dan Booth Dev (@DanBoothDev)  Pablo Panero (@ppanero)  Chuan-Heng Hsiao (@chhsiao1981)  Mohammad Hossein Sekhavat (@mhsekhavat)  Amey Joshi (@amey589)  Paul Harrison (@smoothml)  Fabio Todaro (@SharpEdgeMarshall)  Nicholas Bollweg (@bollwyvl)  Jace Browning (@jacebrowning)  Ionel Cristian Mărieș (@ionelmc)  Kishan Mehta (@kishan3)  Wieland Hoffmann (@mineo)  Antony Lee (@anntzer)  Aurélien Gâteau (@agateau)  Axel H. (@noirbizarre)  Chris (@chrisbrake)  Chris Streeter (@streeter)  Gábor Lipták (@gliptak)  Javier Sánchez Portero (@javiersanp)  Nimrod Milo (@milonimrod)  Philipp Kats (@Casyfill)  Reinout van Rees (@reinout)  Rémy Greinhofer (@rgreinho)  Sebastian (@sebix)  Stuart Mumford (@Cadair)  Tom Forbes (@orf)  Xie Yanbo (@xyb)  Maxim Ivanov (@ivanovmg)  Backers  We would like to thank the following people for supporting us in our efforts to maintain and improve Cookiecutter:  Alex DeBrie  Alexandre Y. Harano  Bruno Alla  Carol Willing  Russell Keith-Magee  Sprint Contributors  PyCon 2016 Sprint  The following people made contributions to the cookiecutter project at the PyCon sprints in Portland, OR from June 2-5 2016. Contributions include user testing, debugging, improving documentation, reviewing issues, writing tutorials, creating and updating project templates, and teaching each other.  Adam Chainz (@adamchainz)  Andrew Ittner (@tephyr)  Audrey Roy Greenfeld (@audreyfeldroy)  Carol Willing (@willingc)  Christopher Clarke (@chrisdev)  Citlalli Murillo (@citmusa)  Daniel Roy Greenfeld (@pydanny)  Diane DeMers Chen (@purplediane)  Elaine Wong (@elainewong)  Elias Dorneles (@eliasdorneles)  Emily Cain (@emcain)  John Roa (@jhonjairoroa87)  Jonan Scheffler (@1337807)  Phoebe Bauer (@phoebebauer)  Kartik Sundararajan (@skarbot)  Katia Lira (@katialira)  Leonardo Jimenez (@xpostudio4)  Lindsay Slazakowski (@lslaz1)  Meghan Heintz (@dot2dotseurat)  Raphael Pierzina (@hackebrot)  Umair Ashraf (@umrashrf)  Valdir Stumm Junior (@stummjr)  Vivian Guillen (@viviangb)  Zaro (@zaro0508)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\CODE_OF_CONDUCT.md,CODE_OF_CONDUCT.md_chunk0,"Code of Conduct  Everyone interacting in the Cookiecutter project's codebases and documentation is expected to follow the PyPA Code of Conduct. This includes, but is not limited to, issue trackers, chat rooms, mailing lists, and other virtual or in real life communication."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\CONTRIBUTING.md,CONTRIBUTING.md_chunk0,"Contributing  Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.  Types of Contributions  Contributor Setup  Contributor Guidelines  Contributor Testing  Core Committer Guide  Types of Contributions  You can contribute in many ways:  Report Bugs  Report bugs at https://github.com/cookiecutter/cookiecutter/issues.  If you are reporting a bug, please include:  Your operating system name and version.  Any details about your local setup that might be helpful in troubleshooting.  If you can, provide detailed steps to reproduce the bug.  If you don't have steps to reproduce the bug, just note your observations in as much detail as you can.   Questions to start a discussion about the issue are welcome.  Fix Bugs  Look through the GitHub issues for bugs. Anything tagged with ""bug"" is open to whoever wants to implement it.  Implement Features  Look through the GitHub issues for features. Anything tagged with ""enhancement"" and ""please-help"" is open to whoever wants to implement it.  Please do not combine multiple feature enhancements into a single pull request.  Note: this project is very conservative, so new features that aren't tagged with ""please-help"" might not get into core. We're trying to keep the code base small, extensible, and streamlined. Whenever possible, it's best to try and implement feature ideas as separate projects outside of the core codebase.  Write Documentation  Cookiecutter could always use more documentation, whether as part of the official Cookiecutter docs, in docstrings, or even on the web in blog posts, articles, and such.  If you want to review your changes on the documentation locally, you can do:  bash pip install -r docs/requirements.txt make servedocs  This will compile the documentation, open it in your browser and start watching the files for changes, recompiling as you save.  Submit Feedback  The best way to send feedback is to file an issue at https://github.com/cookiecutter/cookiecutter/issues.  If you are proposing a feature:  Explain in detail how it would work.  Keep the scope as narrow as possible, to make it easier to implement.  Remember that this is a volunteer-driven project, and that contributions are welcome :)  Setting Up the Code for Local Development  Here's how to set up cookiecutter for local development.  Fork the cookiecutter repo on GitHub.  Clone your fork locally:  bash    git clone git@github.com:your_name_here/cookiecutter.git  Install your local copy into a virtualenv.    Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:  bash    cd cookiecutter/    pip install -e .  Create a branch for local development:  bash    git checkout -b name-of-your-bugfix-or-feature  Now you can make your changes locally.  When you're done making changes, check that your changes pass the tests and lint check:  bash    pip install tox    tox  Ensure that your feature or commit is fully covered by tests. Check report after regular tox run.    You can also run coverage only report and get html report with statement by statement highlighting:  bash    make coverage  You report will be placed to htmlcov directory. Please do not include this directory to your commits.    By default this directory in our .gitignore file.  Commit your changes and push your branch to GitHub:  bash    git add .    git commit -m ""Your detailed description of your changes.""    git push origin name-of-your-bugfix-or-feature  Submit a pull request through the GitHub website.  Contributor Guidelines  Pull Request Guidelines  Before you submit a pull request, check that it meets these guidelines:  The pull request should include tests.  The pull request should be contained:    if it's too big consider splitting it into smaller pull requests.  If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add the feature to the list in README.md.  The pull request must pass all CI/CD jobs before being ready for review.  If one CI/CD job is failing for unrelated reasons you may want to create another PR to fix that first.  Coding Standards  PEP8  Functions over classes except in tests  Quotes via http://stackoverflow.com/a/56190/5549  Use double quotes around strings that are used for interpolation or that are natural language messages  Use single quotes for small symbol-like strings (but break the rules if the strings contain quotes)  Use triple double quotes for docstrings and raw string literals for regular expressions even if they aren't needed.  Example: python LIGHT_MESSAGES = {     'English': ""There are %(number_of_lights)s lights."",     'Pirate':  ""Arr! Thar be %(number_of_lights)s lights."" } def lights_message(language, number_of_lights):     """"""Return a language-appropriate string reporting the light count.""""""     return LIGHT_MESSAGES[language] % locals() def is_pirate(message):     """"""Return True if the given message sounds piratical.""""""     return re.search(r""(?i)(arr|avast|yohoho)!"", message) is not None  Testing with tox  tox uses pytest under the hood, hence it supports the same syntax for selecting tests.  For further information please consult the pytest usage docs.  To run a particular test class with tox:  bash tox -e py310 -- '-k TestFindHooks'  To run some tests with names matching a string expression:  bash tox -e py310 -- '-k generate'  Will run all tests matching ""generate"", test_generate_files for example.  To run just one method:  bash tox -e py310 -- '-k ""TestFindHooks and test_find_hook""'  To run all tests using various versions of Python, just run tox:  bash tox  This configuration file setup the pytest-cov plugin and it is an additional dependency. It generate a coverage report after the tests.  It is possible to test with specific versions of Python. To do this, the command is:  bash tox -e py37,py38  This will run py.test with the python3.7 and python3.8 interpreters.  Core Committer Guide  Vision and Scope  Core committers, use this section to:  Guide your instinct and decisions as a core committer  Limit the codebase from growing infinitely  Command-Line Accessible  Provides a command-line utility that creates projects from cookiecutters  Extremely easy to use without having to think too hard  Flexible for more complex use via optional arguments  API Accessible  Entirely function-based and stateless (Class-free by intentional design)  Usable in pieces for developers of template generation tools  Being Jinja2-specific  Sets a standard baseline for project template creators, facilitating reuse  Minimizes the learning curve for those who already use Flask or Django  Minimizes scope of Cookiecutter codebase  Extensible  Being extendable by people with different ideas for Jinja2-based project template tools.  Entirely function-based  Aim for statelessness  Lets anyone write more opinionated tools  Freedom for Cookiecutter users to build and extend.  No officially-maintained cookiecutter templates, only ones by individuals  Commercial project-friendly licensing, allowing for private cookiecutters and private Cookiecutter-based tools  Fast and Focused  Cookiecutter is designed to do one thing, and do that one thing very well.  Cover the use cases that the core committers need, and as little as possible beyond that :)  Generates project templates from the command-line or API, nothing more  Minimize internal line of code (LOC) count  Ultra-fast project generation for high performance downstream tools  Inclusive  Cross-platform and cross-version support are more important than features/functionality  Fixing Windows bugs even if it's a pain, to allow for use by more beginner coders  Stable  Aim for 100% test coverage and covering corner cases  No pull requests will be accepted that drop test coverage on any platform, including Windows  Conservative decisions patterned after CPython's conservative decisions with stability in mind  Stable APIs that tool builders can rely on  New features require a +1 from 3 core committers  VCS-Hosted Templates  Cookiecutter project templates are intentionally hosted VCS repos as-is.  They are easily forkable  It's easy for users to browse forks and files  They are searchable via standard Github/Bitbucket/other search interface  Minimizes the need for packaging-related cruft files  Easy to create a public project template and host it for free  Easy to collaborate  Process: Pull Requests  If a pull request is untriaged:  Look at the roadmap  Set it for the milestone where it makes the most sense  Add it to the roadmap  How to prioritize pull requests, from most to least important:  Fixes for broken tests. Broken means broken on any supported platform or Python version.  Extra tests to cover corner cases.  Minor edits to docs.  Bug fixes.  Major edits to docs.  Features.  Pull Requests Review Guidelines  Think carefully about the long-term implications of the change.   How will it affect existing projects that are dependent on this?   If this is complicated, do we really want to maintain it forever?  Take the time to get things right, PRs almost always require additional improvements to meet the bar for quality.   Be very strict about quality.  When you merge a pull request take care of closing/updating every related issue explaining how they were affected by those changes.   Also, remember to add the author to AUTHORS.md.  Process: Issues  If an issue is a bug that needs an urgent fix, mark it for the next patch release. Then either fix it or mark as please-help.  For other issues: encourage friendly discussion, moderate debate, offer your thoughts.  New features require a +1 from 2 other core committers (besides yourself).  Process: Roadmap  The roadmap located here  Due dates are flexible. Core committers can change them as needed. Note that GitHub sort on them is buggy.  How to number milestones:  Follow semantic versioning. Look at: http://semver.org  Milestone size:  If a milestone contains too much, move some to the next milestone.  Err on the side of more frequent patch releases.  Process: Your own code changes  All code changes, regardless of who does them, need to be reviewed and merged by someone else. This rule applies to all the core committers.  Exceptions:  Minor corrections and fixes to pull requests submitted by others.  While making a formal release, the release manager can make necessary, appropriate changes.  Small documentation changes that reinforce existing subject matter.   Most commonly being, but not limited to spelling and grammar corrections.  Responsibilities  Ensure cross-platform compatibility for every change that's accepted. Windows, macOS and Linux.  Create issues for any major changes and enhancements that you wish to make.   Discuss things transparently and get community feedback.  Don't add any classes to the codebase unless absolutely needed.   Err on the side of using functions.  Keep feature versions as small as possible, preferably one new feature per version.  Be welcoming to newcomers and encourage diverse new contributors from all backgrounds.   Look at Code of Conduct.  Becoming a Core Committer  Contributors may be given core commit privileges. Preference will be given to those with:  Past contributions to Cookiecutter and other open-source projects.    Contributions to Cookiecutter include both code (both accepted and pending) and friendly participation in the issue tracker.    Quantity and quality are considered.  A coding style that the other core committers find simple, minimal, and clean.  Access to resources for cross-platform development and testing.  Time to devote to the project regularly."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\HISTORY.md,HISTORY.md_chunk0,"History  History is important, but our current roadmap can be found here  2.6.0 (2024-02-21)  Minor Changes  Support Python 3.12 (#1989) @ericof  Modifying Jinja2 start and end variable strings (#1997) @sacha-c  CI/CD and QA changes  Add isort as a pre-commit hook (#1988) @kurtmckee  Bump actions/setup-python from 4 to 5 (#2000) @dependabot  Bump actions/upload-artifact from 3 to 4 (#1999) @dependabot  Quick resolution of #2003 (#2004) @jensens  Support Python 3.12 (#1989) @ericof  [pre-commit.ci] pre-commit autoupdate (#1996) @pre-commit-ci  Quick resolution of #2003 (#2004) @jensens  Documentation updates  Support Python 3.12 (#1989) @ericof  Bugfixes  Fix regression #2009: Adding value to nested dicts broken (#2010) @jensens  Fixed errors caused by invalid config files. (#1995) @alanverresen  This release is made by wonderful contributors:  @alanverresen, @dependabot, @dependabot[bot], @ericof, @jensens, @kurtmckee, @pre-commit-ci, @pre-commit-ci[bot] and @sacha-c  2.5.0 (2023-11-21)  Minor Changes  Default values can be passed as a dict (#1924) @matveyvarg  Implement new style for nested templates config (#1981) @ericof  CI/CD and QA changes  Bump actions/checkout from 3 to 4 (#1953) @dependabot  [pre-commit.ci] pre-commit autoupdate (#1977) @pre-commit-ci  [pre-commit.ci] pre-commit autoupdate (#1957) @pre-commit-ci  Documentation updates  Add argument run to pipx command in README.md (#1964) @staeff  Fix tutorial2 generated HTML (#1971) @aantoin  Update README.md (#1967) @HarshRanaOC  Update README.md to fix broken link (#1952) @david-abn  Update README.md to include installation instructions (#1949) @david-abn  Update cookiecutter-plone-starter link in readme (#1965) @zahidkizmaz  Bugfixes  Fix FileExistsError when using a relative template path (#1968) @pkrueger-cariad  Fix recursive context overwrites (#1961) @padraic-padraic  This release is made by wonderful contributors:  @HarshRanaOC, @aantoin, @david-abn, @dependabot, @dependabot[bot], @ericof, @matveyvarg, @padraic-padraic, @pkrueger-cariad, @pre-commit-ci, @pre-commit-ci[bot], @staeff and @zahidkizmaz  2.4.0 (2023-09-29)  Minor Changes  Gracefully handle files with mixed lined endings (#1942) @EricHripko  Implement a pre_prompt hook that will run before prompts (#1950) @ericof  Documentation updates  Implement a pre_prompt hook that will run before prompts (#1950) @ericof  update main docstrings to include overwrite_if_exists and skip_if_file_exists (#1947) @david-abn  This release is made by wonderful contributors:  @EricHripko, @david-abn and @ericof  2.3.1 (2023-09-21)  Minor Changes  add checkout details to the context (fixes #1759) (#1923) @JonZeolla  CI/CD and QA changes  Update the black pre-commit hook URL and version (#1934) @kurtmckee  Use UTF-8 for file reading/writing (#1937) @rmartin16  Documentation updates  Add missing ""parent dir"" symbol in tutorial 2 (#1932) @tvoirand  Remove colons from exemplary prompt messages (#1912) @paduszyk  docs: add install instruction for Void Linux (#1917) @tranzystorek-io  Bugfixes  Fix nested templates in Git repository (#1922) @BTatlock  Fix prompt counter. (#1940) @ericof  Fix variables with null default not being required (#1919) (#1920) @limtis0  This release is made by wonderful contributors:  @BTatlock, @JonZeolla, @ericof, @kurtmckee, @limtis0, @paduszyk, @rmartin16, @tranzystorek-io and @tvoirand  2.3.0 (2023-08-03)  Minor Changes  Improve style of prompts using rich (#1901) @vemonet  CI/CD and QA changes  Bump paambaati/codeclimate-action from 4.0.0 to 5.0.0 (#1908) @dependabot  [pre-commit.ci] pre-commit autoupdate (#1907) @pre-commit-ci  Bugfixes  Fix replay (#1904) @vemonet  Support multichoice overwrite (#1903) @Meepit  This release is made by wonderful contributors:  @Meepit, @dependabot, @dependabot[bot], @ericof, @pre-commit-ci, @pre-commit-ci[bot] and @vemonet  2.2.3 (2023-07-11)  Changes  Minor Changes  Add support for adding human-readable labels for choices when defining multiple choices questions (#1898) @vemonet  Prompt with replay file (#1758) @w1ndblow  CI/CD and QA changes  Set cookiecutter/VERSION.txt as source of truth for version number (#1896) @ericof  [pre-commit.ci] pre-commit autoupdate (#1897) @pre-commit-ci  Bugfixes  Fix issue where the prompts dict was not passed for yes_no questions (#1895) @vemonet  Set cookiecutter/VERSION.txt as source of truth for version number (#1896) @ericof  This release is made by wonderful contributors:  @ericof, @pre-commit-ci, @pre-commit-ci[bot], @vemonet and @w1ndblow  2.2.2 (2023-07-10)  CI/CD and QA changes  Improve gitignore (#1889) @audreyfeldroy  Add warning for jinja2_time (#1890) @henryiii  This release is made by wonderful contributors:  @audreyfeldroy, @ericof and @henryiii  2.2.0 (2023-07-06)  Changes  Added timeout on request.get() for ensuring that if a recipient serve… (#1772) @openrefactory  Fixing Carriage Return Line Feed (CRLF) order in docs #1792 (#1793) @Lahiry  Reduce I/O (#1877) @kurtmckee  Remove a pre-commit hook special case (#1875) @kurtmckee  Remove universal bdist_wheel option; use ""python -m build"" (#1739) @mwtoews  Remove unused import from post-generate hook script example (#1795) @KAZYPinkSaurus  Standardize newlines for all platforms (#1870) @kurtmckee  feat: Add resolved template repository path as _repo_dir to the context (#1771) @tmeckel  Minor Changes  Added support for providing human-readable prompts to the different variables (#1881) @vemonet  Added: Boolean variable support in JSON (#1626) @liortct  Added: CLI option to keep project files on failure. (#1669) @MaciejPatro  Added: Support partially overwrite keys in nested dict (#1692) @cksac  Added: Templates inheritance (#1485) @simobasso  Code quality: Tests upgrade: Use pathlib for files read/write (#1718) @insspb  Inline jinja2-time extension code (#1779) @tranzystorek-io  Support Python 3.11 (#1850) @kurtmckee  Support nested config files (#1770) @dariocurr  preserves original options in _cookiecutter (#1874) @kjaymiller  CI/CD and QA changes  Add a Dependabot config to autoupdate GitHub workflow actions (#1851) @kurtmckee  Added: Readthedocs build config (#1707) @insspb  Bump actions/setup-python from 3 to 4 (#1854) @dependabot  Bump paambaati/codeclimate-action from 3.0.0 to 4.0.0 (#1853) @dependabot  CI/CD: Tox -> Nox: Added nox configuration (#1706) @insspb  CI/CD: Tox -> Nox: Github actions definition minimized + Sync nox and github actions (#1714) @insspb  CI/CD: Tox -> Nox: Makefile update: Removed watchmedo and sed dependency, tox replaced with nox (#1713) @insspb  CI/CD: Updated .pre-commit-config.yaml to use latest hooks versions (#1712) @insspb  Code quality: Core files: Added exception reason reraise when exception class changed (PEP 3134) (#1719) @insspb  Code quality: Tests upgrade: Use pathlib for files read/write (#1718) @insspb  Code quality: core files: Format replaced with f-strings (#1716) @insspb  Code quality: find.py refactored and type annotated (#1721) @insspb  Code quality: tests files: Simplify statements fixes (#1717) @insspb  Code quality: utils.make_sure_path_exists refactored and type annotated (#1722) @insspb  Fixed: recommonmark replaced with myst, as recommonmark is deprecated (#1709) @insspb  Pretty-format JSON files (#1864) @kurtmckee  Rename master to main so CI runs correctly on merge (#1852) @kurtmckee  Standardize EOF newlines (#1876) @kurtmckee  Update .gitignore and cite where it was copied from (#1879) @kurtmckee  Update base docs, remove tox (#1858) @ericof  Update pre-commit hook versions (#1849) @kurtmckee  Updated: Release drafter configuration (#1704) @insspb  Use tox (#1866) @kurtmckee  Verify an expected warning is raised (#1869) @kurtmckee  fixed failing lint ci action by updating repo of flake8 (#1838) @Tamronimus  Documentation updates  Add jinja env docs (#1872) @pamelafox  Documentation extension: Create a Cookiecutter From Scratch tutorial (#1592) @miro-jelaska  Easy PR! Fix typos and add minor doc updates (#1741) @Alex0Blackwell  Expand cli documentation relating to the no-input flag (#1543) (#1587) @jeremyswerdlow  Fix @audreyr to @audreyfeldroy github account rename (#1604) @ri0t  Fixed broken links to jinja docs (#1691) @insspb  Fixed minor typos in docs (#1753) @segunb  Fixed: Python code block in the replay documentation (#1715) @juhannc  Fixed: recommonmark replaced with myst, as recommonmark is deprecated (#1709) @insspb  Improve Docs Readability (#1690) @ryanrussell  Update base docs, remove tox (#1858) @ericof  Updated: Boolean Variables documentation and docstrings (#1705) @italomaia  docs: fix simple typo, shat -> that (#1749) @timgates42  fixing badge display problem (#1798) @Paulokim1  Bugfixes  Fixed the override not working with copy only dir #1650 (#1651) @zhongdai  Fixed: Removed mention of packages versions, to exclude dependabot warnings alerts (#1711) @insspb  cleanup files if panics during hooks - bugfix (#1760) @liortct  This release is made by wonderful contributors:  @Alex0Blackwell, @KAZYPinkSaurus, @Lahiry, @MaciejPatro, @Paulokim1, @Tamronimus, @cksac, @cookies-xor-cream, @dariocurr, @dependabot, @dependabot[bot], @ericof, @insspb, @italomaia, @jeremyswerdlow, @juhannc, @kjaymiller, @kurtmckee, @liortct, @miro-jelaska, @mwtoews, @openrefactory, @pamelafox, @ri0t, @ryanrussell, @segunb, @simobasso, @timgates42, @tmeckel, @tranzystorek-io, @vemonet and @zhongdai  2.1.1 (2022-06-01)  Documentation updates  Fix local extensions documentation (#1686) @alkatar21  Bugfixes  Sanitize Mercurial branch information before checkout. (#1689) @ericof  This release is made by wonderfull contributors:  @alkatar21, @ericof and @jensens  2.1.0 (2022-05-30)  Changes  Move contributors and backers to credits section (#1599) @doobrie  test_generate_file_verbose_template_syntax_error fixed (#1671) @MaciejPatro  Removed changes related to setuptools_scm (#1629) @ozer550  Feature/local extensions (#1240) @mwesterhof  CI/CD and QA changes  Check manifest: pre-commit, fixes, cleaning (#1683) @jensens  Follow PyPA guide to release package using GitHub Actions. (#1682) @ericof  Documentation updates  Fix typo in dict_variables.rst (#1680) @ericof  Documentation overhaul (#1677) @jensens  Fixed incorrect link on docs. (#1649) @luzfcb  Bugfixes  Restore accidentally deleted support for click 8.x (#1643) @jaklan  This release was made possible by our wonderful contributors:  @doobrie, @jensens, @ericof, @luzfcb  2.0.2 (2021-12-27)  Remark: This release never made it to official PyPI  Fix Python version number in cookiecutter --version and test on Python 3.10 (#1621) @ozer550  Removed changes related to setuptools_scm (#1629) @audreyfeldroy @ozer550  2.0.1 (2021-12-11)  Remark: This release never made it to official PyPI  Breaking Changes  Release preparation for 2.0.1rc1 (#1608) @audreyfeldroy  Replace poyo with pyyaml. (#1489) @dHannasch  Added: Path templates will be rendered when copy_without_render used (#839) @noirbizarre  Added: End of line detection and configuration. (#1407) @insspb  Remove support for python2.7 (#1386) @ssbarnea  Minor Changes  Adopt setuptools-scm packaging (#1577) @ssbarnea  Log the error message when git clone fails, not just the return code (#1505) @logworthy  allow jinja 3.0.0 (#1548) @wouterdb  Added uuid extension to be able to generate uuids (#1493) @jonaswre  Alert user if choice is invalid (#1496) @dHannasch  Replace poyo with pyyaml. (#1489) @dHannasch  update AUTHOR lead (#1532) @HosamAlmoghraby  Add Python 3.9 (#1478) @gliptak  Added: --list-installed cli option, listing already downloaded cookiecutter packages (#1096) @chrisbrake  Added: Jinja2 Environment extension on files generation stage (#1419) @insspb  Added: --replay-file cli option, for replay file distributing (#906) @Cadair  Added: _output_dir to cookiecutter context (#1034) @Casyfill  Added: CLI option to ignore hooks (#992) @rgreinho  Changed: Generated projects can use multiple type hooks at same time. (sh + py) (#974) @milonimrod  Added: Path templates will be rendered when copy_without_render used (#839) @noirbizarre  Added: End of line detection and configuration. (#1407) @insspb  Making code python 3 only: Remove python2 u' sign, fix some strings (#1402) @insspb  py3: remove futures, six and encoding (#1401) @insspb  Render variables starting with an underscore. (#1339) @smoothml  Tests refactoring: test_utils write issues fixed #1405 (#1406) @insspb  CI/CD and QA changes  enable branch coverage (#1542) @simobasso  Make release-drafter diff only between master releases (#1568) @SharpEdgeMarshall  ensure filesystem isolation during tests execution (#1564) @simobasso  add safety ci step (#1560) @simobasso  pre-commit: add bandit hook (#1559) @simobasso  Replace tmpdir in favour of tmp_path (#1545) @SharpEdgeMarshall  Fix linting in CI (#1546) @SharpEdgeMarshall  Coverage 100% (#1526) @SharpEdgeMarshall  Run coverage with matrix (#1521) @SharpEdgeMarshall  Lint rst files (#1443) @ssbarnea  Python3: Changed io.open to build-in open (PEP3116) (#1408) @insspb  Making code python 3 only: Remove python2 u' sign, fix some strings (#1402) @insspb  py3: remove futures, six and encoding (#1401) @insspb  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Tests refactoring: test_utils write issues fixed #1405 (#1406) @insspb  Added: Automatic PyPI deploy on tag creation (#1400) @insspb  Changed: Restored coverage reporter (#1399) @insspb  Documentation updates  Fix pull requests checklist reference (#1537) @glumia  Fix author name (#1544) @HosamAlmoghraby  Add missing contributors (#1535) @glumia  Update CONTRIBUTING.md (#1529) @glumia  Update LICENSE (#1519) @simobasso  docs: rewrite the conditional files / directories example description. (#1437) @lyz-code  Fix incorrect years in release history (#1473) @graue70  Add slugify in the default extensions list (#1470) @oncleben31  Renamed cookiecutter.package to API (#1442) @grrlic  Fixed wording detail (#1427) @steltenpower  Changed: CLI Commands documentation engine (#1418) @insspb  Added: Example for conditional files / directories in hooks (#1397) @xyb  Changed: README.md PyPI URLs changed to the modern PyPI last version (#1391) @brettcannon  Fixed: Comma in README.md (#1390) @Cy-dev-tex  Fixed: Replaced no longer maintained pipsi by pipx (#1395) @ndclt  Bugfixes  Add support for click 8.x (#1569) @cjolowicz  Force click<8.0.0 (#1562) @SharpEdgeMarshall  Remove direct dependency on markupsafe (#1549) @ssbarnea  fixes prompting private rendered dicts (#1504) @juhuebner  User's JSON parse error causes ugly Python exception #809 (#1468) @noone234  config: set default on missing default_context key (#1516) @simobasso  Fixed: Values encoding on Windows (#1414) @agateau  Fixed: Fail with gitolite repositories (#1144) @javiersanp  MANIFEST: Fix file name extensions (#1387) @sebix  Deprecations  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Removed support for Python 3.6 and PyPy (#1608) @audreyfeldroy  This release was made possible by our wonderful contributors:  @Cadair, @Casyfill, @Cy-dev-tex, @HosamAlmoghraby, @SharpEdgeMarshall, @agateau, @audreyfeldroy, @brettcannon, @chrisbrake, @cjolowicz, @dHannasch, @gliptak, @glumia, @graue70, @grrlic, @insspb, @javiersanp, @jonaswre, @jsoref, @Jthevos, @juhuebner, @logworthy, @lyz-code, @milonimrod, @ndclt, @noirbizarre, @noone234, @oncleben31, @ozer550, @rgreinho, @sebix, @Sahil-101, @simobasso, @smoothml, @ssbarnea, @steltenpower, @wouterdb, @xyb, Christopher Wolfe and Hosam Almoghraby ( RIAG Digital )  1.7.2 (2020-04-21)  Fixed: Jinja2&Six version limits causing build errors with ansible project @insspb (#1385)  1.7.1 (2020-04-21)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\HISTORY.md,HISTORY.md_chunk1,"Fix incorrect years in release history (#1473) @graue70  Add slugify in the default extensions list (#1470) @oncleben31  Renamed cookiecutter.package to API (#1442) @grrlic  Fixed wording detail (#1427) @steltenpower  Changed: CLI Commands documentation engine (#1418) @insspb  Added: Example for conditional files / directories in hooks (#1397) @xyb  Changed: README.md PyPI URLs changed to the modern PyPI last version (#1391) @brettcannon  Fixed: Comma in README.md (#1390) @Cy-dev-tex  Fixed: Replaced no longer maintained pipsi by pipx (#1395) @ndclt  Bugfixes  Add support for click 8.x (#1569) @cjolowicz  Force click<8.0.0 (#1562) @SharpEdgeMarshall  Remove direct dependency on markupsafe (#1549) @ssbarnea  fixes prompting private rendered dicts (#1504) @juhuebner  User's JSON parse error causes ugly Python exception #809 (#1468) @noone234  config: set default on missing default_context key (#1516) @simobasso  Fixed: Values encoding on Windows (#1414) @agateau  Fixed: Fail with gitolite repositories (#1144) @javiersanp  MANIFEST: Fix file name extensions (#1387) @sebix  Deprecations  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Removed support for Python 3.6 and PyPy (#1608) @audreyfeldroy  This release was made possible by our wonderful contributors:  @Cadair, @Casyfill, @Cy-dev-tex, @HosamAlmoghraby, @SharpEdgeMarshall, @agateau, @audreyfeldroy, @brettcannon, @chrisbrake, @cjolowicz, @dHannasch, @gliptak, @glumia, @graue70, @grrlic, @insspb, @javiersanp, @jonaswre, @jsoref, @Jthevos, @juhuebner, @logworthy, @lyz-code, @milonimrod, @ndclt, @noirbizarre, @noone234, @oncleben31, @ozer550, @rgreinho, @sebix, @Sahil-101, @simobasso, @smoothml, @ssbarnea, @steltenpower, @wouterdb, @xyb, Christopher Wolfe and Hosam Almoghraby ( RIAG Digital )  1.7.2 (2020-04-21)  Fixed: Jinja2&Six version limits causing build errors with ansible project @insspb (#1385)  1.7.1 (2020-04-21)  This release was focused on internal code and CI/CD changes. During this release all code was verified to match pep8, pep257 and other code-styling guides. Project CI/CD was significantly changed, Windows platform checks based on Appveyor engine was replaced by GitHub actions tests. Appveyor was removed. Also our CI/CD was extended with Mac builds, to verify project builds on Apple devices.  Important Changes:  Added: Added debug messages for get_user_config @ssbarnea (#1357)  Multiple templates per one repository feature added. @RomHartmann (#1224, #1063)  Update replay.py json.dump indent for easy viewing @nicain (#1293)  'future' library replaced with 'six' as a more lightweight python porting library @asottile (#941)  Added extension: Slugify template filter @ppanero (#1336)  Added command line option: --skip-if-file-exists, allow to skip the existing files when doing overwrite_if_exists. @chhsiao1981 (#1076)  Some packages versions limited to be compatible with python2.7 and python 3.5 @insspb (#1349)  Internal CI/CD and tests changes:  Coverage comment in future merge requests disabled @ssbarnea (#1279)  Fixed Python 3.8 travis tests and setup.py message @insspb (#1295, #1297)  Travis builds extended with Windows setup for all supported python versions @insspb (#1300, #1301)  Update .travis.yml to be compatible with latest travis cfg specs @luzfcb (#1346)  Added new test to improve tests coverage @amey589 (#1023)  Added missed coverage lines highlight to pytest-coverage report @insspb (#1352)  pytest-catchlog package removed from test_requirements, as now it is included in pytest @insspb (#1347)  Fixed cov-report tox invocation environment @insspb (#1350)  Added: Release drafter support and configuration to exclude changelog update work and focus on development @ssbarnea @insspb (#1356, #1362)  Added: CI/CD steps for Github actions to speedup CI/CD @insspb (#1360)  Removed: Appveyor CI/CD completely removed @insspb @ssbarnea @insspb (#1363, #1367)  Code style and docs changes:  Added black formatting verification on lint stage + project files reformatting @ssbarnea @insspb (#1368)  Added pep257 docstring for tests/* files @insspb (#1369, #1370, #1371, #1372, #1373, #1374, #1375, #1376, #1377, #1378, #1380, #1381)  Added pep257 docstring for tests/conftests.py @kishan (#1272, #1263)  Added pep257 docstring for tests/replay/conftest.py @kishan (#1270, #1268)  Added pep257 docstring for docs/init.py @kishan (#1273, #1265)  Added missing docstring headers to all files @croesnick (#1269, #1283)  Gitter links replaced by Slack in README @browniebroke (#1282)  flake8-docstrings tests added to CI/CD @ssbarnea (#1284)  Activated pydocstyle rule: D401 - First line should be in imperative mood @ssbarnea (#1285)  Activated pydocstyle rule: D200 - One-line docstring should fit on one line with quotes @ssbarnea (#1288)  Activated pydocstyle rule: D202 - No blank lines allowed after function docstring @ssbarnea (#1288)  Activated pydocstyle rule: D205 - 1 blank line required between summary line and description @ssbarnea (#1286, #1287)  Activated pydocstyle rule: ABS101 @ssbarnea (#1288)  Replaced click documentation links to point to version 7 @igorbasko01 (#1303)  Updated submodule link to latest version with documentation links fix @DanBoothDev (#1388)  Fixed links in main README file. @insspb (#1342)  Fix indentation of .cookiecutterrc in README.md @mhsekhavat (#1322)  Changed format of loggers invocation @insspb (#1307)  1.7.0 (2019-12-22) Old friend  Important Changes:  Drop support for EOL Python 3.4, thanks to @jamescurtin and @insspb (#1024)  Drop support for EOL Python 3.3, thanks to @hugovk (#1024)  Increase the minimum click version to 7.0, thanks to @rly and @luzfcb (#1168)  Other Changes:  PEP257 fixing docstrings in exceptions.py. Thanks to @MinchinWeb (#1237)  PEP257 fixing docstrings in replay.py. Thanks to @kishan (#1234)  PEP257 fixing docstrings in test_unzip.py. Thanks to @tonytheleg and @insspb (#1236, #1262)  Fixed tests sequence for appveyor, to exclude file not found bug. Thanks to @insspb (#1257)  Updates REAMDE.md with svg badge for appveyor. Thanks to @sobolevn (#1254)  Add missing {% endif %} to Choice Variables example. Thanks to @mattstibbs (#1249)  Core documentation converted to Markdown format thanks to @wagnernegrao, @insspb (#1216)  Tests update: use sys.executable when invoking python in python 3 only environment thanks to @vincentbernat (#1221)  Prevent click API v7.0 from showing choices when already shown, thanks to @rly and @luzfcb (#1168)  Test the codebase with python3.8 beta on tox and travis-ci (#1206), thanks to @mihrab34  Add a CODE_OF_CONDUCT.md file to the project, thanks to @andreagrandi (#1009)  Update docstrings in cookiecutter/main.py, cookiecutter/__init__.py, and cookiecutter/log.py to follow the PEP 257 style guide, thanks to @meahow (#998, #999, #1000)  Update docstrings in cookiecutter/utils.py to follow the PEP 257 style guide, thanks to @dornheimer(#1026)  Fix grammar in Choice Variables documentation, thanks to @jubrilissa (#1011)  Update installation docs with links to the Windows Subsystem and GNU utilities, thanks to @Nythiennzo for the PR and @BruceEckel for the review (#1016)  Upgrade flake8 to version 3.5.0, thanks to @cclauss (#1038)  Update tutorial with explanation for how cookiecutter finds the template file, thanks to @accraze(#1025)  Update CI config files to use TOXENV environment variable, thanks to @asottile (#1019)  Improve user documentation for writing hooks, thanks to @jonathansick (#1057)  Make sure to preserve the order of items in the generated cookiecutter context, thanks to @hackebrot (#1074)  Fixed DeprecationWarning for a regular expression on python 3.6, thanks to @reinout (#1124)  Document use of cookiecutter-template topic on GitHub, thanks to @ssbarnea (#1189)  Update README badge links, thanks to @luzfcb (#1207)  Update prompt.py to match pep257 guidelines, thanks to @jairideout (#1105)  Update link to Jinja2 extensions documentation, thanks to @dacog (#1193)  Require pip 9.0.0 or newer for tox environments, thanks to @hackebrot (#1215)  Use io.open contextmanager when reading hook files, thanks to @jcb91 (#1147)  Add more cookiecutter templates to the mix:  cookiecutter-python-cli by @xuanluong (#1003)  cookiecutter-docker-science by @takahi-i (#1040)  cookiecutter-flask-skeleton by @mjhea0 (#1052)  cookiecutter-awesome by @Pawamoy (#1051)  cookiecutter-flask-ask by @machinekoder (#1056)  cookiecutter-data-driven-journalism by @JAStark (#1020)  cookiecutter-tox-plugin by @obestwalter (#1103)  cookiecutter-django-dokku by @mashrikt (#1093)  1.6.0 (2017-10-15) Tim Tam  New Features:  Include template path or template URL in cookiecutter context under _template, thanks to @aroig (#774)  Add a URL abbreviation for GitLab template projects, thanks to @hackebrot (#963)  Add option to use templates from Zip files or Zip URLs, thanks to @freakboy3742 (#961)  Bug Fixes:  Fix an issue with missing default template abbreviations for when a user defined custom abbreviations, thanks to @noirbizarre for the issue report and @hackebrot for the fix (#966, #967)  Preserve existing output directory on project generation failure, thanks to @ionelmc for the report and @michaeljoseph for the fix (#629, #964)  Fix Python 3.x error handling for git operation failures, thanks to @jmcarp (#905)  Other Changes:  Fix broken link to Copy without Render docs, thanks to @coreysnyder04 (#912)  Improve debug log message for when a hook is not found, thanks to @raphigaziano (#160)  Fix module summary and expand_abbreviations() doc string as per pep257, thanks to @terryjbates (#772)  Update doc strings in cookiecutter/cli.py and cookiecutter/config.py according to pep257, thanks to @terryjbates (#922, #931)  Update doc string for is_copy_only_path() according to pep257, thanks to @mathagician and @terryjbates (#935, #949)  Update doc strings in cookiecutter/extensions.py according to pep257, thanks to @meahow (#996)  Fix miscellaneous issues with building docs, thanks to @stevepiercy (#889)  Re-implement Makefile and update several make rules, thanks to @hackebrot (#930)  Fix broken link to pytest docs, thanks to @eyalev for the issue report and @devstrat for the fix (#939, #940)  Add test_requirements.txt file for easier testing outside of tox, thanks to @ramnes (#945)  Improve wording in copy without render docs, thanks to @eyalev (#938)  Fix a number of typos, thanks to @delirious-lettuce (#968)  Improved extra context docs by noting that extra context keys must be present in the template\'s cookiecutter.json, thanks to @karantan for the report and fix (#863, #864)  Added more cookiecutter templates to the mix:  cookiecutter-kata-cpputest by @13coders (#901)  cookiecutter-kata-gtest by @13coders (#901)  cookiecutter-pyramid-talk-python-starter by @mikeckennedy (#915)  cookiecutter-android by @alexfu (#890)  cookiecutter-lux-python by @alexkey (#895)  cookiecutter-git by @tuxredux (#921)  cookiecutter-ansible-role-ci by @ferrarimarco (#903)  cookiecutter_dotfile by @bdcaf (#925)  painless-continuous-delivery by @painless-software         (#927)  cookiecutter-molecule by @retr0h (#954)  sublime-snippet-package-template by @agenoria (#956)  cookiecutter-conda-python by @conda (#969)  cookiecutter-flask-minimal by @candidtim (#977)  cookiecutter-pypackage-rust-cross-platform-publish by @mckaymatt (#957)  cookie-cookie by @tuxredux (#951)  cookiecutter-telegram-bot by @Ars2014 (#984)  python-project-template by @Kwpolska (#986)  wemake-django-template by @wemake-services (#990)  cookiecutter-raml by @genzj (#994)  cookiecutter-anyblok-project by @AnyBlok (#988)  cookiecutter-devenv by @greenguavalabs (#991)  1.5.1 (2017-02-04) Alfajor  New Features:  Major update to installation documentation, thanks to @stevepiercy (#880)  Bug Fixes:  Resolve an issue around default values for dict variables, thanks to @e-kolpakov for raising the issue and @hackebrot for the PR (#882, #884)  Other Changes:  Contributor documentation reST fixes, thanks to @stevepiercy (#878)  Added more cookiecutter templates to the mix:  widget-cookiecutter by @willingc (#781)  cookiecutter-django-foundation by @Parbhat (#804)  cookiecutter-tornado by @hkage (#807)  cookiecutter-django-ansible by @Ivaylo-Bachvarov(#816)  CICADA by @elenimijalis (#840)  cookiecutter-tf-module by @VDuda (#843)  cookiecutter-pyqt4 by @aeroaks (#847)  cookiecutter-golang by @mjhea0 and @lacion (#872, #873)  cookiecutter-elm, cookiecutter-java and cookiecutter-spring-boot by @m-x-k (#879)  1.5.0 (2016-12-18) Alfajor  The primary goal of this release was to add command-line support for passing extra context, address minor bugs and make a number of improvements.  New Features:  Inject extra context with command-line arguments, thanks to @msabramo and @michaeljoseph (#666).  Updated conda installation instructions to work with the new conda-forge distribution of Cookiecutter, thanks to @pydanny and especially @bollwyvl (#232, #705).  Refactor code responsible for interaction with version control systems and raise better error messages, thanks to @michaeljoseph (#778).  Add support for executing cookiecutter using python -m cookiecutter or from a checkout/zip file, thanks to @brettcannon (#788).  New CLI option --debug-file PATH to store a log file on disk. By default no log file is written. Entries for DEBUG level and     higher. Thanks to @hackebrot(#792).  Existing templates in a user\'s cookiecutters_dir (default is ~/.cookiecutters/) can now be referenced by directory name, thanks to @michaeljoseph (#825).  Add support for dict values in cookiecutter.json, thanks to @freakboy3742 and @hackebrot (#815, #858).  Add a jsonify filter to default jinja2 extensions that json.dumps a Python object into a string, thanks to @aroig (#791).  Bug Fixes:  Fix typo in the error logging text for when a hook did not exit successfully, thanks to @luzfcb    (#656)  Fix an issue around replay file names when cookiecutter is used with a relative path to a template, thanks to    @eliasdorneles for raising the issue and @hackebrot for the PR (#752, #753)  Ignore hook files with tilde-suffixes, thanks to @hackebrot (#768)  Fix a minor issue with the code that generates a name for a template, thanks to @hackebrot(#798)  Handle empty hook file or other OS errors, thanks to @christianmlong for raising this bug and @jcarbaugh and @hackebrot for the fix (#632, #729, #862)  Resolve an issue with custom extensions not being loaded for pre_gen_project and post_gen_project hooks, thanks to @cheungnj (#860)  Other Changes:  Remove external dependencies from tests, so that tests can be run w/o network connection, thanks to @hackebrot (#603)  Remove execute permissions on Python files, thanks to @mozillazg (#650)  Report code coverage info from AppVeyor build to codecov, thanks to @ewjoachim (#670)  Documented functions and methods lacking documentation, thanks to @pydanny (#673)  Documented __init__ methods for Environment objects, thanks to @pydanny (#677)  Updated whichcraft to 0.4.0, thanks to @pydanny.  Updated documentation link to Read the Docs, thanks to @natim (#687)  Moved cookiecutter templates and added category links, thanks to @willingc (#674)  Added Github Issue Template, thanks to @luzfcb (#700)  Added ssh repository examples, thanks to @pokoli (#702)  Fix links to the cookiecutter-data-science template and its documentation, thanks to @tephyr for the PR and @willingc for the review (#711, #714)  Update link to docs for Django\'s --template command line option, thanks to @purplediane (#754)  Create hook backup files during the tests as opposed to having them as static files in the repository, thanks to @hackebrot (#789)  Applied PEP 257 docstring conventions to:  environment.py, thanks to @terryjbates (#759)  find.py, thanks to @terryjbates (#761)  generate.py, thanks to @terryjbates (#764)  hooks.py, thanks to @terryjbates (#766)  repository.py, thanks to @terryjbates (#833)  vcs.py, thanks to @terryjbates (#831)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\HISTORY.md,HISTORY.md_chunk2,"Ignore hook files with tilde-suffixes, thanks to @hackebrot (#768)  Fix a minor issue with the code that generates a name for a template, thanks to @hackebrot(#798)  Handle empty hook file or other OS errors, thanks to @christianmlong for raising this bug and @jcarbaugh and @hackebrot for the fix (#632, #729, #862)  Resolve an issue with custom extensions not being loaded for pre_gen_project and post_gen_project hooks, thanks to @cheungnj (#860)  Other Changes:  Remove external dependencies from tests, so that tests can be run w/o network connection, thanks to @hackebrot (#603)  Remove execute permissions on Python files, thanks to @mozillazg (#650)  Report code coverage info from AppVeyor build to codecov, thanks to @ewjoachim (#670)  Documented functions and methods lacking documentation, thanks to @pydanny (#673)  Documented __init__ methods for Environment objects, thanks to @pydanny (#677)  Updated whichcraft to 0.4.0, thanks to @pydanny.  Updated documentation link to Read the Docs, thanks to @natim (#687)  Moved cookiecutter templates and added category links, thanks to @willingc (#674)  Added Github Issue Template, thanks to @luzfcb (#700)  Added ssh repository examples, thanks to @pokoli (#702)  Fix links to the cookiecutter-data-science template and its documentation, thanks to @tephyr for the PR and @willingc for the review (#711, #714)  Update link to docs for Django\'s --template command line option, thanks to @purplediane (#754)  Create hook backup files during the tests as opposed to having them as static files in the repository, thanks to @hackebrot (#789)  Applied PEP 257 docstring conventions to:  environment.py, thanks to @terryjbates (#759)  find.py, thanks to @terryjbates (#761)  generate.py, thanks to @terryjbates (#764)  hooks.py, thanks to @terryjbates (#766)  repository.py, thanks to @terryjbates (#833)  vcs.py, thanks to @terryjbates (#831)  Fix link to the Tryton cookiecutter, thanks to @cedk and @nicoe (#697, #698)  Added PyCon US 2016 sponsorship to README, thanks to @purplediane (#720)  Added a sprint contributor doc, thanks to @phoebebauer (#727)  Converted readthedocs links (.org -> .io), thanks to @adamchainz (#718)  Added Python 3.6 support, thanks to @suledev (#728)  Update occurrences of repo_name in documentation, thanks to @palmerev (#734)  Added case studies document, thanks to @pydanny (#735)  Added first steps cookiecutter creation tutorial, thanks to @BruceEckel (#736)  Reorganised tutorials and setup git submodule to external tutorial, thanks to @dot2dotseurat (#740)  Debian installation instructions, thanks to @ivanlyon (#738)  Usage documentation typo fix., thanks to @terryjbates (#739)  Updated documentation copyright date, thanks to @zzzirk (#747)  Add a make rule to update git submodules, thanks to @hackebrot (#746)  Split up advanced usage docs, thanks to @zzzirk (#749)  Documentation for the no_input option, thanks to @pokoli (#701)  Remove unnecessary shebangs from python files, thanks to @michaeljoseph (#763)  Refactor cookiecutter template identification, thanks to @michaeljoseph (#777)  Add a cli_runner test fixture to simplify CLI tests, thanks to @hackebrot (#790)  Add a check to ensure cookiecutter repositories have JSON context, thanks to @michaeljoseph(#782)  Rename the internal function that determines whether a file should be rendered, thanks to @audreyfeldroy for raising the issue and @hackebrotfor the PR (#741, #802)  Fix typo in docs, thanks to @mwarkentin (#828)  Fix broken link to Invoke docs, thanks to @B3QL (#820)  Add documentation to render_variable function in prompt.py, thanks to @pydanny (#678)  Fix python3.6 travis-ci and tox configuration, thanks to @luzfcb (#844)  Add missing encoding declarations to python files, thanks to @andytom (#852)  Disable poyo logging for tests, thanks to @hackebrot (#855)  Remove pycache directories in make clean-pyc, thanks to @hackebrot (#849)  Refactor hook system to only find the requested hook, thanks to @michaeljoseph (#834)  Add tests for custom extensions in pre_gen_project and post_gen_project hooks, thanks to @hackebrot (#856)  Make the build reproducible by avoiding nondeterministic keyword arguments, thanks to @lamby and @hackebrot (#800, #861)  Extend CLI help message and point users to the github project to engage with the community, thanks to @hackebrot (#859)  Added more cookiecutter templates to the mix:  cookiecutter-funkload-friendly by @tokibito (#657)  cookiecutter-reveal.js by @keimlink (#660)  cookiecutter-python-app by @mdklatt (#659)  morepath-cookiecutter by @href (#672)  hovercraft-slides by @jhermann (#665)  cookiecutter-es6-package by @ratson (#667)  cookiecutter-webpack by @hzdg (#668)  cookiecutter-django-herokuapp by @dulaccc (#374)  cookiecutter-django-aws-eb by @peterlauri (#626)  wagtail-starter-kit by @tkjone (#658)  cookiecutter-dpf-effect by @SpotlightKid (#663)  cookiecutter-dpf-audiotk by @SpotlightKid (#663)  cookiecutter-template by @eviweb (#664)  cookiecutter-angular2 by @matheuspoleza (#675)  cookiecutter-data-science by @pjbull (#680)  cc_django_ember_app by @nanuxbe (#686)  cc_project_app_drf by @nanuxbe (#686)  cc_project_app_full_with_hooks by @nanuxbe (#686)  beat-generator by @ruflin (#695)  cookiecutter-scala by @Plippe (#751)  cookiecutter-snakemake-analysis-pipeline by @xguse (#692)  cookiecutter-py3tkinter by @ivanlyon (#730)  pyramid-cookiecutter-alchemy by @stevepiercy (#745)  pyramid-cookiecutter-starter by @stevepiercy (#745)  pyramid-cookiecutter-zodb by @stevepiercy (#745)  substanced-cookiecutter by @stevepiercy (#745)  cookiecutter-simple-django-cn by @shenyushun (#765)  cookiecutter-pyqt5 by @mandeepbhutani (#797)  cookiecutter-xontrib by @laerus (#817)  cookiecutter-reproducible-science by @mkrapp (#826)  cc-automated-drf-template by @elenimijalis (#832)  1.4.0 (2016-03-20) Shortbread  The goal of this release is changing to a strict Jinja2 environment, paving the way to more awesome in the future, as well as adding support for Jinja2 extensions.  New Features:  Added support for Jinja2 extension support, thanks to @hackebrot (#617).  Now raises an error if Cookiecutter tries to render a template that contains an undefined variable. Makes generation more robust and secure (#586). Work done by @hackebrot (#111, #586, #592)  Uses strict Jinja2 env in prompt, thanks to @hackebrot (#598, #613)  Switched from pyyaml/ruamel.yaml libraries that were problematic across platforms to the pure Python poyo library, thanks to @hackebrot (#557, #569, #621)  User config values for cookiecutters_dir and replay_dir now support environment variable and user home expansion, thanks to   @nfarrar for the suggestion and @hackebrot for the PR (#640,#642)  Add jinja2-time as default extension for dates and times in templates via {% now 'utc' %},thanks to @hackebrot (#653)  Bug Fixes:  Provided way to define options that have no defaults, thanks to @johtso (#587, #588)  Make sure that replay.dump() and replay.load() use the correct user config, thanks to @hackebrot (#590, #594)  Added correct CA bundle for Git on Appveyor, thanks to @maiksensi (#599, #602)  Open HISTORY.rst with utf-8 encoding when reading the changelog, thanks to @0-wiz-0 for submitting the issue and @hackebrot for the fix (#638, #639)  Fix repository indicators for privaterepository urls, thanks to @habnabit for the fix (#595) and @hackebrot for the tests (#655)  Other Changes:  Set path before running tox, thanks to @maiksensi (#615, #620)  Removed xfail in test_cookiecutters, thanks to @hackebrot (#618)  Removed django-cms-plugin on account of 404 error, thanks to @mativs and @pydanny (#593)  Fixed docs/usage.rst, thanks to @macrotim (#604)  Update .gitignore to latest Python.gitignore and ignore PyCharm files, thanks to @audreyfeldroy  Use open context manager to read context_file in generate() function, thanks to @hackebrot (#607, #608)  Added documentation for choice variables, thanks to @maiksensi (#611)  Set up Scrutinizer to check code quality, thanks to @audreyfeldroy  Drop distutils support in setup.py, thanks to @hackebrot (#606, #609)  Change cookiecutter-pypackage-minimal link, thanks to @kragniz (#614)  Fix typo in one of the template\'s description, thanks to @ryanfreckleton (#643)  Fix broken link to _copy_without_render     in troubleshooting.rst, thanks to @ptim (#647)  Added more cookiecutter templates to the mix:  cookiecutter-pipproject by @wdm0006 (#624)  cookiecutter-flask-2 by @wdm0006 (#624)  cookiecutter-kotlin-gradle by @thomaslee (#622)  cookiecutter-tryton-fulfilio by @cedk (#631)  django-starter by @tkjone (#635)  django-docker-bootstrap by @legios89 (#636)  cookiecutter-mediawiki-extension by @JonasGroeger (#645)  cookiecutter-django-gulp by @valerymelou (#648)  1.3.0 (2015-11-10) Pumpkin Spice  The goal of this release is to extend the user config feature and to make hook execution more robust.  New Features:  Abort project generation if pre_gen_project or post_gen_project hook scripts fail, thanks to @eliasdorneles (#464, #549)  Extend user config capabilities with additional cli options --config-file and --default-config and environment variable   COOKIECUTTER_CONFIG, thanks to @jhermann, @pfmoore, and @hackebrot (#258, #424, #565)  Bug Fixes:  Fixed conditional dependencies for wheels in setup.py, thanks to @hackebrot (#557, #568)  Reverted skipif markers to use correct reasons (bug fixed in pytest), thanks to @hackebrot (#574)  Other Changes:  Improved path and documentation for rendering the Sphinx documentation, thanks to @eliasdorneles and @hackebrot (#562, #583)  Added additional help entrypoints, thanks to @michaeljoseph (#563, #492)  Added Two Scoops Academy to the README, thanks to @hackebrot (#576)  Now handling trailing slash on URL, thanks to @ramiroluz (#573, #546)  Support for testing x86 and x86-64 architectures on appveyor, thanks to @maiksensi (#567)  Made tests work without installing Cookiecutter, thanks to @vincentbernat (#550)  Encoded the result of the hook template to utf8, thanks to @ionelmc (#577. #578)  Added test for _run_hook_from_repo_dir, thanks to @hackebrot (#579, #580)  Implemented bumpversion, thanks to @hackebrot (#582)  Added more cookiecutter templates to the mix:  cookiecutter-octoprint-plugin by @foosel (#560)  wagtail-cookiecutter-foundation by @chrisdev, et al. (#566)  1.2.1 (2015-10-18) Zimtsterne  Zimtsterne are cinnamon star cookies.  New Feature:  Returns rendered project dir, thanks to @hackebrot (#553)  Bug Fixes:  Factor in choice variables (as introduced in 1.1.0) when using a user config or extra context, thanks to @ionelmc and @hackebrot (#536, #542).  Other Changes:  Enable py35 support on Travis by using Python 3.5 as base Python (@maiksensi / #540)  If a filename is empty, do not generate. Log instead (@iljabauer / #444)  Fix tests as per last changes in cookiecutter-pypackage, thanks to @eliasdorneles(#555).  Removed deprecated cookiecutter-pylibrary-minimal from the list, thanks to @ionelmc (#556)  Moved to using rualmel.yaml instead of PyYAML, except for Windows users on Python 2.7, thanks     to @pydanny (#557)  Why 1.2.1 instead of 1.2.0? There was a problem in the distribution that we pushed to PyPI. Since you can\'t replace previous files uploaded to PyPI, we deleted the files on PyPI and released 1.2.1.  1.1.0 (2015-09-26) Snickerdoodle  The goals of this release were copy without render and a few additional command-line options such as --overwrite-if-exists, ---replay, and output-dir.  Features:  Added copy without render feature, making it much easier for developers of Ansible, Salt Stack, and other recipe-based tools to work with Cookiecutter. Thanks to @osantana and @LucianU for their innovation, as well as @hackebrot for fixing the Windows problems (#132, #184, #425).  Added specify output directory, thanks to @tony and @hackebrot (#531, #452).  Abort template rendering if the project output directory already exists, thanks to @lgp171188 (#470, #471).  Add a flag to overwrite existing output directory, thanks to @lgp171188 for the implementation (#495) and @schacki, @ionelmc, @pydanny and @hackebrot for submitting issues and code reviews (#475, #493).  Remove test command in favor of tox, thanks to @hackebrot (#480).  Allow cookiecutter invocation, even without installing it, via python -m cookiecutter.cli, thanks to @vincentbernat and @hackebrot (#449, #487).  Improve the type detection handler for online and offline repositories, thanks to @charlax (#490).  Add replay feature, thanks to @hackebrot (#501).  Be more precise when raising an error for an invalid user config file, thanks to @vaab and @hackebrot (#378, #528).  Added official Python 3.5 support, thanks to @pydanny and @hackebrot (#522).  Added support for choice variables and switch to click style prompts, thanks to @hackebrot (#441, #455).  Other Changes:  Updated click requirement to \< 6.0, thanks to @pydanny (#473).  Added landscape.io flair, thanks to @michaeljoseph (#439).  Descriptions of PEP8 specifications and milestone management, thanks to @michaeljoseph (#440).  Added alternate installation options in the documentation, thanks to @pydanny (#117, #315).  The test of the which() function now tests against the date command, thanks to @vincentbernat (#446)  Ensure file handles in setup.py are closed using with statement, thanks to @svisser (#280).  Removed deprecated and fully extraneous compat.is_exe() function, thanks to @hackebrot (#485).  Disabled sudo in .travis, thanks to @hackebrot (#482).  Switched to shields.io for problematic badges, thanks to @pydanny (#491).  Added whichcraft and removed compat.which(), thanks to @pydanny (#511).  Changed to export tox environment variables to codecov, thanks to @maiksensi. (#508).  Moved to using click version command, thanks to @hackebrot (#489).  Don\'t use unicode_literals to please click, thanks to @vincentbernat (#503).  Remove warning for Python 2.6 from __init__.py, thanks to @hackebrot.  Removed compat.py module, thanks to @hackebrot.  Added future to requirements, thanks to @hackebrot.  Fixed problem where expanduser does not resolve \""\~\"" correctly on windows 10 using tox, thanks to @maiksensi. (#527)  Added more cookiecutter templates to the mix:  cookiecutter-beamer by @luismartingil (#307)  cookiecutter-pytest-plugin by @pytest-dev and         @hackebrot (#481)  cookiecutter-csharp-objc-binding by @SandyChapman (#460)  cookiecutter-flask-foundation by @JackStouffer (#457)  cookiecutter-tryton-fulfilio by @fulfilio (#465)  cookiecutter-tapioca by @vintasoftware (#496)  cookiecutter-sublime-text-3-plugin by @kkujawinski (#500)  cookiecutter-muffin by @drgarcia1986 (#494)  cookiecutter-django-rest by @agconti (#520)  cookiecutter-es6-boilerplate by @agconti (#521)  cookiecutter-tampermonkey by @christabor (#516)  cookiecutter-wagtail by @torchbox (#533)  1.0.0 (2015-03-13) Chocolate Chip  The goals of this release was to formally remove support for Python 2.6 and continue the move to using py.test.  Features:  Convert the unittest suite to py.test for the sake of comprehensibility, thanks to @hackebrot (#322, #332, #334, #336, #337, #338, #340, #341, #343, #345, #347, #351, #412, #413, #414).  Generate pytest coverage, thanks to @michaeljoseph (#326).  Documenting of Pull Request merging and HISTORY.rst maintenance, thanks to @michaeljoseph (#330).  Large expansions to the tutorials thanks to @hackebrot (#384)  Switch to using Click for command-line options, thanks to @michaeljoseph (#391, #393).  Added support for working with private repos, thanks to @marctc (#265).  Wheel configuration thanks to @michaeljoseph (#118).  Other Changes:  Formally removed support for 2.6, thanks to @pydanny (#201).  Moved to codecov for continuous integration test coverage and badges, thanks to @michaeljoseph (#71, #369).  Made JSON parsing errors easier to debug, thanks to @rsyring and @mark0978 (#355, #358, #388)."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\HISTORY.md,HISTORY.md_chunk3,"Removed compat.py module, thanks to @hackebrot.  Added future to requirements, thanks to @hackebrot.  Fixed problem where expanduser does not resolve \""\~\"" correctly on windows 10 using tox, thanks to @maiksensi. (#527)  Added more cookiecutter templates to the mix:  cookiecutter-beamer by @luismartingil (#307)  cookiecutter-pytest-plugin by @pytest-dev and         @hackebrot (#481)  cookiecutter-csharp-objc-binding by @SandyChapman (#460)  cookiecutter-flask-foundation by @JackStouffer (#457)  cookiecutter-tryton-fulfilio by @fulfilio (#465)  cookiecutter-tapioca by @vintasoftware (#496)  cookiecutter-sublime-text-3-plugin by @kkujawinski (#500)  cookiecutter-muffin by @drgarcia1986 (#494)  cookiecutter-django-rest by @agconti (#520)  cookiecutter-es6-boilerplate by @agconti (#521)  cookiecutter-tampermonkey by @christabor (#516)  cookiecutter-wagtail by @torchbox (#533)  1.0.0 (2015-03-13) Chocolate Chip  The goals of this release was to formally remove support for Python 2.6 and continue the move to using py.test.  Features:  Convert the unittest suite to py.test for the sake of comprehensibility, thanks to @hackebrot (#322, #332, #334, #336, #337, #338, #340, #341, #343, #345, #347, #351, #412, #413, #414).  Generate pytest coverage, thanks to @michaeljoseph (#326).  Documenting of Pull Request merging and HISTORY.rst maintenance, thanks to @michaeljoseph (#330).  Large expansions to the tutorials thanks to @hackebrot (#384)  Switch to using Click for command-line options, thanks to @michaeljoseph (#391, #393).  Added support for working with private repos, thanks to @marctc (#265).  Wheel configuration thanks to @michaeljoseph (#118).  Other Changes:  Formally removed support for 2.6, thanks to @pydanny (#201).  Moved to codecov for continuous integration test coverage and badges, thanks to @michaeljoseph (#71, #369).  Made JSON parsing errors easier to debug, thanks to @rsyring and @mark0978 (#355, #358, #388).  Updated to Jinja 2.7 or higher in order to control trailing new lines in templates, thanks to @sfermigier (#356).  Tweaked flake8 to ignore e731, thanks to @michaeljoseph (#390).  Fixed failing Windows tests and corrected AppVeyor badge link thanks to @msabramo (#403).  Added more Cookiecutters to the list:  cookiecutter-scala-spark by @jpzk  cookiecutter-atari2600 by @joeyjoejoejr  cookiecutter-bottle by @avelino  cookiecutter-latex-article by @Kreger51  cookiecutter-django-rest-framework by @jpadilla  cookiedozer by @hackebrot  0.9.0 (2015-01-13)  The goals of this release were to add the ability to Jinja2ify the cookiecutter.json default values, and formally launch support for Python 3.4.  Features:  Python 3.4 is now a first class citizen, thanks to everyone.  cookiecutter.json values are now rendered Jinja2 templates, thanks to \@bollwyvl (#291).  Move to py.test, thanks to @pfmoore (#319) and @ramiroluz (#310).  Add PendingDeprecation warning for users of Python 2.6, as support for it is gone in Python 2.7, thanks to @michaeljoseph (#201).  Bug Fixes:  Corrected typo in Makefile, thanks to @inglesp (#297).  Raise an exception when users don\'t have git or hg installed, thanks to @pydanny (#303).  Other changes:  Creation of gitter account for logged chat, thanks to @michaeljoseph.  Added ReadTheDocs badge, thanks to @michaeljoseph.  Added AppVeyor badge, thanks to @pydanny  Documentation and PyPI trove classifier updates, thanks to @thedrow (#323 and #324)  0.8.0 (2014-10-30)  The goal of this release was to allow for injection of extra context via the Cookiecutter API, and to fix minor bugs.  Features:  cookiecutter() now takes an optional extra_context parameter, thanks to @michaeljoseph, @fcurella, @aventurella,  @emonty, @schacki, @ryanolson, @pfmoore, @pydanny, @audreyfeldroy (#260).  Context is now injected into hooks, thanks to @michaeljoseph and @dinopetrone.  Moved all Python 2/3 compatibility code into cookiecutter.compat, making the eventual move to six easier, thanks to @michaeljoseph (#60, #102).  Added cookiecutterrc defined aliases for cookiecutters, thanks to @pfmoore (#246)  Added flake8 to tox to check for pep8 violations, thanks to @natim.  Bug Fixes:  Newlines at the end of files are no longer stripped, thanks to @treyhunner (#183).  Cloning prompt suppressed by respecting the no\_input flag, thanks to @trustrachel (#285)  With Python 3, input is no longer converted to bytes, thanks to @uranusjr (#98).  Other Changes:  Added more Cookiecutters to the list:  Python-iOS-template by @freakboy3742  Python-Android-template by @freakboy3742  cookiecutter-djangocms-plugin by @mishbahr  cookiecutter-pyvanguard by @robinandeer  0.7.2 (2014-08-05)  The goal of this release was to fix cross-platform compatibility, primarily Windows bugs that had crept in during the addition of new features. As of this release, Windows is a first-class citizen again, now complete with continuous integration.  Bug Fixes:  Fixed the contributing file so it displays nicely in Github, thanks to @pydanny.  Updates 2.6 requirements to include simplejson, thanks to @saxix.  Avoid unwanted extra spaces in string literal, thanks to @merwok.  Fix @unittest.skipIf error on Python 2.6.  Let sphinx parse :param: properly by inserting newlines #213, thanks to @mineo.  Fixed Windows test prompt failure by replacing stdin per @cjrh in #195.  Made rmtree remove readonly files, thanks to @pfmoore.  Now using tox to run tests on Appveyor, thanks to @pfmoore (#241).  Fixed tests that assumed the system encoding was utf-8, thanks to @pfmoore (#242, #244).  Added a tox ini file that uses py.test, thanks to @pfmoore (#245).  Other Changes:  @audreyfeldroy formally accepted position as BDFL of cookiecutter.  Elevated @pydanny, @michaeljoseph, and @pfmoore to core committer status.  Added Core Committer guide, by @audreyfeldroy.  Generated apidocs from make docs, by @audreyfeldroy.  Added contributing command to the makedocs function, by @pydanny.  Refactored contributing documentation, included adding core committer instructions, by @pydanny and @audreyfeldroy.  Do not convert input prompt to bytes, thanks to @uranusjr (#192).  Added troubleshooting info about Python 3.3 tests and tox.  Added documentation about command line arguments, thanks to @saxix.  Style cleanups.  Added environment variable to disable network tests for environments without networking, thanks to @vincentbernat.  Added Appveyor support to aid Windows integrations, thanks to @pydanny (#215).  CONTRIBUTING.rst is now generated via make contributing, thanks to @pydanny (#220).  Removed unnecessary endoing argument to json.load, thanks to @pfmoore (#234).  Now generating shell hooks dynamically for Unix/Windows portability, thanks to @pfmoore (#236).  Removed non-portable assumptions about directory structure, thanks to @pfmoore (#238).  Added a note on portability to the hooks documentation, thanks to @pfmoore (#239).  Replaced unicode_open with direct use of io.open, thanks to @pfmoore (#229).  Added more Cookiecutters to the list:  cookiecutter-kivy by @hackebrot  BoilerplatePP by @Paspartout  cookiecutter-pypackage-minimal by @borntyping  cookiecutter-ansible-role by @iknite  cookiecutter-pylibrary by @ionelmc  cookiecutter-pylibrary-minimal by @ionelmc  0.7.1 (2014-04-26)  Bug fixes:  Use the current Python interpreter to run Python hooks, thanks to @coderanger.  Include tests and documentation in source distribution, thanks to @vincentbernat.  Fix various warnings and missing things in the docs (#129, #130), thanks to @nedbat.  Add command line option to get version (#89), thanks to @davedash and @cyberj.  Other changes:  Add more Cookiecutters to the list:  cookiecutter-avr by @solarnz  cookiecutter-tumblr-theme by @relekang  cookiecutter-django-paas by @pbacterio  0.7.0 (2013-11-09)  This is a release with significant improvements and changes. Please read through this list before you upgrade.  New features:  Support for --checkout argument, thanks to @foobacca.  Support for pre-generate and post-generate hooks, thanks to @raphigaziano. Hooks are Python or shell scripts that run before and/or after your project is generated.  Support for absolute paths to cookiecutters, thanks to @krallin.  Support for Mercurial version control system, thanks to @pokoli.  When a cookiecutter contains invalid Jinja2 syntax, you get a better message that shows the location of the TemplateSyntaxError. Thanks to @benjixx.  Can now prompt the user to enter values during generation from a local cookiecutter, thanks to @ThomasChiroux. This is now always the default behavior. Prompts can also be suppressed with --no-input.  Your cloned cookiecutters are stored by default in your ~/.cookiecutters/ directory (or Windows equivalent). The location is configurable. (This is a major change from the pre-0.7.0 behavior, where cloned cookiecutters were deleted at the end of project generation.) Thanks @raphigaziano.  User config in a \~/.cookiecutterrc file, thanks to @raphigaziano. Configurable settings are cookiecutters_dir and default_context.  File permissions are now preserved during project generation, thanks to @benjixx.  Bug fixes:  Unicode issues with prompts and answers are fixed, thanks to @s-m-i-t-a.  The test suite now runs on Windows, which was a major effort. Thanks to @pydanny, who collaborated on this with me.  Other changes:  Quite a bit of refactoring and API changes.  Lots of documentation improvements. Thanks @sloria, @alex, @pydanny, @freakboy3742, @es128, @rolo.  Better naming and organization of test suite.  A CookiecutterCleanSystemTestCase to use for unit tests affected by the user\'s config and cookiecutters directory.  Improvements to the project\'s Makefile.  Improvements to tests. Thanks @gperetin, @s-m-i-t-a.  Removal of subprocess32 dependency. Now using non-context manager version of subprocess.Popen for Python 2 compatibility.  Removal of cookiecutter\'s cleanup module.  A bit of setup.py cleanup, thanks to @oubiga.  Now depends on binaryornot 0.2.0.  0.6.4 (2013-08-21)  Windows support officially added.  Fix TemplateNotFound Exception on Windows (#37).  0.6.3 (2013-08-20)  Fix copying of binary files in nested paths (#41), thanks to @sloria.  0.6.2 (2013-08-19)  Depend on Jinja2>=2.4 instead of Jinja2==2.7.  Fix errors on attempt to render binary files. Copy them over from the project template without rendering.  Fix Python 2.6/2.7 UnicodeDecodeError when values containing Unicode chars are in cookiecutter.json.  Set encoding in Python 3 unicode_open() to always be utf-8.  0.6.1 (2013-08-12)  Improved project template finding. Now looks for the occurrence of {{,cookiecutter, and }} in a directory name.  Fix help message for input_dir arg at command prompt.  Minor edge cases found and corrected, as a result of improved test coverage.  0.6.0 (2013-08-08)  Config is now in a single cookiecutter.json instead of in json/.  When you create a project from a git repo template, Cookiecutter prompts you to enter custom values for the fields defined in cookiecutter.json.  0.5 (2013-07-28)  Friendlier, more simplified command line usage:  bash     # Create project from the cookiecutter-pypackage/ template     $ cookiecutter cookiecutter-pypackage/     # Create project from the cookiecutter-pypackage.git repo template     $ cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage.git  Can now use Cookiecutter from Python as a package:  ```python     from cookiecutter.main import cookiecutter  ```  Internal refactor to remove any code that changes the working     directory.  0.4 (2013-07-22)  Only takes in one argument now: the input directory. The output directory is generated by rendering the name of the input directory.  Output directory cannot be the same as input directory.  0.3 (2013-07-17)  Takes in command line args for the input and output directories.  0.2.1 (2013-07-17)  Minor cleanup.  0.2 (2013-07-17)  Bumped to ""Development Status :: 3 - Alpha"".  Works with any type of text file.  Directory names and filenames can be templated.  0.1.0 (2013-07-11)  First release on PyPI."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\README.md,README.md_chunk0,"[![pypi](https://img.shields.io/pypi/v/cookiecutter.svg)](https://pypi.org/project/cookiecutter/) [![python](https://img.shields.io/pypi/pyversions/cookiecutter.svg)](https://pypi.org/project/cookiecutter/) [![Build Status](https://github.com/cookiecutter/cookiecutter/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/cookiecutter/cookiecutter/actions) [![codecov](https://codecov.io/gh/cookiecutter/cookiecutter/branch/main/graphs/badge.svg?branch=main)](https://codecov.io/github/cookiecutter/cookiecutter?branch=main) [![discord](https://img.shields.io/badge/Discord-cookiecutter-5865F2?style=flat&logo=discord&logoColor=white)](https://discord.gg/9BrxzPKuEW) [![docs](https://readthedocs.org/projects/cookiecutter/badge/?version=latest)](https://readthedocs.org/projects/cookiecutter/?badge=latest) [![Code Quality](https://img.shields.io/scrutinizer/g/cookiecutter/cookiecutter.svg)](https://scrutinizer-ci.com/g/cookiecutter/cookiecutter/?branch=main)  Cookiecutter  Create projects swiftly from cookiecutters (project templates) with this command-line utility. Ideal for generating Python package projects and more.  Documentation  GitHub  PyPI  License (BSD)  Installation  Install cookiecutter using pip package manager: ```  pipx is strongly recommended.  pipx install cookiecutter  If pipx is not an option,  you can install cookiecutter in your Python user directory.  python -m pip install --user cookiecutter ```  Features  Cross-Platform: Supports Windows, Mac, and Linux.  User-Friendly: No Python knowledge required.  Versatile: Compatible with Python 3.7 to 3.12.  Multi-Language Support: Use templates in any language or markup format.  For Users  Quick Start  The recommended way to use Cookiecutter as a command line utility is to run it with pipx, which can be installed with pip install pipx, but if you plan to use Cookiecutter programmatically, please run pip install cookiecutter.  Use a GitHub template  ```bash  You'll be prompted to enter values.  Then it'll create your Python package in the current working directory,  based on those values.  For the sake of brevity, repos on GitHub can just use the 'gh' prefix  $ pipx run cookiecutter gh:audreyfeldroy/cookiecutter-pypackage ```  Use a local template  bash $ pipx run cookiecutter cookiecutter-pypackage/  Use it from Python  ```py from cookiecutter.main import cookiecutter  Create project from the cookiecutter-pypackage/ template  cookiecutter('cookiecutter-pypackage/')  Create project from the cookiecutter-pypackage.git repo template  cookiecutter('gh:audreyfeldroy//cookiecutter-pypackage.git') ```  Detailed Usage  Generate projects from local or remote templates.  Customize projects with cookiecutter.json prompts.  Utilize pre-prompt, pre- and post-generate hooks.  Learn More  For Template Creators  Utilize unlimited directory nesting.  Employ Jinja2 for all templating needs.  Define template variables easily with cookiecutter.json.  Learn More  Available Templates  Discover a variety of ready-to-use templates on GitHub.  Special Templates  cookiecutter-pypackage  cookiecutter-django  cookiecutter-pytest-plugin  cookiecutter-plone-starter  Community  Join the community, contribute, or seek assistance.  Troubleshooting Guide  Stack Overflow  Discord  File an Issue  Contributors  Contribution Guide  Support  Star us on GitHub.  Stay tuned for upcoming support options.  Feedback  We value your feedback. Share your criticisms or complaints constructively to help us improve.  File an Issue  Waiting for a Response?  Be patient and consider reaching out to the community for assistance.  For urgent matters, contact @audreyfeldroy for consultation or custom development.  Code of Conduct  Adhere to the PyPA Code of Conduct during all interactions in the project's ecosystem.  Acknowledgements  Created and led by Audrey Roy Greenfeld, supported by a dedicated team of maintainers and contributors."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\setup.py,setup.py_chunk0,"""""""cookiecutter distutils configuration.""""""  from pathlib import Path  from setuptools import setup   def _get_version() -> str:     """"""Read cookiecutter/VERSION.txt and return its contents.""""""     path = Path(""cookiecutter"").resolve()     version_file = path / ""VERSION.txt""     return version_file.read_text().strip()   version = _get_version()   with open('README.md', encoding='utf-8') as readme_file:     readme = readme_file.read()   requirements = [     'binaryornot>=0.4.4',     'Jinja2>=2.7,<4.0.0',     'click>=7.0,<9.0.0',     'pyyaml>=5.3.1',     'python-slugify>=4.0.0',     'requests>=2.23.0',     'arrow',     'rich', ]  setup(     name='cookiecutter',     version=version,     description=(         'A command-line utility that creates projects from project '         'templates, e.g. creating a Python package project from a '         'Python package project template.'     ),     long_description=readme,     long_description_content_type='text/markdown',     author='Audrey Feldroy',     author_email='audreyr@gmail.com',     url='https://github.com/cookiecutter/cookiecutter',     project_urls={         ""Documentation"": ""https://cookiecutter.readthedocs.io"",         ""Issues"": ""https://github.com/cookiecutter/cookiecutter/issues"",         ""Discord"": ""https://discord.gg/9BrxzPKuEW"",     },     packages=['cookiecutter'],     package_dir={'cookiecutter': 'cookiecutter'},     entry_points={'console_scripts': ['cookiecutter = cookiecutter.__main__:main']},     include_package_data=True,     python_requires='>=3.7',     install_requires=requirements,     license='BSD',     zip_safe=False,     classifiers=[         ""Development Status :: 5 - Production/Stable"",         ""Environment :: Console"",         ""Intended Audience :: Developers"",         ""Natural Language :: English"",         ""License :: OSI Approved :: BSD License"",         ""Programming Language :: Python :: 3 :: Only"",         ""Programming Language :: Python :: 3"",         ""Programming Language :: Python :: 3.7"",         ""Programming Language :: Python :: 3.8"",         ""Programming Language :: Python :: 3.9"",         ""Programming Language :: Python :: 3.10"",         ""Programming Language :: Python :: 3.11"",         ""Programming Language :: Python :: 3.12"",         ""Programming Language :: Python :: Implementation :: CPython"",         ""Programming Language :: Python :: Implementation :: PyPy"",         ""Programming Language :: Python"",         ""Topic :: Software Development"",     ],     keywords=[         ""cookiecutter"",         ""Python"",         ""projects"",         ""project templates"",         ""Jinja2"",         ""skeleton"",         ""scaffolding"",         ""project directory"",         ""package"",         ""packaging"",     ], )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\__main__.py,__main__.py_chunk0,"""""""Allow cookiecutter to be executable from a checkout or zip file.""""""  import runpy  if __name__ == ""__main__"":     runpy.run_module(""cookiecutter"", run_name=""__main__"")"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\cli.py,cli.py_chunk0,"""""""Main `cookiecutter` CLI.""""""  from __future__ import annotations  import json import os import sys from collections import OrderedDict from typing import TYPE_CHECKING, Any  if TYPE_CHECKING:     from collections.abc import Iterable      from click import Context, Parameter     from typing_extensions import Literal   import click  from cookiecutter import __version__ from cookiecutter.config import get_user_config from cookiecutter.exceptions import (     ContextDecodingException,     EmptyDirNameException,     FailedHookException,     InvalidModeException,     InvalidZipRepository,     OutputDirExistsException,     RepositoryCloneFailed,     RepositoryNotFound,     UndefinedVariableInTemplate,     UnknownExtension, ) from cookiecutter.log import configure_logger from cookiecutter.main import cookiecutter   def version_msg() -> str:     """"""Return the Cookiecutter version, location and Python powering it.""""""     python_version = sys.version     location = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))     return f""Cookiecutter {__version__} from {location} (Python {python_version})""   def validate_extra_context(     _ctx: Context, _param: Parameter, value: Iterable[str] ) -> OrderedDict[str, str] | None:     """"""Validate extra context.""""""     for string in value:         if '=' not in string:             raise click.BadParameter(                 f""EXTRA_CONTEXT should contain items of the form key=value; ""                 f""'{string}' doesn't match that form""             )      # Convert tuple -- e.g.: ('program_name=foobar', 'startsecs=66')     # to dict -- e.g.: {'program_name': 'foobar', 'startsecs': '66'}     return OrderedDict(s.split('=', 1) for s in value) or None   def list_installed_templates(     default_config: bool | dict[str, Any], passed_config_file: str | None ) -> None:     """"""List installed (locally cloned) templates. Use cookiecutter --list-installed.""""""     config = get_user_config(passed_config_file, default_config)     cookiecutter_folder: str = config['cookiecutters_dir']     if not os.path.exists(cookiecutter_folder):         click.echo(             f""Error: Cannot list installed templates. ""             f""Folder does not exist: {cookiecutter_folder}""         )         sys.exit(-1)      template_names = [         folder         for folder in os.listdir(cookiecutter_folder)         if os.path.exists(             os.path.join(cookiecutter_folder, folder, 'cookiecutter.json')         )     ]     click.echo(f'{len(template_names)} installed templates: ')     for name in template_names:         click.echo(f' * {name}')   @click.command(context_settings={""help_option_names"": ['-h', '--help']}) @click.version_option(__version__, '-V', '--version', message=version_msg()) @click.argument('template', required=False) @click.argument('extra_context', nargs=-1, callback=validate_extra_context) @click.option(     '--no-input',     is_flag=True,     help='Do not prompt for parameters and only use cookiecutter.json file content. '     'Defaults to deleting any cached resources and redownloading them. '     'Cannot be combined with the --replay flag.', ) @click.option(     '-c',     '--checkout',     help='branch, tag or commit to checkout after git clone', ) @click.option(     '--directory',     help='Directory within repo that holds cookiecutter.json file '     'for advanced repositories with multi templates in it', ) @click.option(     '-v', '--verbose', is_flag=True, help='Print debug information', default=False ) @click.option(     '--replay',     is_flag=True,     help='Do not prompt for parameters and only use information entered previously. '     'Cannot be combined with the --no-input flag or with extra configuration passed.', ) @click.option(     '--replay-file',     type=click.Path(),     default=None,     help='Use this file for replay instead of the default.', ) @click.option(     '-f',     '--overwrite-if-exists',     is_flag=True,     help='Overwrite the contents of the output directory if it already exists', ) @click.option(     '-s',     '--skip-if-file-exists',     is_flag=True,     help='Skip the files in the corresponding directories if they already exist',     default=False, ) @click.option(     '-o',     '--output-dir',     default='.',     type=click.Path(),     help='Where to output the generated project dir into', ) @click.option(     '--config-file', type=click.Path(), default=None, help='User configuration file' ) @click.option(     '--default-config',     is_flag=True,     help='Do not load a config file. Use the defaults instead', ) @click.option(     '--debug-file',     type=click.Path(),     default=None,     help='File to be used as a stream for DEBUG logging', ) @click.option(     '--accept-hooks',     type=click.Choice(['yes', 'ask', 'no']),     default='yes',     help='Accept pre/post hooks', ) @click.option(     '-l', '--list-installed', is_flag=True, help='List currently installed templates.' ) @click.option(     '--keep-project-on-failure',     is_flag=True,     help='Do not delete project folder on failure', ) def main(     template: str,     extra_context: dict[str, Any],     no_input: bool,     checkout: str,     verbose: bool,     replay: bool | str,     overwrite_if_exists: bool,     output_dir: str,     config_file: str | None,     default_config: bool,     debug_file: str | None,     directory: str,     skip_if_file_exists: bool,     accept_hooks: Literal['yes', 'ask', 'no'],     replay_file: str | None,     list_installed: bool,     keep_project_on_failure: bool, ) -> None:     """"""Create a project from a Cookiecutter project template (TEMPLATE).      Cookiecutter is free and open source software, developed and managed by     volunteers. If you would like to help out or fund the project, please get     in touch at https://github.com/cookiecutter/cookiecutter.     """"""     # Commands that should work without arguments     if list_installed:         list_installed_templates(default_config, config_file)         sys.exit(0)      # Raising usage, after all commands that should work without args.     if not template or template.lower() == 'help':         click.echo(click.get_current_context().get_help())         sys.exit(0)      configure_logger(stream_level='DEBUG' if verbose else 'INFO', debug_file=debug_file)      # If needed, prompt the user to ask whether or not they want to execute     # the pre/post hooks.     if accept_hooks == ""ask"":         _accept_hooks = click.confirm(""Do you want to execute hooks?"")     else:         _accept_hooks = accept_hooks == ""yes""      if replay_file:         replay = replay_file      try:         cookiecutter(             template,             checkout,             no_input,             extra_context=extra_context,             replay=replay,             overwrite_if_exists=overwrite_if_exists,             output_dir=output_dir,             config_file=config_file,             default_config=default_config,             password=os.environ.get('COOKIECUTTER_REPO_PASSWORD'),             directory=directory,             skip_if_file_exists=skip_if_file_exists,             accept_hooks=_accept_hooks,             keep_project_on_failure=keep_project_on_failure,         )     except (         ContextDecodingException,         OutputDirExistsException,         EmptyDirNameException,         InvalidModeException,         FailedHookException,         UnknownExtension,         InvalidZipRepository,         RepositoryNotFound,         RepositoryCloneFailed,     ) as e:         click.echo(e)         sys.exit(1)     except UndefinedVariableInTemplate as undefined_err:         click.echo(f'{undefined_err.message}')         click.echo(f'Error message: {undefined_err.error.message}')          context_str = json.dumps(undefined_err.context, indent=4, sort_keys=True)         click.echo(f'Context: {context_str}')         sys.exit(1)   if __name__ == ""__main__"":     main()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\config.py,config.py_chunk0,"""""""Global configuration handling.""""""  from __future__ import annotations  import collections import copy import logging import os from typing import TYPE_CHECKING, Any  import yaml  from cookiecutter.exceptions import ConfigDoesNotExistException, InvalidConfiguration  if TYPE_CHECKING:     from pathlib import Path  logger = logging.getLogger(__name__)  USER_CONFIG_PATH = os.path.expanduser('~/.cookiecutterrc')  BUILTIN_ABBREVIATIONS = {     'gh': 'https://github.com/{0}.git',     'gl': 'https://gitlab.com/{0}.git',     'bb': 'https://bitbucket.org/{0}', }  DEFAULT_CONFIG = {     'cookiecutters_dir': os.path.expanduser('~/.cookiecutters/'),     'replay_dir': os.path.expanduser('~/.cookiecutter_replay/'),     'default_context': collections.OrderedDict([]),     'abbreviations': BUILTIN_ABBREVIATIONS, }   def _expand_path(path: str) -> str:     """"""Expand both environment variables and user home in the given path.""""""     path = os.path.expandvars(path)     path = os.path.expanduser(path)     return path   def merge_configs(default: dict[str, Any], overwrite: dict[str, Any]) -> dict[str, Any]:     """"""Recursively update a dict with the key/value pair of another.      Dict values that are dictionaries themselves will be updated, whilst     preserving existing keys.     """"""     new_config = copy.deepcopy(default)      for k, v in overwrite.items():         # Make sure to preserve existing items in         # nested dicts, for example `abbreviations`         if isinstance(v, dict):             new_config[k] = merge_configs(default.get(k, {}), v)         else:             new_config[k] = v      return new_config   def get_config(config_path: Path | str) -> dict[str, Any]:     """"""Retrieve the config from the specified path, returning a config dict.""""""     if not os.path.exists(config_path):         raise ConfigDoesNotExistException(f'Config file {config_path} does not exist.')      logger.debug('config_path is %s', config_path)     with open(config_path, encoding='utf-8') as file_handle:         try:             yaml_dict = yaml.safe_load(file_handle) or {}         except yaml.YAMLError as e:             raise InvalidConfiguration(                 f'Unable to parse YAML file {config_path}.'             ) from e         if not isinstance(yaml_dict, dict):             raise InvalidConfiguration(                 f'Top-level element of YAML file {config_path} should be an object.'             )      config_dict = merge_configs(DEFAULT_CONFIG, yaml_dict)      raw_replay_dir = config_dict['replay_dir']     config_dict['replay_dir'] = _expand_path(raw_replay_dir)      raw_cookies_dir = config_dict['cookiecutters_dir']     config_dict['cookiecutters_dir'] = _expand_path(raw_cookies_dir)      return config_dict   def get_user_config(     config_file: str | None = None,     default_config: bool | dict[str, Any] = False, ) -> dict[str, Any]:     """"""Return the user config as a dict.      If ``default_config`` is True, ignore ``config_file`` and return default     values for the config parameters.      If ``default_config`` is a dict, merge values with default values and return them     for the config parameters.      If a path to a ``config_file`` is given, that is different from the default     location, load the user config from that.      Otherwise look up the config file path in the ``COOKIECUTTER_CONFIG``     environment variable. If set, load the config from this path. This will     raise an error if the specified path is not valid.      If the environment variable is not set, try the default config file path     before falling back to the default config values.     """"""     # Do NOT load a config. Merge provided values with defaults and return them instead     if default_config and isinstance(default_config, dict):         return merge_configs(DEFAULT_CONFIG, default_config)      # Do NOT load a config. Return defaults instead.     if default_config:         logger.debug(""Force ignoring user config with default_config switch."")         return copy.copy(DEFAULT_CONFIG)      # Load the given config file     if config_file and config_file is not USER_CONFIG_PATH:         logger.debug(""Loading custom config from %s."", config_file)         return get_config(config_file)      try:         # Does the user set up a config environment variable?         env_config_file = os.environ['COOKIECUTTER_CONFIG']     except KeyError:         # Load an optional user config if it exists         # otherwise return the defaults         if os.path.exists(USER_CONFIG_PATH):             logger.debug(""Loading config from %s."", USER_CONFIG_PATH)             return get_config(USER_CONFIG_PATH)         else:             logger.debug(""User config not found. Loading default config."")             return copy.copy(DEFAULT_CONFIG)     else:         # There is a config environment variable. Try to load it.         # Do not check for existence, so invalid file paths raise an error.         logger.debug(""User config not found or not specified. Loading default config."")         return get_config(env_config_file)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\environment.py,environment.py_chunk0,"""""""Jinja2 environment and extensions loading.""""""  from __future__ import annotations  from typing import Any  from jinja2 import Environment, StrictUndefined  from cookiecutter.exceptions import UnknownExtension   class ExtensionLoaderMixin:     """"""Mixin providing sane loading of extensions specified in a given context.      The context is being extracted from the keyword arguments before calling     the next parent class in line of the child.     """"""      def __init__(self, *, context: dict[str, Any] | None = None, **kwargs: Any) -> None:         """"""Initialize the Jinja2 Environment object while loading extensions.          Does the following:          1. Establishes default_extensions (currently just a Time feature)         2. Reads extensions set in the cookiecutter.json _extensions key.         3. Attempts to load the extensions. Provides useful error if fails.         """"""         context = context or {}          default_extensions = [             'cookiecutter.extensions.JsonifyExtension',             'cookiecutter.extensions.RandomStringExtension',             'cookiecutter.extensions.SlugifyExtension',             'cookiecutter.extensions.TimeExtension',             'cookiecutter.extensions.UUIDExtension',         ]         extensions = default_extensions + self._read_extensions(context)          try:             super().__init__(extensions=extensions, **kwargs)  #  type: ignore[call-arg]         except ImportError as err:             raise UnknownExtension(f'Unable to load extension: {err}') from err      def _read_extensions(self, context: dict[str, Any]) -> list[str]:         """"""Return list of extensions as str to be passed on to the Jinja2 env.          If context does not contain the relevant info, return an empty         list instead.         """"""         try:             extensions = context['cookiecutter']['_extensions']         except KeyError:             return []         else:             return [str(ext) for ext in extensions]   class StrictEnvironment(ExtensionLoaderMixin, Environment):     """"""Create strict Jinja2 environment.      Jinja2 environment will raise error on undefined variable in template-     rendering context.     """"""      def __init__(self, **kwargs: Any) -> None:         """"""Set the standard Cookiecutter StrictEnvironment.          Also loading extensions defined in cookiecutter.json's _extensions key.         """"""         super().__init__(undefined=StrictUndefined, **kwargs)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\exceptions.py,exceptions.py_chunk0,"""""""All exceptions used in the Cookiecutter code base are defined here.""""""  from __future__ import annotations  from typing import TYPE_CHECKING, Any  if TYPE_CHECKING:     from jinja2 import TemplateError   class CookiecutterException(Exception):     """"""     Base exception class.      All Cookiecutter-specific exceptions should subclass this class.     """"""   class NonTemplatedInputDirException(CookiecutterException):     """"""     Exception for when a project's input dir is not templated.      The name of the input directory should always contain a string that is     rendered to something else, so that input_dir != output_dir.     """"""   class UnknownTemplateDirException(CookiecutterException):     """"""     Exception for ambiguous project template directory.      Raised when Cookiecutter cannot determine which directory is the project     template, e.g. more than one dir appears to be a template dir.     """"""      # unused locally   class MissingProjectDir(CookiecutterException):     """"""     Exception for missing generated project directory.      Raised during cleanup when remove_repo() can't find a generated project     directory inside of a repo.     """"""      # unused locally   class ConfigDoesNotExistException(CookiecutterException):     """"""     Exception for missing config file.      Raised when get_config() is passed a path to a config file, but no file     is found at that path.     """"""   class InvalidConfiguration(CookiecutterException):     """"""     Exception for invalid configuration file.      Raised if the global configuration file is not valid YAML or is     badly constructed.     """"""   class UnknownRepoType(CookiecutterException):     """"""     Exception for unknown repo types.      Raised if a repo's type cannot be determined.     """"""   class VCSNotInstalled(CookiecutterException):     """"""     Exception when version control is unavailable.      Raised if the version control system (git or hg) is not installed.     """"""   class ContextDecodingException(CookiecutterException):     """"""     Exception for failed JSON decoding.      Raised when a project's JSON context file can not be decoded.     """"""   class OutputDirExistsException(CookiecutterException):     """"""     Exception for existing output directory.      Raised when the output directory of the project exists already.     """"""   class EmptyDirNameException(CookiecutterException):     """"""     Exception for a empty directory name.      Raised when the directory name provided is empty.     """"""   class InvalidModeException(CookiecutterException):     """"""     Exception for incompatible modes.      Raised when cookiecutter is called with both `no_input==True` and     `replay==True` at the same time.     """"""   class FailedHookException(CookiecutterException):     """"""     Exception for hook failures.      Raised when a hook script fails.     """"""   class UndefinedVariableInTemplate(CookiecutterException):     """"""     Exception for out-of-scope variables.      Raised when a template uses a variable which is not defined in the     context.     """"""      def __init__(         self, message: str, error: TemplateError, context: dict[str, Any]     ) -> None:         """"""Exception for out-of-scope variables.""""""         self.message = message         self.error = error         self.context = context      def __str__(self) -> str:         """"""Text representation of UndefinedVariableInTemplate.""""""         return (             f""{self.message}. ""             f""Error message: {self.error.message}. ""             f""Context: {self.context}""         )   class UnknownExtension(CookiecutterException):     """"""     Exception for un-importable extension.      Raised when an environment is unable to import a required extension.     """"""   class RepositoryNotFound(CookiecutterException):     """"""     Exception for missing repo.      Raised when the specified cookiecutter repository doesn't exist.     """"""   class RepositoryCloneFailed(CookiecutterException):     """"""     Exception for un-cloneable repo.      Raised when a cookiecutter template can't be cloned.     """"""   class InvalidZipRepository(CookiecutterException):     """"""     Exception for bad zip repo.      Raised when the specified cookiecutter repository isn't a valid     Zip archive.     """""""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\extensions.py,extensions.py_chunk0,"""""""Jinja2 extensions.""""""  from __future__ import annotations  import json import string import uuid from secrets import choice from typing import TYPE_CHECKING, Any, Iterable  import arrow from jinja2 import Environment, nodes from jinja2.ext import Extension from slugify import slugify as pyslugify from slugify.slugify import DEFAULT_SEPARATOR  if TYPE_CHECKING:     import re      from jinja2.parser import Parser   class JsonifyExtension(Extension):     """"""Jinja2 extension to convert a Python object to JSON.""""""      def __init__(self, environment: Environment) -> None:         """"""Initialize the extension with the given environment.""""""         super().__init__(environment)          def jsonify(obj: Any, indent: int = 4) -> str:             return json.dumps(obj, sort_keys=True, indent=indent)          environment.filters['jsonify'] = jsonify   class RandomStringExtension(Extension):     """"""Jinja2 extension to create a random string.""""""      def __init__(self, environment: Environment) -> None:         """"""Jinja2 Extension Constructor.""""""         super().__init__(environment)          def random_ascii_string(length: int, punctuation: bool = False) -> str:             if punctuation:                 corpus = f'{string.ascii_letters}{string.punctuation}'             else:                 corpus = string.ascii_letters             return """".join(choice(corpus) for _ in range(length))          environment.globals.update(random_ascii_string=random_ascii_string)   class SlugifyExtension(Extension):     """"""Jinja2 Extension to slugify string.""""""      def __init__(self, environment: Environment) -> None:         """"""Jinja2 Extension constructor.""""""         super().__init__(environment)          def slugify(             value: str,             entities: bool = True,             decimal: bool = True,             hexadecimal: bool = True,             max_length: int = 0,             word_boundary: bool = False,             separator: str = DEFAULT_SEPARATOR,             save_order: bool = False,             stopwords: Iterable[str] = (),             regex_pattern: re.Pattern[str] | str | None = None,             lowercase: bool = True,             replacements: Iterable[Iterable[str]] = (),             allow_unicode: bool = False,         ) -> str:             """"""Slugifies the value.""""""             return pyslugify(                 value,                 entities,                 decimal,                 hexadecimal,                 max_length,                 word_boundary,                 separator,                 save_order,                 stopwords,                 regex_pattern,                 lowercase,                 replacements,                 allow_unicode,             )          environment.filters['slugify'] = slugify   class UUIDExtension(Extension):     """"""Jinja2 Extension to generate uuid4 string.""""""      def __init__(self, environment: Environment) -> None:         """"""Jinja2 Extension constructor.""""""         super().__init__(environment)          def uuid4() -> str:             """"""Generate UUID4.""""""             return str(uuid.uuid4())          environment.globals.update(uuid4=uuid4)   class TimeExtension(Extension):     """"""Jinja2 Extension for dates and times.""""""      tags = {'now'}      def __init__(self, environment: Environment) -> None:         """"""Jinja2 Extension constructor.""""""         super().__init__(environment)          environment.extend(datetime_format='%Y-%m-%d')      def _datetime(         self,         timezone: str,         operator: str,         offset: str,         datetime_format: str | None,     ) -> str:         d = arrow.now(timezone)          # parse shift params from offset and include operator         shift_params = {}         for param in offset.split(','):             interval, value = param.split('=')             shift_params[interval.strip()] = float(operator + value.strip())         d = d.shift(**shift_params)          if datetime_format is None:             datetime_format = self.environment.datetime_format  # type: ignore[attr-defined]         return d.strftime(datetime_format)      def _now(self, timezone: str, datetime_format: str | None) -> str:         if datetime_format is None:             datetime_format = self.environment.datetime_format  # type: ignore[attr-defined]         return arrow.now(timezone).strftime(datetime_format)      def parse(self, parser: Parser) -> nodes.Output:         """"""Parse datetime template and add datetime value.""""""         lineno = next(parser.stream).lineno          node = parser.parse_expression()          if parser.stream.skip_if('comma'):             datetime_format = parser.parse_expression()         else:             datetime_format = nodes.Const(None)          if isinstance(node, nodes.Add):             call_method = self.call_method(                 '_datetime',                 [node.left, nodes.Const('+'), node.right, datetime_format],                 lineno=lineno,             )         elif isinstance(node, nodes.Sub):             call_method = self.call_method(                 '_datetime',                 [node.left, nodes.Const('-'), node.right, datetime_format],                 lineno=lineno,             )         else:             call_method = self.call_method(                 '_now',                 [node, datetime_format],                 lineno=lineno,             )         return nodes.Output([call_method], lineno=lineno)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\find.py,find.py_chunk0,"""""""Functions for finding Cookiecutter templates and other components.""""""  from __future__ import annotations  import logging import os from pathlib import Path from typing import TYPE_CHECKING  from cookiecutter.exceptions import NonTemplatedInputDirException  if TYPE_CHECKING:     from jinja2 import Environment  logger = logging.getLogger(__name__)   def find_template(repo_dir: Path | str, env: Environment) -> Path:     """"""Determine which child directory of ``repo_dir`` is the project template.      :param repo_dir: Local directory of newly cloned repo.     :return: Relative path to project template.     """"""     logger.debug('Searching %s for the project template.', repo_dir)      for str_path in os.listdir(repo_dir):         if (             'cookiecutter' in str_path             and env.variable_start_string in str_path             and env.variable_end_string in str_path         ):             project_template = Path(repo_dir, str_path)             break     else:         raise NonTemplatedInputDirException      logger.debug('The project template appears to be %s', project_template)     return project_template"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\generate.py,generate.py_chunk0,"""""""Functions for generating a project from a project template.""""""  from __future__ import annotations  import fnmatch import json import logging import os import shutil import warnings from collections import OrderedDict from pathlib import Path from typing import Any  from binaryornot.check import is_binary from jinja2 import Environment, FileSystemLoader from jinja2.exceptions import TemplateSyntaxError, UndefinedError from rich.prompt import InvalidResponse  from cookiecutter.exceptions import (     ContextDecodingException,     EmptyDirNameException,     OutputDirExistsException,     UndefinedVariableInTemplate, ) from cookiecutter.find import find_template from cookiecutter.hooks import run_hook_from_repo_dir from cookiecutter.prompt import YesNoPrompt from cookiecutter.utils import (     create_env_with_context,     make_sure_path_exists,     rmtree,     work_in, )  logger = logging.getLogger(__name__)   def is_copy_only_path(path: str, context: dict[str, Any]) -> bool:     """"""Check whether the given `path` should only be copied and not rendered.      Returns True if `path` matches a pattern in the given `context` dict,     otherwise False.      :param path: A file-system path referring to a file or dir that         should be rendered or just copied.     :param context: cookiecutter context.     """"""     try:         for dont_render in context['cookiecutter']['_copy_without_render']:             if fnmatch.fnmatch(path, dont_render):                 return True     except KeyError:         return False      return False   def apply_overwrites_to_context(     context: dict[str, Any],     overwrite_context: dict[str, Any],     *,     in_dictionary_variable: bool = False, ) -> None:     """"""Modify the given context in place based on the overwrite_context.""""""     for variable, overwrite in overwrite_context.items():         if variable not in context:             if not in_dictionary_variable:                 # We are dealing with a new variable on first level, ignore                 continue             # We are dealing with a new dictionary variable in a deeper level             context[variable] = overwrite          context_value = context[variable]         if isinstance(context_value, list):             if in_dictionary_variable:                 context[variable] = overwrite                 continue             if isinstance(overwrite, list):                 # We are dealing with a multichoice variable                 # Let's confirm all choices are valid for the given context                 if set(overwrite).issubset(set(context_value)):                     context[variable] = overwrite                 else:                     raise ValueError(                         f""{overwrite} provided for multi-choice variable ""                         f""{variable}, but valid choices are {context_value}""                     )             else:                 # We are dealing with a choice variable                 if overwrite in context_value:                     # This overwrite is actually valid for the given context                     # Let's set it as default (by definition first item in list)                     # see ``cookiecutter.prompt.prompt_choice_for_config``                     context_value.remove(overwrite)                     context_value.insert(0, overwrite)                 else:                     raise ValueError(                         f""{overwrite} provided for choice variable ""                         f""{variable}, but the choices are {context_value}.""                     )         elif isinstance(context_value, dict) and isinstance(overwrite, dict):             # Partially overwrite some keys in original dict             apply_overwrites_to_context(                 context_value, overwrite, in_dictionary_variable=True             )             context[variable] = context_value         elif isinstance(context_value, bool) and isinstance(overwrite, str):             # We are dealing with a boolean variable             # Convert overwrite to its boolean counterpart             try:                 context[variable] = YesNoPrompt().process_response(overwrite)             except InvalidResponse as err:                 raise ValueError(                     f""{overwrite} provided for variable ""                     f""{variable} could not be converted to a boolean.""                 ) from err         else:             # Simply overwrite the value for this variable             context[variable] = overwrite   def generate_context(     context_file: str = 'cookiecutter.json',     default_context: dict[str, Any] | None = None,     extra_context: dict[str, Any] | None = None, ) -> dict[str, Any]:     """"""Generate the context for a Cookiecutter project template.      Loads the JSON file as a Python object, with key being the JSON filename.      :param context_file: JSON file containing key/value pairs for populating         the cookiecutter's variables.     :param default_context: Dictionary containing config to take into account.     :param extra_context: Dictionary containing configuration overrides     """"""     context = OrderedDict([])      try:         with open(context_file, encoding='utf-8') as file_handle:             obj = json.load(file_handle, object_pairs_hook=OrderedDict)     except ValueError as e:         # JSON decoding error.  Let's throw a new exception that is more         # friendly for the developer or user.         full_fpath = os.path.abspath(context_file)         json_exc_message = str(e)         our_exc_message = (             f""JSON decoding error while loading '{full_fpath}'. ""             f""Decoding error details: '{json_exc_message}'""         )         raise ContextDecodingException(our_exc_message) from e      # Add the Python object to the context dictionary     file_name = os.path.split(context_file)[1]     file_stem = file_name.split('.')[0]     context[file_stem] = obj      # Overwrite context variable defaults with the default context from the     # user's global config, if available     if default_context:         try:             apply_overwrites_to_context(obj, default_context)         except ValueError as error:             warnings.warn(f""Invalid default received: {error}"")     if extra_context:         apply_overwrites_to_context(obj, extra_context)      logger.debug('Context generated is %s', context)     return context   def generate_file(     project_dir: str,     infile: str,     context: dict[str, Any],     env: Environment,     skip_if_file_exists: bool = False, ) -> None:     """"""Render filename of infile as name of outfile, handle infile correctly.      Dealing with infile appropriately:          a. If infile is a binary file, copy it over without rendering.         b. If infile is a text file, render its contents and write the            rendered infile to outfile.      Precondition:          When calling `generate_file()`, the root template dir must be the         current working directory. Using `utils.work_in()` is the recommended         way to perform this directory change.      :param project_dir: Absolute path to the resulting generated project.     :param infile: Input file to generate the file from. Relative to the root         template dir.     :param context: Dict for populating the cookiecutter's variables.     :param env: Jinja2 template execution environment.     """"""     logger.debug('Processing file %s', infile)      # Render the path to the output file (not including the root project dir)     outfile_tmpl = env.from_string(infile)      outfile = os.path.join(project_dir, outfile_tmpl.render(**context))     file_name_is_empty = os.path.isdir(outfile)     if file_name_is_empty:         logger.debug('The resulting file name is empty: %s', outfile)         return      if skip_if_file_exists and os.path.exists(outfile):         logger.debug('The resulting file already exists: %s', outfile)         return      logger.debug('Created file at %s', outfile)      # Just copy over binary files. Don't render.     logger.debug(""Check %s to see if it's a binary"", infile)     if is_binary(infile):         logger.debug('Copying binary %s to %s without rendering', infile, outfile)         shutil.copyfile(infile, outfile)         shutil.copymode(infile, outfile)         return      # Force fwd slashes on Windows for get_template     # This is a by-design Jinja issue     infile_fwd_slashes = infile.replace(os.path.sep, '/')      # Render the file     try:         tmpl = env.get_template(infile_fwd_slashes)     except TemplateSyntaxError as exception:         # Disable translated so that printed exception contains verbose         # information about syntax error location         exception.translated = False         raise     rendered_file = tmpl.render(**context)      if context['cookiecutter'].get('_new_lines', False):         # Use `_new_lines` from context, if configured.         newline = context['cookiecutter']['_new_lines']         logger.debug('Using configured newline character %s', repr(newline))     else:         # Detect original file newline to output the rendered file.         # Note that newlines can be a tuple if file contains mixed line endings.         # In this case, we pick the first line ending we detected.         with open(infile, encoding='utf-8') as rd:             rd.readline()  # Read only the first line to load a 'newlines' value.         newline = rd.newlines[0] if isinstance(rd.newlines, tuple) else rd.newlines         logger.debug('Using detected newline character %s', repr(newline))      logger.debug('Writing contents to file %s', outfile)      with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:         fh.write(rendered_file)      # Apply file permissions to output file     shutil.copymode(infile, outfile)   def render_and_create_dir(     dirname: str,     context: dict[str, Any],     output_dir: Path | str,     environment: Environment,     overwrite_if_exists: bool = False, ) -> tuple[Path, bool]:     """"""Render name of a directory, create the directory, return its path.""""""     if not dirname or dirname == """":         msg = 'Error: directory name is empty'         raise EmptyDirNameException(msg)      name_tmpl = environment.from_string(dirname)     rendered_dirname = name_tmpl.render(**context)      dir_to_create = Path(output_dir, rendered_dirname)      logger.debug(         'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir     )      output_dir_exists = dir_to_create.exists()      if output_dir_exists:         if overwrite_if_exists:             logger.debug(                 'Output directory %s already exists, overwriting it', dir_to_create             )         else:             msg = f'Error: ""{dir_to_create}"" directory already exists'             raise OutputDirExistsException(msg)     else:         make_sure_path_exists(dir_to_create)      return dir_to_create, not output_dir_exists   def _run_hook_from_repo_dir(     repo_dir: str,     hook_name: str,     project_dir: Path | str,     context: dict[str, Any],     delete_project_on_failure: bool, ) -> None:     """"""Run hook from repo directory, clean project directory if hook fails.      :param repo_dir: Project template input directory.     :param hook_name: The hook to execute.     :param project_dir: The directory to execute the script from.     :param context: Cookiecutter project context.     :param delete_project_on_failure: Delete the project directory on hook         failure?     """"""     warnings.warn(         ""The '_run_hook_from_repo_dir' function is deprecated, ""         ""use 'cookiecutter.hooks.run_hook_from_repo_dir' instead"",         DeprecationWarning,         2,     )     run_hook_from_repo_dir(         repo_dir, hook_name, project_dir, context, delete_project_on_failure     )   def generate_files(     repo_dir: Path | str,     context: dict[str, Any] | None = None,     output_dir: Path | str = '.',     overwrite_if_exists: bool = False,     skip_if_file_exists: bool = False,     accept_hooks: bool = True,     keep_project_on_failure: bool = False, ) -> str:     """"""Render the templates and saves them to files.      :param repo_dir: Project template input directory.     :param context: Dict for populating the template's variables.     :param output_dir: Where to output the generated project dir into.     :param overwrite_if_exists: Overwrite the contents of the output directory         if it exists.     :param skip_if_file_exists: Skip the files in the corresponding directories         if they already exist     :param accept_hooks: Accept pre and post hooks if set to `True`.     :param keep_project_on_failure: If `True` keep generated project directory even when         generation fails     """"""     context = context or OrderedDict([])      env = create_env_with_context(context)      template_dir = find_template(repo_dir, env)     logger.debug('Generating project from %s...', template_dir)      unrendered_dir = os.path.split(template_dir)[1]     try:         project_dir: Path | str         project_dir, output_directory_created = render_and_create_dir(             unrendered_dir, context, output_dir, env, overwrite_if_exists         )     except UndefinedError as err:         msg = f""Unable to create project directory '{unrendered_dir}'""         raise UndefinedVariableInTemplate(msg, err, context) from err      # We want the Jinja path and the OS paths to match. Consequently, we'll:     #   + CD to the template folder     #   + Set Jinja's path to '.'     #     #  In order to build our files to the correct folder(s), we'll use an     # absolute path for the target folder (project_dir)      project_dir = os.path.abspath(project_dir)     logger.debug('Project directory is %s', project_dir)      # if we created the output directory, then it's ok to remove it     # if rendering fails     delete_project_on_failure = output_directory_created and not keep_project_on_failure      if accept_hooks:         run_hook_from_repo_dir(             repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure         )      with work_in(template_dir):         env.loader = FileSystemLoader(['.', '../templates'])          for root, dirs, files in os.walk('.'):             # We must separate the two types of dirs into different lists.             # The reason is that we don't want ``os.walk`` to go through the             # unrendered directories, since they will just be copied.             copy_dirs = []             render_dirs = []              for d in dirs:                 d_ = os.path.normpath(os.path.join(root, d))                 # We check the full path, because that's how it can be                 # specified in the ``_copy_without_render`` setting, but                 # we store just the dir name                 if is_copy_only_path(d_, context):                     logger.debug('Found copy only path %s', d)                     copy_dirs.append(d)                 else:                     render_dirs.append(d)              for copy_dir in copy_dirs:                 indir = os.path.normpath(os.path.join(root, copy_dir))                 outdir = os.path.normpath(os.path.join(project_dir, indir))                 outdir = env.from_string(outdir).render(**context)                 logger.debug('Copying dir %s to %s without rendering', indir, outdir)                  # The outdir is not the root dir, it is the dir which marked as copy                 # only in the config file. If the program hits this line, which means                 # the overwrite_if_exists = True, and root dir exists                 if os.path.isdir(outdir):                     shutil.rmtree(outdir)                 shutil.copytree(indir, outdir)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\generate.py,generate.py_chunk1,"# if we created the output directory, then it's ok to remove it     # if rendering fails     delete_project_on_failure = output_directory_created and not keep_project_on_failure      if accept_hooks:         run_hook_from_repo_dir(             repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure         )      with work_in(template_dir):         env.loader = FileSystemLoader(['.', '../templates'])          for root, dirs, files in os.walk('.'):             # We must separate the two types of dirs into different lists.             # The reason is that we don't want ``os.walk`` to go through the             # unrendered directories, since they will just be copied.             copy_dirs = []             render_dirs = []              for d in dirs:                 d_ = os.path.normpath(os.path.join(root, d))                 # We check the full path, because that's how it can be                 # specified in the ``_copy_without_render`` setting, but                 # we store just the dir name                 if is_copy_only_path(d_, context):                     logger.debug('Found copy only path %s', d)                     copy_dirs.append(d)                 else:                     render_dirs.append(d)              for copy_dir in copy_dirs:                 indir = os.path.normpath(os.path.join(root, copy_dir))                 outdir = os.path.normpath(os.path.join(project_dir, indir))                 outdir = env.from_string(outdir).render(**context)                 logger.debug('Copying dir %s to %s without rendering', indir, outdir)                  # The outdir is not the root dir, it is the dir which marked as copy                 # only in the config file. If the program hits this line, which means                 # the overwrite_if_exists = True, and root dir exists                 if os.path.isdir(outdir):                     shutil.rmtree(outdir)                 shutil.copytree(indir, outdir)              # We mutate ``dirs``, because we only want to go through these dirs             # recursively             dirs[:] = render_dirs             for d in dirs:                 unrendered_dir = os.path.join(project_dir, root, d)                 try:                     render_and_create_dir(                         unrendered_dir, context, output_dir, env, overwrite_if_exists                     )                 except UndefinedError as err:                     if delete_project_on_failure:                         rmtree(project_dir)                     _dir = os.path.relpath(unrendered_dir, output_dir)                     msg = f""Unable to create directory '{_dir}'""                     raise UndefinedVariableInTemplate(msg, err, context) from err              for f in files:                 infile = os.path.normpath(os.path.join(root, f))                 if is_copy_only_path(infile, context):                     outfile_tmpl = env.from_string(infile)                     outfile_rendered = outfile_tmpl.render(**context)                     outfile = os.path.join(project_dir, outfile_rendered)                     logger.debug(                         'Copying file %s to %s without rendering', infile, outfile                     )                     shutil.copyfile(infile, outfile)                     shutil.copymode(infile, outfile)                     continue                 try:                     generate_file(                         project_dir, infile, context, env, skip_if_file_exists                     )                 except UndefinedError as err:                     if delete_project_on_failure:                         rmtree(project_dir)                     msg = f""Unable to create file '{infile}'""                     raise UndefinedVariableInTemplate(msg, err, context) from err      if accept_hooks:         run_hook_from_repo_dir(             repo_dir,             'post_gen_project',             project_dir,             context,             delete_project_on_failure,         )      return project_dir"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\hooks.py,hooks.py_chunk0,"""""""Functions for discovering and executing various cookiecutter hooks.""""""  from __future__ import annotations  import errno import logging import os import subprocess import sys import tempfile from typing import TYPE_CHECKING, Any  from jinja2.exceptions import UndefinedError  from cookiecutter import utils from cookiecutter.exceptions import FailedHookException from cookiecutter.utils import (     create_env_with_context,     create_tmp_repo_dir,     rmtree,     work_in, )  if TYPE_CHECKING:     from pathlib import Path  logger = logging.getLogger(__name__)  _HOOKS = [     'pre_prompt',     'pre_gen_project',     'post_gen_project', ] EXIT_SUCCESS = 0   def valid_hook(hook_file: str, hook_name: str) -> bool:     """"""Determine if a hook file is valid.      :param hook_file: The hook file to consider for validity     :param hook_name: The hook to find     :return: The hook file validity     """"""     filename = os.path.basename(hook_file)     basename = os.path.splitext(filename)[0]     matching_hook = basename == hook_name     supported_hook = basename in _HOOKS     backup_file = filename.endswith('~')      return matching_hook and supported_hook and not backup_file   def find_hook(hook_name: str, hooks_dir: str = 'hooks') -> list[str] | None:     """"""Return a dict of all hook scripts provided.      Must be called with the project template as the current working directory.     Dict's key will be the hook/script's name, without extension, while values     will be the absolute path to the script. Missing scripts will not be     included in the returned dict.      :param hook_name: The hook to find     :param hooks_dir: The hook directory in the template     :return: The absolute path to the hook script or None     """"""     logger.debug('hooks_dir is %s', os.path.abspath(hooks_dir))      if not os.path.isdir(hooks_dir):         logger.debug('No hooks/dir in template_dir')         return None      scripts = [         os.path.abspath(os.path.join(hooks_dir, hook_file))         for hook_file in os.listdir(hooks_dir)         if valid_hook(hook_file, hook_name)     ]      if len(scripts) == 0:         return None     return scripts   def run_script(script_path: str, cwd: Path | str = '.') -> None:     """"""Execute a script from a working directory.      :param script_path: Absolute path to the script to run.     :param cwd: The directory to run the script from.     """"""     run_thru_shell = sys.platform.startswith('win')     if script_path.endswith('.py'):         script_command = [sys.executable, script_path]     else:         script_command = [script_path]      utils.make_executable(script_path)      try:         proc = subprocess.Popen(script_command, shell=run_thru_shell, cwd=cwd)  # nosec         exit_status = proc.wait()         if exit_status != EXIT_SUCCESS:             raise FailedHookException(                 f'Hook script failed (exit status: {exit_status})'             )     except OSError as err:         if err.errno == errno.ENOEXEC:             raise FailedHookException(                 'Hook script failed, might be an empty file or missing a shebang'             ) from err         raise FailedHookException(f'Hook script failed (error: {err})') from err   def run_script_with_context(     script_path: Path | str, cwd: Path | str, context: dict[str, Any] ) -> None:     """"""Execute a script after rendering it with Jinja.      :param script_path: Absolute path to the script to run.     :param cwd: The directory to run the script from.     :param context: Cookiecutter project template context.     """"""     _, extension = os.path.splitext(script_path)      with open(script_path, encoding='utf-8') as file:         contents = file.read()      with tempfile.NamedTemporaryFile(delete=False, mode='wb', suffix=extension) as temp:         env = create_env_with_context(context)         template = env.from_string(contents)         output = template.render(**context)         temp.write(output.encode('utf-8'))      run_script(temp.name, cwd)   def run_hook(hook_name: str, project_dir: Path | str, context: dict[str, Any]) -> None:     """"""     Try to find and execute a hook from the specified project directory.      :param hook_name: The hook to execute.     :param project_dir: The directory to execute the script from.     :param context: Cookiecutter project context.     """"""     scripts = find_hook(hook_name)     if not scripts:         logger.debug('No %s hook found', hook_name)         return     logger.debug('Running hook %s', hook_name)     for script in scripts:         run_script_with_context(script, project_dir, context)   def run_hook_from_repo_dir(     repo_dir: Path | str,     hook_name: str,     project_dir: Path | str,     context: dict[str, Any],     delete_project_on_failure: bool, ) -> None:     """"""Run hook from repo directory, clean project directory if hook fails.      :param repo_dir: Project template input directory.     :param hook_name: The hook to execute.     :param project_dir: The directory to execute the script from.     :param context: Cookiecutter project context.     :param delete_project_on_failure: Delete the project directory on hook         failure?     """"""     with work_in(repo_dir):         try:             run_hook(hook_name, project_dir, context)         except (             FailedHookException,             UndefinedError,         ):             if delete_project_on_failure:                 rmtree(project_dir)             logger.error(                 ""Stopping generation because %s hook ""                 ""script didn't exit successfully"",                 hook_name,             )             raise   def run_pre_prompt_hook(repo_dir: Path | str) -> Path | str:     """"""Run pre_prompt hook from repo directory.      :param repo_dir: Project template input directory.     """"""     # Check if we have a valid pre_prompt script     with work_in(repo_dir):         scripts = find_hook('pre_prompt')         if not scripts:             return repo_dir      # Create a temporary directory     repo_dir = create_tmp_repo_dir(repo_dir)     with work_in(repo_dir):         scripts = find_hook('pre_prompt') or []         for script in scripts:             try:                 run_script(script, str(repo_dir))             except FailedHookException as e:  # noqa: PERF203                 raise FailedHookException('Pre-Prompt Hook script failed') from e     return repo_dir"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\log.py,log.py_chunk0,"""""""Module for setting up logging.""""""  from __future__ import annotations  import logging import sys  LOG_LEVELS = {     'DEBUG': logging.DEBUG,     'INFO': logging.INFO,     'WARNING': logging.WARNING,     'ERROR': logging.ERROR,     'CRITICAL': logging.CRITICAL, }  LOG_FORMATS = {     'DEBUG': '%(levelname)s %(name)s: %(message)s',     'INFO': '%(levelname)s: %(message)s', }   def configure_logger(     stream_level: str = 'DEBUG', debug_file: str | None = None ) -> logging.Logger:     """"""Configure logging for cookiecutter.      Set up logging to stdout with given level. If ``debug_file`` is given set     up logging to file with DEBUG level.     """"""     # Set up 'cookiecutter' logger     logger = logging.getLogger('cookiecutter')     logger.setLevel(logging.DEBUG)      # Remove all attached handlers, in case there was     # a logger with using the name 'cookiecutter'     del logger.handlers[:]      # Create a file handler if a log file is provided     if debug_file is not None:         debug_formatter = logging.Formatter(LOG_FORMATS['DEBUG'])         file_handler = logging.FileHandler(debug_file)         file_handler.setLevel(LOG_LEVELS['DEBUG'])         file_handler.setFormatter(debug_formatter)         logger.addHandler(file_handler)      # Get settings based on the given stream_level     log_formatter = logging.Formatter(LOG_FORMATS[stream_level])     log_level = LOG_LEVELS[stream_level]      # Create a stream handler     stream_handler = logging.StreamHandler(stream=sys.stdout)     stream_handler.setLevel(log_level)     stream_handler.setFormatter(log_formatter)     logger.addHandler(stream_handler)      return logger"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\main.py,main.py_chunk0,""""""" Main entry point for the `cookiecutter` command.  The code in this module is also a good example of how to use Cookiecutter as a library rather than a script. """"""  from __future__ import annotations  import logging import os import sys from copy import copy from pathlib import Path from typing import Any  from cookiecutter.config import get_user_config from cookiecutter.exceptions import InvalidModeException from cookiecutter.generate import generate_context, generate_files from cookiecutter.hooks import run_pre_prompt_hook from cookiecutter.prompt import choose_nested_template, prompt_for_config from cookiecutter.replay import dump, load from cookiecutter.repository import determine_repo_dir from cookiecutter.utils import rmtree  logger = logging.getLogger(__name__)   def cookiecutter(     template: str,     checkout: str | None = None,     no_input: bool = False,     extra_context: dict[str, Any] | None = None,     replay: bool | str | None = None,     overwrite_if_exists: bool = False,     output_dir: str = '.',     config_file: str | None = None,     default_config: bool = False,     password: str | None = None,     directory: str | None = None,     skip_if_file_exists: bool = False,     accept_hooks: bool = True,     keep_project_on_failure: bool = False, ) -> str:     """"""     Run Cookiecutter just as if using it from the command line.      :param template: A directory containing a project template directory,         or a URL to a git repository.     :param checkout: The branch, tag or commit ID to checkout after clone.     :param no_input: Do not prompt for user input.         Use default values for template parameters taken from `cookiecutter.json`, user         config and `extra_dict`. Force a refresh of cached resources.     :param extra_context: A dictionary of context that overrides default         and user configuration.     :param replay: Do not prompt for input, instead read from saved json. If         ``True`` read from the ``replay_dir``.         if it exists     :param overwrite_if_exists: Overwrite the contents of the output directory         if it exists.     :param output_dir: Where to output the generated project dir into.     :param config_file: User configuration file path.     :param default_config: Use default values rather than a config file.     :param password: The password to use when extracting the repository.     :param directory: Relative path to a cookiecutter template in a repository.     :param skip_if_file_exists: Skip the files in the corresponding directories         if they already exist.     :param accept_hooks: Accept pre and post hooks if set to `True`.     :param keep_project_on_failure: If `True` keep generated project directory even when         generation fails     """"""     if replay and ((no_input is not False) or (extra_context is not None)):         err_msg = (             ""You can not use both replay and no_input or extra_context ""             ""at the same time.""         )         raise InvalidModeException(err_msg)      config_dict = get_user_config(         config_file=config_file,         default_config=default_config,     )     base_repo_dir, cleanup_base_repo_dir = determine_repo_dir(         template=template,         abbreviations=config_dict['abbreviations'],         clone_to_dir=config_dict['cookiecutters_dir'],         checkout=checkout,         no_input=no_input,         password=password,         directory=directory,     )     repo_dir, cleanup = base_repo_dir, cleanup_base_repo_dir     # Run pre_prompt hook     repo_dir = str(run_pre_prompt_hook(base_repo_dir)) if accept_hooks else repo_dir     # Always remove temporary dir if it was created     cleanup = repo_dir != base_repo_dir      import_patch = _patch_import_path_for_repo(repo_dir)     template_name = os.path.basename(os.path.abspath(repo_dir))     if replay:         with import_patch:             if isinstance(replay, bool):                 context_from_replayfile = load(config_dict['replay_dir'], template_name)             else:                 path, template_name = os.path.split(os.path.splitext(replay)[0])                 context_from_replayfile = load(path, template_name)      context_file = os.path.join(repo_dir, 'cookiecutter.json')     logger.debug('context_file is %s', context_file)      if replay:         context = generate_context(             context_file=context_file,             default_context=config_dict['default_context'],             extra_context=None,         )         logger.debug('replayfile context: %s', context_from_replayfile)         items_for_prompting = {             k: v             for k, v in context['cookiecutter'].items()             if k not in context_from_replayfile['cookiecutter']         }         context_for_prompting = {}         context_for_prompting['cookiecutter'] = items_for_prompting         context = context_from_replayfile         logger.debug('prompting context: %s', context_for_prompting)     else:         context = generate_context(             context_file=context_file,             default_context=config_dict['default_context'],             extra_context=extra_context,         )         context_for_prompting = context     # preserve the original cookiecutter options     # print(context['cookiecutter'])     context['_cookiecutter'] = {         k: v for k, v in context['cookiecutter'].items() if not k.startswith(""_"")     }      # prompt the user to manually configure at the command line.     # except when 'no-input' flag is set      with import_patch:         if {""template"", ""templates""} & set(context[""cookiecutter""].keys()):             nested_template = choose_nested_template(context, repo_dir, no_input)             return cookiecutter(                 template=nested_template,                 checkout=checkout,                 no_input=no_input,                 extra_context=extra_context,                 replay=replay,                 overwrite_if_exists=overwrite_if_exists,                 output_dir=output_dir,                 config_file=config_file,                 default_config=default_config,                 password=password,                 directory=directory,                 skip_if_file_exists=skip_if_file_exists,                 accept_hooks=accept_hooks,                 keep_project_on_failure=keep_project_on_failure,             )         if context_for_prompting['cookiecutter']:             context['cookiecutter'].update(                 prompt_for_config(context_for_prompting, no_input)             )      logger.debug('context is %s', context)      # include template dir or url in the context dict     context['cookiecutter']['_template'] = template      # include output+dir in the context dict     context['cookiecutter']['_output_dir'] = os.path.abspath(output_dir)      # include repo dir or url in the context dict     context['cookiecutter']['_repo_dir'] = f""{repo_dir}""      # include checkout details in the context dict     context['cookiecutter']['_checkout'] = checkout      dump(config_dict['replay_dir'], template_name, context)      # Create project from local context and project template.     with import_patch:         result = generate_files(             repo_dir=repo_dir,             context=context,             overwrite_if_exists=overwrite_if_exists,             skip_if_file_exists=skip_if_file_exists,             output_dir=output_dir,             accept_hooks=accept_hooks,             keep_project_on_failure=keep_project_on_failure,         )      # Cleanup (if required)     if cleanup:         rmtree(repo_dir)     if cleanup_base_repo_dir:         rmtree(base_repo_dir)     return result   class _patch_import_path_for_repo:  # noqa: N801     def __init__(self, repo_dir: Path | str) -> None:         self._repo_dir = f""{repo_dir}"" if isinstance(repo_dir, Path) else repo_dir      def __enter__(self) -> None:         self._path = copy(sys.path)         sys.path.append(self._repo_dir)      def __exit__(self, type, value, traceback):  # type: ignore[no-untyped-def]         sys.path = self._path"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\prompt.py,prompt.py_chunk0,"""""""Functions for prompting the user for project info.""""""  from __future__ import annotations  import json import os import re import sys from collections import OrderedDict from itertools import starmap from pathlib import Path from typing import TYPE_CHECKING, Any, Dict, Iterator, List, Union  from jinja2.exceptions import UndefinedError from rich.prompt import Confirm, InvalidResponse, Prompt, PromptBase from typing_extensions import TypeAlias  from cookiecutter.exceptions import UndefinedVariableInTemplate from cookiecutter.utils import create_env_with_context, rmtree  if TYPE_CHECKING:     from jinja2 import Environment   def read_user_variable(var_name: str, default_value, prompts=None, prefix: str = """"):     """"""Prompt user for variable and return the entered value or given default.      :param str var_name: Variable of the context to query the user     :param default_value: Value that will be returned if no input happens     """"""     question = (         prompts[var_name]         if prompts and var_name in prompts and prompts[var_name]         else var_name     )      while True:         variable = Prompt.ask(f""{prefix}{question}"", default=default_value)         if variable is not None:             break      return variable   class YesNoPrompt(Confirm):     """"""A prompt that returns a boolean for yes/no questions.""""""      yes_choices = [""1"", ""true"", ""t"", ""yes"", ""y"", ""on""]     no_choices = [""0"", ""false"", ""f"", ""no"", ""n"", ""off""]      def process_response(self, value: str) -> bool:         """"""Convert choices to a bool.""""""         value = value.strip().lower()         if value in self.yes_choices:             return True         elif value in self.no_choices:             return False         else:             raise InvalidResponse(self.validate_error_message)   def read_user_yes_no(var_name, default_value, prompts=None, prefix: str = """"):     """"""Prompt the user to reply with 'yes' or 'no' (or equivalent values).      - These input values will be converted to ``True``:       ""1"", ""true"", ""t"", ""yes"", ""y"", ""on""     - These input values will be converted to ``False``:       ""0"", ""false"", ""f"", ""no"", ""n"", ""off""      Actual parsing done by :func:`prompt`; Check this function codebase change in     case of unexpected behaviour.      :param str question: Question to the user     :param default_value: Value that will be returned if no input happens     """"""     question = (         prompts[var_name]         if prompts and var_name in prompts and prompts[var_name]         else var_name     )     return YesNoPrompt.ask(f""{prefix}{question}"", default=default_value)   def read_repo_password(question: str) -> str:     """"""Prompt the user to enter a password.      :param question: Question to the user     """"""     return Prompt.ask(question, password=True)   def read_user_choice(var_name: str, options: list, prompts=None, prefix: str = """"):     """"""Prompt the user to choose from several options for the given variable.      The first item will be returned if no input happens.      :param var_name: Variable as specified in the context     :param list options: Sequence of options that are available to select from     :return: Exactly one item of ``options`` that has been chosen by the user     """"""     if not options:         raise ValueError      choice_map = OrderedDict((f'{i}', value) for i, value in enumerate(options, 1))     choices = choice_map.keys()      question = f""Select {var_name}""      choice_lines: Iterator[str] = starmap(         ""    [bold magenta]{}[/] - [bold]{}[/]"".format, choice_map.items()     )      # Handle if human-readable prompt is provided     if prompts and var_name in prompts:         if isinstance(prompts[var_name], str):             question = prompts[var_name]         else:             if ""__prompt__"" in prompts[var_name]:                 question = prompts[var_name][""__prompt__""]             choice_lines = (                 f""    [bold magenta]{i}[/] - [bold]{prompts[var_name][p]}[/]""                 if p in prompts[var_name]                 else f""    [bold magenta]{i}[/] - [bold]{p}[/]""                 for i, p in choice_map.items()             )      prompt = '\n'.join(         (             f""{prefix}{question}"",             ""\n"".join(choice_lines),             ""    Choose from"",         )     )      user_choice = Prompt.ask(prompt, choices=list(choices), default=next(iter(choices)))     return choice_map[user_choice]   DEFAULT_DISPLAY = 'default'   def process_json(user_value: str):     """"""Load user-supplied value as a JSON dict.      :param user_value: User-supplied value to load as a JSON dict     """"""     try:         user_dict = json.loads(user_value, object_pairs_hook=OrderedDict)     except Exception as error:         # Leave it up to click to ask the user again         raise InvalidResponse('Unable to decode to JSON.') from error      if not isinstance(user_dict, dict):         # Leave it up to click to ask the user again         raise InvalidResponse('Requires JSON dict.')      return user_dict   class JsonPrompt(PromptBase[dict]):     """"""A prompt that returns a dict from JSON string.""""""      default = None     response_type = dict     validate_error_message = ""[prompt.invalid]  Please enter a valid JSON string""      @staticmethod     def process_response(value: str) -> dict[str, Any]:         """"""Convert choices to a dict.""""""         return process_json(value)   def read_user_dict(var_name: str, default_value, prompts=None, prefix: str = """"):     """"""Prompt the user to provide a dictionary of data.      :param var_name: Variable as specified in the context     :param default_value: Value that will be returned if no input is provided     :return: A Python dictionary to use in the context.     """"""     if not isinstance(default_value, dict):         raise TypeError      question = (         prompts[var_name]         if prompts and var_name in prompts and prompts[var_name]         else var_name     )     user_value = JsonPrompt.ask(         f""{prefix}{question} [cyan bold]({DEFAULT_DISPLAY})[/]"",         default=default_value,         show_default=False,     )     return user_value   _Raw: TypeAlias = Union[bool, Dict[""_Raw"", ""_Raw""], List[""_Raw""], str, None]   def render_variable(     env: Environment,     raw: _Raw,     cookiecutter_dict: dict[str, Any], ) -> str:     """"""Render the next variable to be displayed in the user prompt.      Inside the prompting taken from the cookiecutter.json file, this renders     the next variable. For example, if a project_name is ""Peanut Butter     Cookie"", the repo_name could be be rendered with:          `{{ cookiecutter.project_name.replace("" "", ""_"") }}`.      This is then presented to the user as the default.      :param Environment env: A Jinja2 Environment object.     :param raw: The next value to be prompted for by the user.     :param dict cookiecutter_dict: The current context as it's gradually         being populated with variables.     :return: The rendered value for the default variable.     """"""     if raw is None or isinstance(raw, bool):         return raw     elif isinstance(raw, dict):         return {             render_variable(env, k, cookiecutter_dict): render_variable(                 env, v, cookiecutter_dict             )             for k, v in raw.items()         }     elif isinstance(raw, list):         return [render_variable(env, v, cookiecutter_dict) for v in raw]     elif not isinstance(raw, str):         raw = str(raw)      template = env.from_string(raw)      return template.render(cookiecutter=cookiecutter_dict)   def _prompts_from_options(options: dict) -> dict:     """"""Process template options and return friendly prompt information.""""""     prompts = {""__prompt__"": ""Select a template""}     for option_key, option_value in options.items():         title = str(option_value.get(""title"", option_key))         description = option_value.get(""description"", option_key)         label = title if title == description else f""{title} ({description})""         prompts[option_key] = label     return prompts   def prompt_choice_for_template(     key: str, options: dict, no_input: bool ) -> OrderedDict[str, Any]:     """"""Prompt user with a set of options to choose from.      :param no_input: Do not prompt for user input and return the first available option.     """"""     opts = list(options.keys())     prompts = {""templates"": _prompts_from_options(options)}     return opts[0] if no_input else read_user_choice(key, opts, prompts, """")   def prompt_choice_for_config(     cookiecutter_dict: dict[str, Any],     env: Environment,     key: str,     options,     no_input: bool,     prompts=None,     prefix: str = """", ) -> OrderedDict[str, Any] | str:     """"""Prompt user with a set of options to choose from.      :param no_input: Do not prompt for user input and return the first available option.     """"""     rendered_options = [render_variable(env, raw, cookiecutter_dict) for raw in options]     if no_input:         return rendered_options[0]     return read_user_choice(key, rendered_options, prompts, prefix)   def prompt_for_config(     context: dict[str, Any], no_input: bool = False ) -> OrderedDict[str, Any]:     """"""Prompt user to enter a new config.      :param dict context: Source for field names and sample values.     :param no_input: Do not prompt for user input and use only values from context.     """"""     cookiecutter_dict = OrderedDict([])     env = create_env_with_context(context)     prompts = context['cookiecutter'].pop('__prompts__', {})      # First pass: Handle simple and raw variables, plus choices.     # These must be done first because the dictionaries keys and     # values might refer to them.     count = 0     all_prompts = context['cookiecutter'].items()     visible_prompts = [k for k, _ in all_prompts if not k.startswith(""_"")]     size = len(visible_prompts)     for key, raw in all_prompts:         if key.startswith('_') and not key.startswith('__'):             cookiecutter_dict[key] = raw             continue         elif key.startswith('__'):             cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)             continue          if not isinstance(raw, dict):             count += 1             prefix = f""  [dim][{count}/{size}][/] ""          try:             if isinstance(raw, list):                 # We are dealing with a choice variable                 val = prompt_choice_for_config(                     cookiecutter_dict, env, key, raw, no_input, prompts, prefix                 )                 cookiecutter_dict[key] = val             elif isinstance(raw, bool):                 # We are dealing with a boolean variable                 if no_input:                     cookiecutter_dict[key] = render_variable(                         env, raw, cookiecutter_dict                     )                 else:                     cookiecutter_dict[key] = read_user_yes_no(key, raw, prompts, prefix)             elif not isinstance(raw, dict):                 # We are dealing with a regular variable                 val = render_variable(env, raw, cookiecutter_dict)                  if not no_input:                     val = read_user_variable(key, val, prompts, prefix)                  cookiecutter_dict[key] = val         except UndefinedError as err:             msg = f""Unable to render variable '{key}'""             raise UndefinedVariableInTemplate(msg, err, context) from err      # Second pass; handle the dictionaries.     for key, raw in context['cookiecutter'].items():         # Skip private type dicts not to be rendered.         if key.startswith('_') and not key.startswith('__'):             continue          try:             if isinstance(raw, dict):                 # We are dealing with a dict variable                 count += 1                 prefix = f""  [dim][{count}/{size}][/] ""                 val = render_variable(env, raw, cookiecutter_dict)                  if not no_input and not key.startswith('__'):                     val = read_user_dict(key, val, prompts, prefix)                  cookiecutter_dict[key] = val         except UndefinedError as err:             msg = f""Unable to render variable '{key}'""             raise UndefinedVariableInTemplate(msg, err, context) from err      return cookiecutter_dict   def choose_nested_template(     context: dict[str, Any], repo_dir: Path | str, no_input: bool = False ) -> str:     """"""Prompt user to select the nested template to use.      :param context: Source for field names and sample values.     :param repo_dir: Repository directory.     :param no_input: Do not prompt for user input and use only values from context.     :returns: Path to the selected template.     """"""     cookiecutter_dict: OrderedDict[str, Any] = OrderedDict([])     env = create_env_with_context(context)     prefix = """"     prompts = context['cookiecutter'].pop('__prompts__', {})     key = ""templates""     config = context['cookiecutter'].get(key, {})     if config:         # Pass         val = prompt_choice_for_template(key, config, no_input)         template = config[val][""path""]     else:         # Old style         key = ""template""         config = context['cookiecutter'].get(key, [])         val = prompt_choice_for_config(             cookiecutter_dict, env, key, config, no_input, prompts, prefix         )         template = re.search(r'\((.+)\)', val).group(1)      template = Path(template) if template else None     if not (template and not template.is_absolute()):         raise ValueError(""Illegal template path"")      repo_dir = Path(repo_dir).resolve()     template_path = (repo_dir / template).resolve()     # Return path as string     return f""{template_path}""   def prompt_and_delete(path: Path | str, no_input: bool = False) -> bool:     """"""     Ask user if it's okay to delete the previously-downloaded file/directory.      If yes, delete it. If no, checks to see if the old version should be     reused. If yes, it's reused; otherwise, Cookiecutter exits.      :param path: Previously downloaded zipfile.     :param no_input: Suppress prompt to delete repo and just delete it.     :return: True if the content was deleted     """"""     # Suppress prompt if called via API     if no_input:         ok_to_delete = True     else:         question = (             f""You've downloaded {path} before. Is it okay to delete and re-download it?""         )          ok_to_delete = read_user_yes_no(question, 'yes')      if ok_to_delete:         if os.path.isdir(path):             rmtree(path)         else:             os.remove(path)         return True     else:         ok_to_reuse = read_user_yes_no(             ""Do you want to re-use the existing version?"", 'yes'         )          if ok_to_reuse:             return False          sys.exit()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\replay.py,replay.py_chunk0,""""""" cookiecutter.replay.  ------------------- """"""  from __future__ import annotations  import json import os from typing import TYPE_CHECKING, Any  from cookiecutter.utils import make_sure_path_exists  if TYPE_CHECKING:     from pathlib import Path   def get_file_name(replay_dir: Path | str, template_name: str) -> str:     """"""Get the name of file.""""""     suffix = '.json' if not template_name.endswith('.json') else ''     file_name = f'{template_name}{suffix}'     return os.path.join(replay_dir, file_name)   def dump(replay_dir: Path | str, template_name: str, context: dict[str, Any]) -> None:     """"""Write json data to file.""""""     make_sure_path_exists(replay_dir)      if 'cookiecutter' not in context:         raise ValueError('Context is required to contain a cookiecutter key')      replay_file = get_file_name(replay_dir, template_name)      with open(replay_file, 'w', encoding=""utf-8"") as outfile:         json.dump(context, outfile, indent=2)   def load(replay_dir: Path | str, template_name: str) -> dict[str, Any]:     """"""Read json data from file.""""""     replay_file = get_file_name(replay_dir, template_name)      with open(replay_file, encoding=""utf-8"") as infile:         context: dict[str, Any] = json.load(infile)      if 'cookiecutter' not in context:         raise ValueError('Context is required to contain a cookiecutter key')      return context"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\repository.py,repository.py_chunk0,"""""""Cookiecutter repository functions.""""""  from __future__ import annotations  import os import re from typing import TYPE_CHECKING  from cookiecutter.exceptions import RepositoryNotFound from cookiecutter.vcs import clone from cookiecutter.zipfile import unzip  if TYPE_CHECKING:     from pathlib import Path  REPO_REGEX = re.compile(     r"""""" # something like git:// ssh:// file:// etc. ((((git|hg)\+)?(git|ssh|file|https?):(//)?)  |                                      # or  (\w+@[\w\.]+)                          # something like user@... ) """""",     re.VERBOSE, )   def is_repo_url(value: str) -> bool:     """"""Return True if value is a repository URL.""""""     return bool(REPO_REGEX.match(value))   def is_zip_file(value: str) -> bool:     """"""Return True if value is a zip file.""""""     return value.lower().endswith('.zip')   def expand_abbreviations(template: str, abbreviations: dict[str, str]) -> str:     """"""Expand abbreviations in a template name.      :param template: The project template name.     :param abbreviations: Abbreviation definitions.     """"""     if template in abbreviations:         return abbreviations[template]      # Split on colon. If there is no colon, rest will be empty     # and prefix will be the whole template     prefix, _sep, rest = template.partition(':')     if prefix in abbreviations:         return abbreviations[prefix].format(rest)      return template   def repository_has_cookiecutter_json(repo_directory: str) -> bool:     """"""Determine if `repo_directory` contains a `cookiecutter.json` file.      :param repo_directory: The candidate repository directory.     :return: True if the `repo_directory` is valid, else False.     """"""     repo_directory_exists = os.path.isdir(repo_directory)      repo_config_exists = os.path.isfile(         os.path.join(repo_directory, 'cookiecutter.json')     )     return repo_directory_exists and repo_config_exists   def determine_repo_dir(     template: str,     abbreviations: dict[str, str],     clone_to_dir: Path | str,     checkout: str | None,     no_input: bool,     password: str | None = None,     directory: str | None = None, ) -> tuple[str, bool]:     """"""     Locate the repository directory from a template reference.      Applies repository abbreviations to the template reference.     If the template refers to a repository URL, clone it.     If the template is a path to a local repository, use it.      :param template: A directory containing a project template directory,         or a URL to a git repository.     :param abbreviations: A dictionary of repository abbreviation         definitions.     :param clone_to_dir: The directory to clone the repository into.     :param checkout: The branch, tag or commit ID to checkout after clone.     :param no_input: Do not prompt for user input and eventually force a refresh of         cached resources.     :param password: The password to use when extracting the repository.     :param directory: Directory within repo where cookiecutter.json lives.     :return: A tuple containing the cookiecutter template directory, and         a boolean describing whether that directory should be cleaned up         after the template has been instantiated.     :raises: `RepositoryNotFound` if a repository directory could not be found.     """"""     template = expand_abbreviations(template, abbreviations)      if is_zip_file(template):         unzipped_dir = unzip(             zip_uri=template,             is_url=is_repo_url(template),             clone_to_dir=clone_to_dir,             no_input=no_input,             password=password,         )         repository_candidates = [unzipped_dir]         cleanup = True     elif is_repo_url(template):         cloned_repo = clone(             repo_url=template,             checkout=checkout,             clone_to_dir=clone_to_dir,             no_input=no_input,         )         repository_candidates = [cloned_repo]         cleanup = False     else:         repository_candidates = [template, os.path.join(clone_to_dir, template)]         cleanup = False      if directory:         repository_candidates = [             os.path.join(s, directory) for s in repository_candidates         ]      for repo_candidate in repository_candidates:         if repository_has_cookiecutter_json(repo_candidate):             return repo_candidate, cleanup      raise RepositoryNotFound(         'A valid repository for ""{}"" could not be found in the following '         'locations:\n{}'.format(template, '\n'.join(repository_candidates))     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\utils.py,utils.py_chunk0,"""""""Helper functions used throughout Cookiecutter.""""""  from __future__ import annotations  import contextlib import logging import os import shutil import stat import tempfile from pathlib import Path from typing import TYPE_CHECKING, Any, Iterator  from jinja2.ext import Extension  from cookiecutter.environment import StrictEnvironment  if TYPE_CHECKING:     from jinja2 import Environment  logger = logging.getLogger(__name__)   def force_delete(func, path, _exc_info) -> None:  # type: ignore[no-untyped-def]     """"""Error handler for `shutil.rmtree()` equivalent to `rm -rf`.      Usage: `shutil.rmtree(path, onerror=force_delete)`     From https://docs.python.org/3/library/shutil.html#rmtree-example     """"""     os.chmod(path, stat.S_IWRITE)     func(path)   def rmtree(path: Path | str) -> None:     """"""Remove a directory and all its contents. Like rm -rf on Unix.      :param path: A directory path.     """"""     shutil.rmtree(path, onerror=force_delete)   def make_sure_path_exists(path: Path | str) -> None:     """"""Ensure that a directory exists.      :param path: A directory tree path for creation.     """"""     logger.debug('Making sure path exists (creates tree if not exist): %s', path)     try:         Path(path).mkdir(parents=True, exist_ok=True)     except OSError as error:         raise OSError(f'Unable to create directory at {path}') from error   @contextlib.contextmanager def work_in(dirname: Path | str | None = None) -> Iterator[None]:     """"""Context manager version of os.chdir.      When exited, returns to the working directory prior to entering.     """"""     curdir = os.getcwd()     try:         if dirname is not None:             os.chdir(dirname)         yield     finally:         os.chdir(curdir)   def make_executable(script_path: Path | str) -> None:     """"""Make `script_path` executable.      :param script_path: The file to change     """"""     status = os.stat(script_path)     os.chmod(script_path, status.st_mode | stat.S_IEXEC)   def simple_filter(filter_function) -> type[Extension]:  # type: ignore[no-untyped-def]     """"""Decorate a function to wrap it in a simplified jinja2 extension.""""""      class SimpleFilterExtension(Extension):         def __init__(self, environment: Environment) -> None:             super().__init__(environment)             environment.filters[filter_function.__name__] = filter_function      SimpleFilterExtension.__name__ = filter_function.__name__     return SimpleFilterExtension   def create_tmp_repo_dir(repo_dir: Path | str) -> Path:     """"""Create a temporary dir with a copy of the contents of repo_dir.""""""     repo_dir = Path(repo_dir).resolve()     base_dir = tempfile.mkdtemp(prefix='cookiecutter')     new_dir = f""{base_dir}/{repo_dir.name}""     logger.debug(f'Copying repo_dir from {repo_dir} to {new_dir}')     shutil.copytree(repo_dir, new_dir)     return Path(new_dir)   def create_env_with_context(context: dict[str, Any]) -> StrictEnvironment:     """"""Create a jinja environment using the provided context.""""""     envvars = context.get('cookiecutter', {}).get('_jinja2_env_vars', {})      return StrictEnvironment(context=context, keep_trailing_newline=True, **envvars)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\vcs.py,vcs.py_chunk0,"""""""Helper functions for working with version control systems.""""""  from __future__ import annotations  import logging import os import subprocess from pathlib import Path from shutil import which from typing import TYPE_CHECKING  if TYPE_CHECKING:     from typing_extensions import Literal  from cookiecutter.exceptions import (     RepositoryCloneFailed,     RepositoryNotFound,     UnknownRepoType,     VCSNotInstalled, ) from cookiecutter.prompt import prompt_and_delete from cookiecutter.utils import make_sure_path_exists  logger = logging.getLogger(__name__)   BRANCH_ERRORS = [     'error: pathspec',     'unknown revision', ]   def identify_repo(repo_url: str) -> tuple[Literal[""git"", ""hg""], str]:     """"""Determine if `repo_url` should be treated as a URL to a git or hg repo.      Repos can be identified by prepending ""hg+"" or ""git+"" to the repo URL.      :param repo_url: Repo URL of unknown type.     :returns: ('git', repo_url), ('hg', repo_url), or None.     """"""     repo_url_values = repo_url.split('+')     if len(repo_url_values) == 2:         repo_type = repo_url_values[0]         if repo_type in [""git"", ""hg""]:             return repo_type, repo_url_values[1]  # type: ignore[return-value]         else:             raise UnknownRepoType     else:         if 'git' in repo_url:             return 'git', repo_url         elif 'bitbucket' in repo_url:             return 'hg', repo_url         else:             raise UnknownRepoType   def is_vcs_installed(repo_type: str) -> bool:     """"""     Check if the version control system for a repo type is installed.      :param repo_type:     """"""     return bool(which(repo_type))   def clone(     repo_url: str,     checkout: str | None = None,     clone_to_dir: Path | str = ""."",     no_input: bool = False, ) -> str:     """"""Clone a repo to the current directory.      :param repo_url: Repo URL of unknown type.     :param checkout: The branch, tag or commit ID to checkout after clone.     :param clone_to_dir: The directory to clone to.                          Defaults to the current directory.     :param no_input: Do not prompt for user input and eventually force a refresh of         cached resources.     :returns: str with path to the new directory of the repository.     """"""     # Ensure that clone_to_dir exists     clone_to_dir = Path(clone_to_dir).expanduser()     make_sure_path_exists(clone_to_dir)      # identify the repo_type     repo_type, repo_url = identify_repo(repo_url)      # check that the appropriate VCS for the repo_type is installed     if not is_vcs_installed(repo_type):         msg = f""'{repo_type}' is not installed.""         raise VCSNotInstalled(msg)      repo_url = repo_url.rstrip('/')     repo_name = os.path.split(repo_url)[1]     if repo_type == 'git':         repo_name = repo_name.split(':')[-1].rsplit('.git')[0]         repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))     if repo_type == 'hg':         repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))     logger.debug(f'repo_dir is {repo_dir}')      if os.path.isdir(repo_dir):         clone = prompt_and_delete(repo_dir, no_input=no_input)     else:         clone = True      if clone:         try:             subprocess.check_output(                 [repo_type, 'clone', repo_url],                 cwd=clone_to_dir,                 stderr=subprocess.STDOUT,             )             if checkout is not None:                 checkout_params = [checkout]                 # Avoid Mercurial ""--config"" and ""--debugger"" injection vulnerability                 if repo_type == ""hg"":                     checkout_params.insert(0, ""--"")                 subprocess.check_output(                     [repo_type, 'checkout', *checkout_params],                     cwd=repo_dir,                     stderr=subprocess.STDOUT,                 )         except subprocess.CalledProcessError as clone_error:             output = clone_error.output.decode('utf-8')             if 'not found' in output.lower():                 raise RepositoryNotFound(                     f'The repository {repo_url} could not be found, '                     'have you made a typo?'                 ) from clone_error             if any(error in output for error in BRANCH_ERRORS):                 raise RepositoryCloneFailed(                     f'The {checkout} branch of repository '                     f'{repo_url} could not found, have you made a typo?'                 ) from clone_error             logger.error('git clone failed with error: %s', output)             raise      return repo_dir"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\zipfile.py,zipfile.py_chunk0,"""""""Utility functions for handling and fetching repo archives in zip format.""""""  from __future__ import annotations  import os import tempfile from pathlib import Path from zipfile import BadZipFile, ZipFile  import requests  from cookiecutter.exceptions import InvalidZipRepository from cookiecutter.prompt import prompt_and_delete, read_repo_password from cookiecutter.utils import make_sure_path_exists   def unzip(     zip_uri: str,     is_url: bool,     clone_to_dir: Path | str = ""."",     no_input: bool = False,     password: str | None = None, ) -> str:     """"""Download and unpack a zipfile at a given URI.      This will download the zipfile to the cookiecutter repository,     and unpack into a temporary directory.      :param zip_uri: The URI for the zipfile.     :param is_url: Is the zip URI a URL or a file?     :param clone_to_dir: The cookiecutter repository directory         to put the archive into.     :param no_input: Do not prompt for user input and eventually force a refresh of         cached resources.     :param password: The password to use when unpacking the repository.     """"""     # Ensure that clone_to_dir exists     clone_to_dir = Path(clone_to_dir).expanduser()     make_sure_path_exists(clone_to_dir)      if is_url:         # Build the name of the cached zipfile,         # and prompt to delete if it already exists.         identifier = zip_uri.rsplit('/', 1)[1]         zip_path = os.path.join(clone_to_dir, identifier)          if os.path.exists(zip_path):             download = prompt_and_delete(zip_path, no_input=no_input)         else:             download = True          if download:             # (Re) download the zipfile             r = requests.get(zip_uri, stream=True, timeout=100)             with open(zip_path, 'wb') as f:                 for chunk in r.iter_content(chunk_size=1024):                     if chunk:  # filter out keep-alive new chunks                         f.write(chunk)     else:         # Just use the local zipfile as-is.         zip_path = os.path.abspath(zip_uri)      # Now unpack the repository. The zipfile will be unpacked     # into a temporary directory     try:         zip_file = ZipFile(zip_path)          if len(zip_file.namelist()) == 0:             raise InvalidZipRepository(f'Zip repository {zip_uri} is empty')          # The first record in the zipfile should be the directory entry for         # the archive. If it isn't a directory, there's a problem.         first_filename = zip_file.namelist()[0]         if not first_filename.endswith('/'):             raise InvalidZipRepository(                 f""Zip repository {zip_uri} does not include a top-level directory""             )          # Construct the final target directory         project_name = first_filename[:-1]         unzip_base = tempfile.mkdtemp()         unzip_path = os.path.join(unzip_base, project_name)          # Extract the zip file into the temporary directory         try:             zip_file.extractall(path=unzip_base)         except RuntimeError as runtime_err:             # File is password protected; try to get a password from the             # environment; if that doesn't work, ask the user.             if password is not None:                 try:                     zip_file.extractall(path=unzip_base, pwd=password.encode('utf-8'))                 except RuntimeError as e:                     raise InvalidZipRepository(                         'Invalid password provided for protected repository'                     ) from e             elif no_input:                 raise InvalidZipRepository(                     'Unable to unlock password protected repository'                 ) from runtime_err             else:                 retry: int | None = 0                 while retry is not None:                     try:                         password = read_repo_password('Repo password')                         zip_file.extractall(                             path=unzip_base, pwd=password.encode('utf-8')                         )                         retry = None                     except RuntimeError as e:  # noqa: PERF203                         retry += 1  # type: ignore[operator]                         if retry == 3:                             raise InvalidZipRepository(                                 'Invalid password provided for protected repository'                             ) from e      except BadZipFile as e:         raise InvalidZipRepository(             f'Zip repository {zip_uri} is not a valid zip archive:'         ) from e      return unzip_path"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\__init__.py,__init__.py_chunk0,"""""""Main package for Cookiecutter.""""""  from pathlib import Path   def _get_version() -> str:     """"""Read VERSION.txt and return its contents.""""""     path = Path(__file__).parent.resolve()     version_file = path / ""VERSION.txt""     return version_file.read_text(encoding=""utf-8"").strip()   __version__ = _get_version()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\cookiecutter\__main__.py,__main__.py_chunk0,"""""""Allow cookiecutter to be executable through `python -m cookiecutter`.""""""  from cookiecutter.cli import main  if __name__ == ""__main__"":     main(prog_name=""cookiecutter"")"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\AUTHORS.md,AUTHORS.md_chunk0,"Credits  Development Leads  Audrey Roy Greenfeld (@audreyfeldroy)  Daniel Roy Greenfeld (@pydanny)  Raphael Pierzina (@hackebrot)  Core Committers  Michael Joseph (@michaeljoseph)  Paul Moore (@pfmoore)  Andrey Shpak (@insspb)  Sorin Sbarnea (@ssbarnea)  Fábio C. Barrionuevo da Luz (@luzfcb)  Simone Basso (@simobasso)  Jens Klein (@jensens)  Érico Andrei (@ericof)  Contributors  Steven Loria (@sloria)  Goran Peretin (@gperetin)  Hamish Downer (@foobacca)  Thomas Orozco (@krallin)  Jindrich Smitka (@s-m-i-t-a)  Benjamin Schwarze (@benjixx)  Raphi (@raphigaziano)  Thomas Chiroux (@ThomasChiroux)  Sergi Almacellas Abellana (@pokoli)  Alex Gaynor (@alex)  Rolo (@rolo)  Pablo (@oubiga)  Bruno Rocha (@rochacbruno)  Alexander Artemenko (@svetlyak40wt)  Mahmoud Abdelkader (@mahmoudimus)  Leonardo Borges Avelino (@lborgav)  Chris Trotman (@solarnz)  Rolf (@relekang)  Noah Kantrowitz (@coderanger)  Vincent Bernat (@vincentbernat)  Germán Moya (@pbacterio)  Ned Batchelder (@nedbat)  Dave Dash (@davedash)  Johan Charpentier (@cyberj)  Éric Araujo (@merwok)  saxix (@saxix)  Tzu-ping Chung (@uranusjr)  Caleb Hattingh (@cjrh)  Flavio Curella (@fcurella)  Adam Venturella (@aventurella)  Monty Taylor (@emonty)  schacki (@schacki)  Ryan Olson (@ryanolson)  Trey Hunner (@treyhunner)  Russell Keith-Magee (@freakboy3742)  Mishbah Razzaque (@mishbahr)  Robin Andeer (@robinandeer)  Rachel Sanders (@trustrachel)  Rémy Hubscher (@Natim)  Dino Petron3 (@dinopetrone)  Peter Inglesby (@inglesp)  Ramiro Batista da Luz (@ramiroluz)  Omer Katz (@thedrow)  lord63 (@lord63)  Randy Syring (@rsyring)  Mark Jones (@mark0978)  Marc Abramowitz (@msabramo)  Lucian Ursu (@LucianU)  Osvaldo Santana Neto (@osantana)  Matthias84 (@Matthias84)  Simeon Visser (@svisser)  Guruprasad (@lgp171188)  Charles-Axel Dein (@charlax)  Diego Garcia (@drgarcia1986)  maiksensi (@maiksensi)  Andrew Conti (@agconti)  Valentin Lab (@vaab)  Ilja Bauer (@iljabauer)  Elias Dorneles (@eliasdorneles)  Matias Saguir (@mativs)  Johannes (@johtso)  macrotim (@macrotim)  Will McGinnis (@wdm0006)  Cédric Krier (@cedk)  Tim Osborn (@ptim)  Aaron Gallagher (@habnabit)  mozillazg (@mozillazg)  Joachim Jablon (@ewjoachim)  Andrew Ittner (@tephyr)  Diane DeMers Chen (@purplediane)  zzzirk (@zzzirk)  Carol Willing (@willingc)  phoebebauer (@phoebebauer)  Adam Chainz (@adamchainz)  Sulé (@suledev)  Evan Palmer (@palmerev)  Bruce Eckel (@BruceEckel)  Robert Lyon (@ivanlyon)  Terry Bates (@terryjbates)  Brett Cannon (@brettcannon)  Michael Warkentin (@mwarkentin)  Bartłomiej Kurzeja (@B3QL)  Thomas O'Donnell (@andytom)  Jeremy Carbaugh (@jcarbaugh)  Nathan Cheung (@cheungnj)  Abdó Roig-Maranges (@aroig)  Steve Piercy (@stevepiercy)  Corey (@coreysnyder04)  Dmitry Evstratov (@devstrat)  Eyal Levin (@eyalev)  mathagician (@mathagician)  Guillaume Gelin (@ramnes)  @delirious-lettuce (@delirious-lettuce)  Gasper Vozel (@karantan)  Joshua Carp (@jmcarp)  @meahow (@meahow)  Andrea Grandi (@andreagrandi)  Issa Jubril (@jubrilissa)  Nytiennzo Madooray (@Nythiennzo)  Erik Bachorski (@dornheimer)  cclauss (@cclauss)  Andy Craze (@accraze)  Anthony Sottile (@asottile)  Jonathan Sick (@jonathansick)  Hugo (@hugovk)  Min ho Kim (@minho42)  Ryan Ly (@rly)  Akintola Rahmat (@mihrab34)  Jai Ram Rideout (@jairideout)  Diego Carrasco Gubernatis (@dacog)  Wagner Negrão (@wagnernegrao)  Josh Barnes (@jcb91)  Nikita Sobolev (@sobolevn)  Matt Stibbs (@mattstibbs)  MinchinWeb (@MinchinWeb)  kishan (@kishan)  tonytheleg (@tonytheleg)  Roman Hartmann (@RomHartmann)  DSEnvel (@DSEnvel)  kishan (@kishan)  Bruno Alla (@browniebroke)  nicain (@nicain)  Carsten Rösnick-Neugebauer (@croesnick)  igorbasko01 (@igorbasko01)  Dan Booth Dev (@DanBoothDev)  Pablo Panero (@ppanero)  Chuan-Heng Hsiao (@chhsiao1981)  Mohammad Hossein Sekhavat (@mhsekhavat)  Amey Joshi (@amey589)  Paul Harrison (@smoothml)  Fabio Todaro (@SharpEdgeMarshall)  Nicholas Bollweg (@bollwyvl)  Jace Browning (@jacebrowning)  Ionel Cristian Mărieș (@ionelmc)  Kishan Mehta (@kishan3)  Wieland Hoffmann (@mineo)  Antony Lee (@anntzer)  Aurélien Gâteau (@agateau)  Axel H. (@noirbizarre)  Chris (@chrisbrake)  Chris Streeter (@streeter)  Gábor Lipták (@gliptak)  Javier Sánchez Portero (@javiersanp)  Nimrod Milo (@milonimrod)  Philipp Kats (@Casyfill)  Reinout van Rees (@reinout)  Rémy Greinhofer (@rgreinho)  Sebastian (@sebix)  Stuart Mumford (@Cadair)  Tom Forbes (@orf)  Xie Yanbo (@xyb)  Maxim Ivanov (@ivanovmg)  Backers  We would like to thank the following people for supporting us in our efforts to maintain and improve Cookiecutter:  Alex DeBrie  Alexandre Y. Harano  Bruno Alla  Carol Willing  Russell Keith-Magee  Sprint Contributors  PyCon 2016 Sprint  The following people made contributions to the cookiecutter project at the PyCon sprints in Portland, OR from June 2-5 2016. Contributions include user testing, debugging, improving documentation, reviewing issues, writing tutorials, creating and updating project templates, and teaching each other.  Adam Chainz (@adamchainz)  Andrew Ittner (@tephyr)  Audrey Roy Greenfeld (@audreyfeldroy)  Carol Willing (@willingc)  Christopher Clarke (@chrisdev)  Citlalli Murillo (@citmusa)  Daniel Roy Greenfeld (@pydanny)  Diane DeMers Chen (@purplediane)  Elaine Wong (@elainewong)  Elias Dorneles (@eliasdorneles)  Emily Cain (@emcain)  John Roa (@jhonjairoroa87)  Jonan Scheffler (@1337807)  Phoebe Bauer (@phoebebauer)  Kartik Sundararajan (@skarbot)  Katia Lira (@katialira)  Leonardo Jimenez (@xpostudio4)  Lindsay Slazakowski (@lslaz1)  Meghan Heintz (@dot2dotseurat)  Raphael Pierzina (@hackebrot)  Umair Ashraf (@umrashrf)  Valdir Stumm Junior (@stummjr)  Vivian Guillen (@viviangb)  Zaro (@zaro0508)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\case_studies.md,case_studies.md_chunk0,"Case Studies  This showcase is where organizations can describe how they are using Cookiecutter.  BeeWare  Building Python tools for platforms like mobile phones and set top boxes requires a lot of boilerplate code just to get the project running. Cookiecutter has enabled us to very quickly stub out a starter project in which running Python code can be placed, and makes maintaining those templates very easy. With Cookiecutter we've been able to deliver support Android devices, iOS devices, tvOS boxes, and we're planning to add native support for iOS and Windows devices in the future.  BeeWare is an organization building open source libraries for Python support on all platforms.  ChrisDev  Anytime we start a new project we begin with a Cookiecutter template that generates a Django/Wagtail project Our developers like it for maintainability and our designers enjoy being able to spin up new sites using our tool chain very quickly. Cookiecutter is very useful for because it supports both Mac OSX and Windows users.  ChrisDev is a Trinidad-based consulting agency.  OpenStack  OpenStack uses several Cookiecutter templates to generate:  Openstack compliant puppet-modules  Install guides  New tempest plugins  OpenStack is open source software for creating private and public clouds."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\cli_options.rst,cli_options.rst_chunk0,Command Line Options  cookiecutter.__main__:main
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\CODE_OF_CONDUCT.md,CODE_OF_CONDUCT.md_chunk0,"Code of Conduct  Everyone interacting in the Cookiecutter project's codebases and documentation is expected to follow the PyPA Code of Conduct. This includes, but is not limited to, issue trackers, chat rooms, mailing lists, and other virtual or in real life communication."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\conf.py,conf.py_chunk0,"""""""Documentation build configuration file.""""""  # # cookiecutter documentation build configuration file, created by # sphinx-quickstart on Thu Jul 11 11:31:49 2013. # # This file is execfile()d with the current directory set to its containing # dir. # # Note that not all possible configuration values are present in this # autogenerated file. # # All configuration values have a default; values that are commented out # serve to show the default.  import os import sys  # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # sys.path.insert(0, os.path.abspath('.'))  # For building docs in foreign environments where we don't have all our # dependencies (like readthedocs), mock out imports that cause sphinx to fail. # see: https://docs.readthedocs.io/en/latest/faq.html#i-get-import-errors-on-libraries-that-depend-on-c-modules   # Add parent dir to path cwd = os.getcwd() parent = os.path.dirname(cwd) sys.path.append(parent)  import cookiecutter  # noqa: E402  # -- General configuration ----------------------------------------------------  # If your documentation needs a minimal Sphinx version, state it here. # needs_sphinx = '1.0'  # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named 'sphinx.ext.*') or # your custom ones. extensions = [     'sphinx.ext.autodoc',     'sphinx.ext.doctest',     'sphinx.ext.intersphinx',     'sphinx.ext.todo',     'sphinx.ext.coverage',     'sphinx.ext.imgmath',     'sphinx.ext.ifconfig',     'sphinx.ext.viewcode',     'sphinx_click.ext',     'myst_parser',     'sphinxcontrib.apidoc',     'sphinx_autodoc_typehints', ]  # Add any paths that contain templates here, relative to this directory. templates_path = ['_templates']  # The suffix of source filenames. source_suffix = {'.rst': 'restructuredtext', '.md': 'markdown'}  # The encoding of source files. # source_encoding = 'utf-8-sig'  # The master toctree document. master_doc = 'index'  # General information about the project. project = 'cookiecutter' copyright = '2013-2022, Audrey Roy and Cookiecutter community'  # The version info for the project you're documenting, acts as replacement for # |version| and |release|, also used in various other places throughout the # built documents. # # The short X.Y version. version = cookiecutter.__version__ # The full version, including alpha/beta/rc tags. release = cookiecutter.__version__  # The language for content autogenerated by Sphinx. Refer to documentation # for a list of supported languages. # language = None  # There are two options for replacing |today|: either, you set today to some # non-false value, then it is used: # today = '' # Else, today_fmt is used as the format for a strftime call. # today_fmt = '%B %d, %Y'  # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. exclude_patterns = ['_build']  # The reST default role (used for this markup: `text`) to use for all documents # default_role = None  # If true, '()' will be appended to :func: etc. cross-reference text. # add_function_parentheses = True  # If true, the current module name will be prepended to all description # unit titles (such as .. function::). # add_module_names = True  # If true, sectionauthor and moduleauthor directives will be shown in the # output. They are ignored by default. # show_authors = False  # The name of the Pygments (syntax highlighting) style to use. pygments_style = 'sphinx'  # A list of ignored prefixes for module index sorting. # modindex_common_prefix = []  # If true, keep warnings as ""system message"" paragraphs in the built documents. # keep_warnings = False  # Suppress nonlocal image warnings suppress_warnings = ['image.nonlocal_uri']  # -- Options for HTML output --------------------------------------------------  # The theme to use for HTML and HTML Help pages.  See the documentation for # a list of builtin themes. html_theme = 'sphinx_rtd_theme'  # Theme options are theme-specific and customize the look and feel of a theme # further.  For a list of options available for each theme, see the # documentation. # html_theme_options = {}  # Add any paths that contain custom themes here, relative to this directory. # html_theme_path = []  # The name for this set of Sphinx documents.  If None, it defaults to # ""<project> v<release> documentation"". # html_title = None  # A shorter title for the navigation bar.  Default is the same as html_title. # html_short_title = None  # The name of an image file (relative to this directory) to place at the top # of the sidebar. # html_logo = None  # The name of an image file (within the static path) to use as favicon of the # docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32 # pixels large. # html_favicon = None  # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named ""default.css"" will overwrite the builtin ""default.css"". html_static_path = []  # If not '', a 'Last updated on:' timestamp is inserted at every page bottom, # using the given strftime format. # html_last_updated_fmt = '%b %d, %Y'  # If true, SmartyPants will be used to convert quotes and dashes to # typographically correct entities. # html_use_smartypants = True  # Custom sidebar templates, maps document names to template names. # html_sidebars = {}  # Additional templates that should be rendered to pages, maps page names to # template names. # html_additional_pages = {}  # If false, no module index is generated. # html_domain_indices = True  # If false, no index is generated. # html_use_index = True  # If true, the index is split into individual pages for each letter. # html_split_index = False  # If true, links to the reST sources are added to the pages. # html_show_sourcelink = True  # If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True. # html_show_sphinx = True  # If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True. # html_show_copyright = True  # If true, an OpenSearch description file will be output, and all pages will # contain a <link> tag referring to it.  The value of this option must be the # base URL from which the finished HTML is served. # html_use_opensearch = ''  # This is the file name suffix for HTML files (e.g. "".xhtml""). # html_file_suffix = None  # Output file base name for HTML help builder. htmlhelp_basename = 'cookiecutterdoc'   # -- Options for LaTeX output -------------------------------------------------  latex_elements = {     # The paper size ('letterpaper' or 'a4paper').     # 'papersize': 'letterpaper',     # The font size ('10pt', '11pt' or '12pt').     # 'pointsize': '10pt',     # Additional stuff for the LaTeX preamble.     # 'preamble': '', }  # Grouping the document tree into LaTeX files. List of tuples # (source start file, target name, title, author, documentclass [howto/manual]) latex_documents = [     (         'index',         'cookiecutter.tex',         'cookiecutter Documentation',         'Audrey Roy and Cookiecutter community',         'manual',     ), ]  # The name of an image file (relative to this directory) to place at the top of # the title page. # latex_logo = None  # For ""manual"" documents, if this is true, then toplevel headings are parts, # not chapters. # latex_use_parts = False  # If true, show page references after internal links. # latex_show_pagerefs = False  # If true, show URL addresses after external links. # latex_show_urls = False  # Documents to append as an appendix to all manuals. # latex_appendices = []  # If false, no module index is generated. # latex_domain_indices = True   # -- Options for manual page output -------------------------------------------  # One entry per manual page. List of tuples # (source start file, name, description, authors, manual section). man_pages = [     (         'index',         'cookiecutter',         'cookiecutter Documentation',         ['Audrey Roy and Cookiecutter community'],         1,     ) ]  # If true, show URL addresses after external links. # man_show_urls = False   # -- Options for Texinfo output -----------------------------------------------  # Grouping the document tree into Texinfo files. List of tuples # (source start file, target name, title, author, #  dir menu entry, description, category) texinfo_documents = [     (         'index',         'cookiecutter',         'cookiecutter Documentation',         'Audrey Roy and Cookiecutter community',         'cookiecutter',         'Creates projects from project templates',         'Miscellaneous',     ), ]  # Documents to append as an appendix to all manuals. # texinfo_appendices = []  # If false, no module index is generated. # texinfo_domain_indices = True  # How to display URL addresses: 'footnote', 'no', or 'inline'. # texinfo_show_urls = 'footnote'  # If true, do not generate a @detailmenu in the ""Top"" node's menu. # texinfo_no_detailmenu = False   # -- Options for Epub output --------------------------------------------------  # Bibliographic Dublin Core info. epub_title = 'cookiecutter' epub_author = 'Audrey Roy' epub_publisher = 'Audrey Roy and Cookiecutter community' epub_copyright = '2013-2022, Audrey Roy and Cookiecutter community'  # The language of the text. It defaults to the language option # or en if the language is not set. # epub_language = ''  # The scheme of the identifier. Typical schemes are ISBN or URL. # epub_scheme = ''  # The unique identifier of the text. This can be a ISBN number # or the project homepage. # epub_identifier = ''  # A unique identification for the text. # epub_uid = ''  # A tuple containing the cover image and cover page html template filenames. # epub_cover = ()  # A sequence of (type, uri, title) tuples for the guide element of content.opf. # epub_guide = ()  # HTML files that should be inserted before the pages created by sphinx. # The format is a list of tuples containing the path and title. # epub_pre_files = []  # HTML files that should be inserted after the pages created by sphinx. # The format is a list of tuples containing the path and title. # epub_post_files = []  # A list of files that should not be packed into the epub file. # epub_exclude_files = []  # The depth of the table of contents in toc.ncx. # epub_tocdepth = 3  # Allow duplicate toc entries. # epub_tocdup = True  # Fix unsupported image types using the PIL. # epub_fix_images = False  # Scale large images. # epub_max_image_width = 0  # If 'no', URL addresses will not be shown. # epub_show_urls = 'inline'  # If false, no index is generated. # epub_use_index = True   # Example configuration for intersphinx: refer to the Python standard library. intersphinx_mapping = {     ""python"": (""https://docs.python.org/3"", None),     ""requests"": (""https://requests.readthedocs.io/en/latest/"", None),     ""click"": (""https://click.palletsprojects.com/en/latest"", None), } myst_enable_extensions = [     ""tasklist"",     ""strikethrough"",     ""fieldlist"", ] myst_heading_anchors = 3 # Apidoc extension config apidoc_module_dir = ""../cookiecutter"" apidoc_output_dir = ""."" apidoc_toc_file = False apidoc_extra_args = [""-t"", ""_templates""]  autodoc_member_order = ""groupwise"" autodoc_typehints = ""none"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\CONTRIBUTING.md,CONTRIBUTING.md_chunk0,"Contributing  Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.  Types of Contributions  Contributor Setup  Contributor Guidelines  Contributor Testing  Core Committer Guide  Types of Contributions  You can contribute in many ways:  Report Bugs  Report bugs at https://github.com/cookiecutter/cookiecutter/issues.  If you are reporting a bug, please include:  Your operating system name and version.  Any details about your local setup that might be helpful in troubleshooting.  If you can, provide detailed steps to reproduce the bug.  If you don't have steps to reproduce the bug, just note your observations in as much detail as you can.   Questions to start a discussion about the issue are welcome.  Fix Bugs  Look through the GitHub issues for bugs. Anything tagged with ""bug"" is open to whoever wants to implement it.  Implement Features  Look through the GitHub issues for features. Anything tagged with ""enhancement"" and ""please-help"" is open to whoever wants to implement it.  Please do not combine multiple feature enhancements into a single pull request.  Note: this project is very conservative, so new features that aren't tagged with ""please-help"" might not get into core. We're trying to keep the code base small, extensible, and streamlined. Whenever possible, it's best to try and implement feature ideas as separate projects outside of the core codebase.  Write Documentation  Cookiecutter could always use more documentation, whether as part of the official Cookiecutter docs, in docstrings, or even on the web in blog posts, articles, and such.  If you want to review your changes on the documentation locally, you can do:  bash pip install -r docs/requirements.txt make servedocs  This will compile the documentation, open it in your browser and start watching the files for changes, recompiling as you save.  Submit Feedback  The best way to send feedback is to file an issue at https://github.com/cookiecutter/cookiecutter/issues.  If you are proposing a feature:  Explain in detail how it would work.  Keep the scope as narrow as possible, to make it easier to implement.  Remember that this is a volunteer-driven project, and that contributions are welcome :)  Setting Up the Code for Local Development  Here's how to set up cookiecutter for local development.  Fork the cookiecutter repo on GitHub.  Clone your fork locally:  bash    git clone git@github.com:your_name_here/cookiecutter.git  Install your local copy into a virtualenv.    Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:  bash    cd cookiecutter/    pip install -e .  Create a branch for local development:  bash    git checkout -b name-of-your-bugfix-or-feature  Now you can make your changes locally.  When you're done making changes, check that your changes pass the tests and lint check:  bash    pip install tox    tox  Ensure that your feature or commit is fully covered by tests. Check report after regular tox run.    You can also run coverage only report and get html report with statement by statement highlighting:  bash    make coverage  You report will be placed to htmlcov directory. Please do not include this directory to your commits.    By default this directory in our .gitignore file.  Commit your changes and push your branch to GitHub:  bash    git add .    git commit -m ""Your detailed description of your changes.""    git push origin name-of-your-bugfix-or-feature  Submit a pull request through the GitHub website.  Contributor Guidelines  Pull Request Guidelines  Before you submit a pull request, check that it meets these guidelines:  The pull request should include tests.  The pull request should be contained:    if it's too big consider splitting it into smaller pull requests.  If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add the feature to the list in README.md.  The pull request must pass all CI/CD jobs before being ready for review.  If one CI/CD job is failing for unrelated reasons you may want to create another PR to fix that first.  Coding Standards  PEP8  Functions over classes except in tests  Quotes via http://stackoverflow.com/a/56190/5549  Use double quotes around strings that are used for interpolation or that are natural language messages  Use single quotes for small symbol-like strings (but break the rules if the strings contain quotes)  Use triple double quotes for docstrings and raw string literals for regular expressions even if they aren't needed.  Example: python LIGHT_MESSAGES = {     'English': ""There are %(number_of_lights)s lights."",     'Pirate':  ""Arr! Thar be %(number_of_lights)s lights."" } def lights_message(language, number_of_lights):     """"""Return a language-appropriate string reporting the light count.""""""     return LIGHT_MESSAGES[language] % locals() def is_pirate(message):     """"""Return True if the given message sounds piratical.""""""     return re.search(r""(?i)(arr|avast|yohoho)!"", message) is not None  Testing with tox  tox uses pytest under the hood, hence it supports the same syntax for selecting tests.  For further information please consult the pytest usage docs.  To run a particular test class with tox:  bash tox -e py310 -- '-k TestFindHooks'  To run some tests with names matching a string expression:  bash tox -e py310 -- '-k generate'  Will run all tests matching ""generate"", test_generate_files for example.  To run just one method:  bash tox -e py310 -- '-k ""TestFindHooks and test_find_hook""'  To run all tests using various versions of Python, just run tox:  bash tox  This configuration file setup the pytest-cov plugin and it is an additional dependency. It generate a coverage report after the tests.  It is possible to test with specific versions of Python. To do this, the command is:  bash tox -e py37,py38  This will run py.test with the python3.7 and python3.8 interpreters.  Core Committer Guide  Vision and Scope  Core committers, use this section to:  Guide your instinct and decisions as a core committer  Limit the codebase from growing infinitely  Command-Line Accessible  Provides a command-line utility that creates projects from cookiecutters  Extremely easy to use without having to think too hard  Flexible for more complex use via optional arguments  API Accessible  Entirely function-based and stateless (Class-free by intentional design)  Usable in pieces for developers of template generation tools  Being Jinja2-specific  Sets a standard baseline for project template creators, facilitating reuse  Minimizes the learning curve for those who already use Flask or Django  Minimizes scope of Cookiecutter codebase  Extensible  Being extendable by people with different ideas for Jinja2-based project template tools.  Entirely function-based  Aim for statelessness  Lets anyone write more opinionated tools  Freedom for Cookiecutter users to build and extend.  No officially-maintained cookiecutter templates, only ones by individuals  Commercial project-friendly licensing, allowing for private cookiecutters and private Cookiecutter-based tools  Fast and Focused  Cookiecutter is designed to do one thing, and do that one thing very well.  Cover the use cases that the core committers need, and as little as possible beyond that :)  Generates project templates from the command-line or API, nothing more  Minimize internal line of code (LOC) count  Ultra-fast project generation for high performance downstream tools  Inclusive  Cross-platform and cross-version support are more important than features/functionality  Fixing Windows bugs even if it's a pain, to allow for use by more beginner coders  Stable  Aim for 100% test coverage and covering corner cases  No pull requests will be accepted that drop test coverage on any platform, including Windows  Conservative decisions patterned after CPython's conservative decisions with stability in mind  Stable APIs that tool builders can rely on  New features require a +1 from 3 core committers  VCS-Hosted Templates  Cookiecutter project templates are intentionally hosted VCS repos as-is.  They are easily forkable  It's easy for users to browse forks and files  They are searchable via standard Github/Bitbucket/other search interface  Minimizes the need for packaging-related cruft files  Easy to create a public project template and host it for free  Easy to collaborate  Process: Pull Requests  If a pull request is untriaged:  Look at the roadmap  Set it for the milestone where it makes the most sense  Add it to the roadmap  How to prioritize pull requests, from most to least important:  Fixes for broken tests. Broken means broken on any supported platform or Python version.  Extra tests to cover corner cases.  Minor edits to docs.  Bug fixes.  Major edits to docs.  Features.  Pull Requests Review Guidelines  Think carefully about the long-term implications of the change.   How will it affect existing projects that are dependent on this?   If this is complicated, do we really want to maintain it forever?  Take the time to get things right, PRs almost always require additional improvements to meet the bar for quality.   Be very strict about quality.  When you merge a pull request take care of closing/updating every related issue explaining how they were affected by those changes.   Also, remember to add the author to AUTHORS.md.  Process: Issues  If an issue is a bug that needs an urgent fix, mark it for the next patch release. Then either fix it or mark as please-help.  For other issues: encourage friendly discussion, moderate debate, offer your thoughts.  New features require a +1 from 2 other core committers (besides yourself).  Process: Roadmap  The roadmap located here  Due dates are flexible. Core committers can change them as needed. Note that GitHub sort on them is buggy.  How to number milestones:  Follow semantic versioning. Look at: http://semver.org  Milestone size:  If a milestone contains too much, move some to the next milestone.  Err on the side of more frequent patch releases.  Process: Your own code changes  All code changes, regardless of who does them, need to be reviewed and merged by someone else. This rule applies to all the core committers.  Exceptions:  Minor corrections and fixes to pull requests submitted by others.  While making a formal release, the release manager can make necessary, appropriate changes.  Small documentation changes that reinforce existing subject matter.   Most commonly being, but not limited to spelling and grammar corrections.  Responsibilities  Ensure cross-platform compatibility for every change that's accepted. Windows, macOS and Linux.  Create issues for any major changes and enhancements that you wish to make.   Discuss things transparently and get community feedback.  Don't add any classes to the codebase unless absolutely needed.   Err on the side of using functions.  Keep feature versions as small as possible, preferably one new feature per version.  Be welcoming to newcomers and encourage diverse new contributors from all backgrounds.   Look at Code of Conduct.  Becoming a Core Committer  Contributors may be given core commit privileges. Preference will be given to those with:  Past contributions to Cookiecutter and other open-source projects.    Contributions to Cookiecutter include both code (both accepted and pending) and friendly participation in the issue tracker.    Quantity and quality are considered.  A coding style that the other core committers find simple, minimal, and clean.  Access to resources for cross-platform development and testing.  Time to devote to the project regularly."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\cookiecutter.rst,cookiecutter.rst_chunk0,"cookiecutter package  Submodules  cookiecutter.cli module  cookiecutter.cli  cookiecutter.config module  cookiecutter.config  cookiecutter.environment module  cookiecutter.environment  cookiecutter.exceptions module  cookiecutter.exceptions  cookiecutter.extensions module  cookiecutter.extensions  cookiecutter.find module  cookiecutter.find  cookiecutter.generate module  cookiecutter.generate  cookiecutter.hooks module  cookiecutter.hooks  cookiecutter.log module  cookiecutter.log  cookiecutter.main module  cookiecutter.main  cookiecutter.prompt module  cookiecutter.prompt  cookiecutter.replay module  cookiecutter.replay  cookiecutter.repository module  cookiecutter.repository  cookiecutter.utils module  cookiecutter.utils  cookiecutter.vcs module  cookiecutter.vcs  cookiecutter.zipfile module  cookiecutter.zipfile  Module contents  cookiecutter"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\HISTORY.md,HISTORY.md_chunk0,"History  History is important, but our current roadmap can be found here  2.6.0 (2024-02-21)  Minor Changes  Support Python 3.12 (#1989) @ericof  Modifying Jinja2 start and end variable strings (#1997) @sacha-c  CI/CD and QA changes  Add isort as a pre-commit hook (#1988) @kurtmckee  Bump actions/setup-python from 4 to 5 (#2000) @dependabot  Bump actions/upload-artifact from 3 to 4 (#1999) @dependabot  Quick resolution of #2003 (#2004) @jensens  Support Python 3.12 (#1989) @ericof  [pre-commit.ci] pre-commit autoupdate (#1996) @pre-commit-ci  Quick resolution of #2003 (#2004) @jensens  Documentation updates  Support Python 3.12 (#1989) @ericof  Bugfixes  Fix regression #2009: Adding value to nested dicts broken (#2010) @jensens  Fixed errors caused by invalid config files. (#1995) @alanverresen  This release is made by wonderful contributors:  @alanverresen, @dependabot, @dependabot[bot], @ericof, @jensens, @kurtmckee, @pre-commit-ci, @pre-commit-ci[bot] and @sacha-c  2.5.0 (2023-11-21)  Minor Changes  Default values can be passed as a dict (#1924) @matveyvarg  Implement new style for nested templates config (#1981) @ericof  CI/CD and QA changes  Bump actions/checkout from 3 to 4 (#1953) @dependabot  [pre-commit.ci] pre-commit autoupdate (#1977) @pre-commit-ci  [pre-commit.ci] pre-commit autoupdate (#1957) @pre-commit-ci  Documentation updates  Add argument run to pipx command in README.md (#1964) @staeff  Fix tutorial2 generated HTML (#1971) @aantoin  Update README.md (#1967) @HarshRanaOC  Update README.md to fix broken link (#1952) @david-abn  Update README.md to include installation instructions (#1949) @david-abn  Update cookiecutter-plone-starter link in readme (#1965) @zahidkizmaz  Bugfixes  Fix FileExistsError when using a relative template path (#1968) @pkrueger-cariad  Fix recursive context overwrites (#1961) @padraic-padraic  This release is made by wonderful contributors:  @HarshRanaOC, @aantoin, @david-abn, @dependabot, @dependabot[bot], @ericof, @matveyvarg, @padraic-padraic, @pkrueger-cariad, @pre-commit-ci, @pre-commit-ci[bot], @staeff and @zahidkizmaz  2.4.0 (2023-09-29)  Minor Changes  Gracefully handle files with mixed lined endings (#1942) @EricHripko  Implement a pre_prompt hook that will run before prompts (#1950) @ericof  Documentation updates  Implement a pre_prompt hook that will run before prompts (#1950) @ericof  update main docstrings to include overwrite_if_exists and skip_if_file_exists (#1947) @david-abn  This release is made by wonderful contributors:  @EricHripko, @david-abn and @ericof  2.3.1 (2023-09-21)  Minor Changes  add checkout details to the context (fixes #1759) (#1923) @JonZeolla  CI/CD and QA changes  Update the black pre-commit hook URL and version (#1934) @kurtmckee  Use UTF-8 for file reading/writing (#1937) @rmartin16  Documentation updates  Add missing ""parent dir"" symbol in tutorial 2 (#1932) @tvoirand  Remove colons from exemplary prompt messages (#1912) @paduszyk  docs: add install instruction for Void Linux (#1917) @tranzystorek-io  Bugfixes  Fix nested templates in Git repository (#1922) @BTatlock  Fix prompt counter. (#1940) @ericof  Fix variables with null default not being required (#1919) (#1920) @limtis0  This release is made by wonderful contributors:  @BTatlock, @JonZeolla, @ericof, @kurtmckee, @limtis0, @paduszyk, @rmartin16, @tranzystorek-io and @tvoirand  2.3.0 (2023-08-03)  Minor Changes  Improve style of prompts using rich (#1901) @vemonet  CI/CD and QA changes  Bump paambaati/codeclimate-action from 4.0.0 to 5.0.0 (#1908) @dependabot  [pre-commit.ci] pre-commit autoupdate (#1907) @pre-commit-ci  Bugfixes  Fix replay (#1904) @vemonet  Support multichoice overwrite (#1903) @Meepit  This release is made by wonderful contributors:  @Meepit, @dependabot, @dependabot[bot], @ericof, @pre-commit-ci, @pre-commit-ci[bot] and @vemonet  2.2.3 (2023-07-11)  Changes  Minor Changes  Add support for adding human-readable labels for choices when defining multiple choices questions (#1898) @vemonet  Prompt with replay file (#1758) @w1ndblow  CI/CD and QA changes  Set cookiecutter/VERSION.txt as source of truth for version number (#1896) @ericof  [pre-commit.ci] pre-commit autoupdate (#1897) @pre-commit-ci  Bugfixes  Fix issue where the prompts dict was not passed for yes_no questions (#1895) @vemonet  Set cookiecutter/VERSION.txt as source of truth for version number (#1896) @ericof  This release is made by wonderful contributors:  @ericof, @pre-commit-ci, @pre-commit-ci[bot], @vemonet and @w1ndblow  2.2.2 (2023-07-10)  CI/CD and QA changes  Improve gitignore (#1889) @audreyfeldroy  Add warning for jinja2_time (#1890) @henryiii  This release is made by wonderful contributors:  @audreyfeldroy, @ericof and @henryiii  2.2.0 (2023-07-06)  Changes  Added timeout on request.get() for ensuring that if a recipient serve… (#1772) @openrefactory  Fixing Carriage Return Line Feed (CRLF) order in docs #1792 (#1793) @Lahiry  Reduce I/O (#1877) @kurtmckee  Remove a pre-commit hook special case (#1875) @kurtmckee  Remove universal bdist_wheel option; use ""python -m build"" (#1739) @mwtoews  Remove unused import from post-generate hook script example (#1795) @KAZYPinkSaurus  Standardize newlines for all platforms (#1870) @kurtmckee  feat: Add resolved template repository path as _repo_dir to the context (#1771) @tmeckel  Minor Changes  Added support for providing human-readable prompts to the different variables (#1881) @vemonet  Added: Boolean variable support in JSON (#1626) @liortct  Added: CLI option to keep project files on failure. (#1669) @MaciejPatro  Added: Support partially overwrite keys in nested dict (#1692) @cksac  Added: Templates inheritance (#1485) @simobasso  Code quality: Tests upgrade: Use pathlib for files read/write (#1718) @insspb  Inline jinja2-time extension code (#1779) @tranzystorek-io  Support Python 3.11 (#1850) @kurtmckee  Support nested config files (#1770) @dariocurr  preserves original options in _cookiecutter (#1874) @kjaymiller  CI/CD and QA changes  Add a Dependabot config to autoupdate GitHub workflow actions (#1851) @kurtmckee  Added: Readthedocs build config (#1707) @insspb  Bump actions/setup-python from 3 to 4 (#1854) @dependabot  Bump paambaati/codeclimate-action from 3.0.0 to 4.0.0 (#1853) @dependabot  CI/CD: Tox -> Nox: Added nox configuration (#1706) @insspb  CI/CD: Tox -> Nox: Github actions definition minimized + Sync nox and github actions (#1714) @insspb  CI/CD: Tox -> Nox: Makefile update: Removed watchmedo and sed dependency, tox replaced with nox (#1713) @insspb  CI/CD: Updated .pre-commit-config.yaml to use latest hooks versions (#1712) @insspb  Code quality: Core files: Added exception reason reraise when exception class changed (PEP 3134) (#1719) @insspb  Code quality: Tests upgrade: Use pathlib for files read/write (#1718) @insspb  Code quality: core files: Format replaced with f-strings (#1716) @insspb  Code quality: find.py refactored and type annotated (#1721) @insspb  Code quality: tests files: Simplify statements fixes (#1717) @insspb  Code quality: utils.make_sure_path_exists refactored and type annotated (#1722) @insspb  Fixed: recommonmark replaced with myst, as recommonmark is deprecated (#1709) @insspb  Pretty-format JSON files (#1864) @kurtmckee  Rename master to main so CI runs correctly on merge (#1852) @kurtmckee  Standardize EOF newlines (#1876) @kurtmckee  Update .gitignore and cite where it was copied from (#1879) @kurtmckee  Update base docs, remove tox (#1858) @ericof  Update pre-commit hook versions (#1849) @kurtmckee  Updated: Release drafter configuration (#1704) @insspb  Use tox (#1866) @kurtmckee  Verify an expected warning is raised (#1869) @kurtmckee  fixed failing lint ci action by updating repo of flake8 (#1838) @Tamronimus  Documentation updates  Add jinja env docs (#1872) @pamelafox  Documentation extension: Create a Cookiecutter From Scratch tutorial (#1592) @miro-jelaska  Easy PR! Fix typos and add minor doc updates (#1741) @Alex0Blackwell  Expand cli documentation relating to the no-input flag (#1543) (#1587) @jeremyswerdlow  Fix @audreyr to @audreyfeldroy github account rename (#1604) @ri0t  Fixed broken links to jinja docs (#1691) @insspb  Fixed minor typos in docs (#1753) @segunb  Fixed: Python code block in the replay documentation (#1715) @juhannc  Fixed: recommonmark replaced with myst, as recommonmark is deprecated (#1709) @insspb  Improve Docs Readability (#1690) @ryanrussell  Update base docs, remove tox (#1858) @ericof  Updated: Boolean Variables documentation and docstrings (#1705) @italomaia  docs: fix simple typo, shat -> that (#1749) @timgates42  fixing badge display problem (#1798) @Paulokim1  Bugfixes  Fixed the override not working with copy only dir #1650 (#1651) @zhongdai  Fixed: Removed mention of packages versions, to exclude dependabot warnings alerts (#1711) @insspb  cleanup files if panics during hooks - bugfix (#1760) @liortct  This release is made by wonderful contributors:  @Alex0Blackwell, @KAZYPinkSaurus, @Lahiry, @MaciejPatro, @Paulokim1, @Tamronimus, @cksac, @cookies-xor-cream, @dariocurr, @dependabot, @dependabot[bot], @ericof, @insspb, @italomaia, @jeremyswerdlow, @juhannc, @kjaymiller, @kurtmckee, @liortct, @miro-jelaska, @mwtoews, @openrefactory, @pamelafox, @ri0t, @ryanrussell, @segunb, @simobasso, @timgates42, @tmeckel, @tranzystorek-io, @vemonet and @zhongdai  2.1.1 (2022-06-01)  Documentation updates  Fix local extensions documentation (#1686) @alkatar21  Bugfixes  Sanitize Mercurial branch information before checkout. (#1689) @ericof  This release is made by wonderfull contributors:  @alkatar21, @ericof and @jensens  2.1.0 (2022-05-30)  Changes  Move contributors and backers to credits section (#1599) @doobrie  test_generate_file_verbose_template_syntax_error fixed (#1671) @MaciejPatro  Removed changes related to setuptools_scm (#1629) @ozer550  Feature/local extensions (#1240) @mwesterhof  CI/CD and QA changes  Check manifest: pre-commit, fixes, cleaning (#1683) @jensens  Follow PyPA guide to release package using GitHub Actions. (#1682) @ericof  Documentation updates  Fix typo in dict_variables.rst (#1680) @ericof  Documentation overhaul (#1677) @jensens  Fixed incorrect link on docs. (#1649) @luzfcb  Bugfixes  Restore accidentally deleted support for click 8.x (#1643) @jaklan  This release was made possible by our wonderful contributors:  @doobrie, @jensens, @ericof, @luzfcb  2.0.2 (2021-12-27)  Remark: This release never made it to official PyPI  Fix Python version number in cookiecutter --version and test on Python 3.10 (#1621) @ozer550  Removed changes related to setuptools_scm (#1629) @audreyfeldroy @ozer550  2.0.1 (2021-12-11)  Remark: This release never made it to official PyPI  Breaking Changes  Release preparation for 2.0.1rc1 (#1608) @audreyfeldroy  Replace poyo with pyyaml. (#1489) @dHannasch  Added: Path templates will be rendered when copy_without_render used (#839) @noirbizarre  Added: End of line detection and configuration. (#1407) @insspb  Remove support for python2.7 (#1386) @ssbarnea  Minor Changes  Adopt setuptools-scm packaging (#1577) @ssbarnea  Log the error message when git clone fails, not just the return code (#1505) @logworthy  allow jinja 3.0.0 (#1548) @wouterdb  Added uuid extension to be able to generate uuids (#1493) @jonaswre  Alert user if choice is invalid (#1496) @dHannasch  Replace poyo with pyyaml. (#1489) @dHannasch  update AUTHOR lead (#1532) @HosamAlmoghraby  Add Python 3.9 (#1478) @gliptak  Added: --list-installed cli option, listing already downloaded cookiecutter packages (#1096) @chrisbrake  Added: Jinja2 Environment extension on files generation stage (#1419) @insspb  Added: --replay-file cli option, for replay file distributing (#906) @Cadair  Added: _output_dir to cookiecutter context (#1034) @Casyfill  Added: CLI option to ignore hooks (#992) @rgreinho  Changed: Generated projects can use multiple type hooks at same time. (sh + py) (#974) @milonimrod  Added: Path templates will be rendered when copy_without_render used (#839) @noirbizarre  Added: End of line detection and configuration. (#1407) @insspb  Making code python 3 only: Remove python2 u' sign, fix some strings (#1402) @insspb  py3: remove futures, six and encoding (#1401) @insspb  Render variables starting with an underscore. (#1339) @smoothml  Tests refactoring: test_utils write issues fixed #1405 (#1406) @insspb  CI/CD and QA changes  enable branch coverage (#1542) @simobasso  Make release-drafter diff only between master releases (#1568) @SharpEdgeMarshall  ensure filesystem isolation during tests execution (#1564) @simobasso  add safety ci step (#1560) @simobasso  pre-commit: add bandit hook (#1559) @simobasso  Replace tmpdir in favour of tmp_path (#1545) @SharpEdgeMarshall  Fix linting in CI (#1546) @SharpEdgeMarshall  Coverage 100% (#1526) @SharpEdgeMarshall  Run coverage with matrix (#1521) @SharpEdgeMarshall  Lint rst files (#1443) @ssbarnea  Python3: Changed io.open to build-in open (PEP3116) (#1408) @insspb  Making code python 3 only: Remove python2 u' sign, fix some strings (#1402) @insspb  py3: remove futures, six and encoding (#1401) @insspb  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Tests refactoring: test_utils write issues fixed #1405 (#1406) @insspb  Added: Automatic PyPI deploy on tag creation (#1400) @insspb  Changed: Restored coverage reporter (#1399) @insspb  Documentation updates  Fix pull requests checklist reference (#1537) @glumia  Fix author name (#1544) @HosamAlmoghraby  Add missing contributors (#1535) @glumia  Update CONTRIBUTING.md (#1529) @glumia  Update LICENSE (#1519) @simobasso  docs: rewrite the conditional files / directories example description. (#1437) @lyz-code  Fix incorrect years in release history (#1473) @graue70  Add slugify in the default extensions list (#1470) @oncleben31  Renamed cookiecutter.package to API (#1442) @grrlic  Fixed wording detail (#1427) @steltenpower  Changed: CLI Commands documentation engine (#1418) @insspb  Added: Example for conditional files / directories in hooks (#1397) @xyb  Changed: README.md PyPI URLs changed to the modern PyPI last version (#1391) @brettcannon  Fixed: Comma in README.md (#1390) @Cy-dev-tex  Fixed: Replaced no longer maintained pipsi by pipx (#1395) @ndclt  Bugfixes  Add support for click 8.x (#1569) @cjolowicz  Force click<8.0.0 (#1562) @SharpEdgeMarshall  Remove direct dependency on markupsafe (#1549) @ssbarnea  fixes prompting private rendered dicts (#1504) @juhuebner  User's JSON parse error causes ugly Python exception #809 (#1468) @noone234  config: set default on missing default_context key (#1516) @simobasso  Fixed: Values encoding on Windows (#1414) @agateau  Fixed: Fail with gitolite repositories (#1144) @javiersanp  MANIFEST: Fix file name extensions (#1387) @sebix  Deprecations  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Removed support for Python 3.6 and PyPy (#1608) @audreyfeldroy  This release was made possible by our wonderful contributors:  @Cadair, @Casyfill, @Cy-dev-tex, @HosamAlmoghraby, @SharpEdgeMarshall, @agateau, @audreyfeldroy, @brettcannon, @chrisbrake, @cjolowicz, @dHannasch, @gliptak, @glumia, @graue70, @grrlic, @insspb, @javiersanp, @jonaswre, @jsoref, @Jthevos, @juhuebner, @logworthy, @lyz-code, @milonimrod, @ndclt, @noirbizarre, @noone234, @oncleben31, @ozer550, @rgreinho, @sebix, @Sahil-101, @simobasso, @smoothml, @ssbarnea, @steltenpower, @wouterdb, @xyb, Christopher Wolfe and Hosam Almoghraby ( RIAG Digital )  1.7.2 (2020-04-21)  Fixed: Jinja2&Six version limits causing build errors with ansible project @insspb (#1385)  1.7.1 (2020-04-21)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\HISTORY.md,HISTORY.md_chunk1,"Fix incorrect years in release history (#1473) @graue70  Add slugify in the default extensions list (#1470) @oncleben31  Renamed cookiecutter.package to API (#1442) @grrlic  Fixed wording detail (#1427) @steltenpower  Changed: CLI Commands documentation engine (#1418) @insspb  Added: Example for conditional files / directories in hooks (#1397) @xyb  Changed: README.md PyPI URLs changed to the modern PyPI last version (#1391) @brettcannon  Fixed: Comma in README.md (#1390) @Cy-dev-tex  Fixed: Replaced no longer maintained pipsi by pipx (#1395) @ndclt  Bugfixes  Add support for click 8.x (#1569) @cjolowicz  Force click<8.0.0 (#1562) @SharpEdgeMarshall  Remove direct dependency on markupsafe (#1549) @ssbarnea  fixes prompting private rendered dicts (#1504) @juhuebner  User's JSON parse error causes ugly Python exception #809 (#1468) @noone234  config: set default on missing default_context key (#1516) @simobasso  Fixed: Values encoding on Windows (#1414) @agateau  Fixed: Fail with gitolite repositories (#1144) @javiersanp  MANIFEST: Fix file name extensions (#1387) @sebix  Deprecations  Removed: Bumpversion, setup.py arguments. (#1404) @insspb  Removed support for Python 3.6 and PyPy (#1608) @audreyfeldroy  This release was made possible by our wonderful contributors:  @Cadair, @Casyfill, @Cy-dev-tex, @HosamAlmoghraby, @SharpEdgeMarshall, @agateau, @audreyfeldroy, @brettcannon, @chrisbrake, @cjolowicz, @dHannasch, @gliptak, @glumia, @graue70, @grrlic, @insspb, @javiersanp, @jonaswre, @jsoref, @Jthevos, @juhuebner, @logworthy, @lyz-code, @milonimrod, @ndclt, @noirbizarre, @noone234, @oncleben31, @ozer550, @rgreinho, @sebix, @Sahil-101, @simobasso, @smoothml, @ssbarnea, @steltenpower, @wouterdb, @xyb, Christopher Wolfe and Hosam Almoghraby ( RIAG Digital )  1.7.2 (2020-04-21)  Fixed: Jinja2&Six version limits causing build errors with ansible project @insspb (#1385)  1.7.1 (2020-04-21)  This release was focused on internal code and CI/CD changes. During this release all code was verified to match pep8, pep257 and other code-styling guides. Project CI/CD was significantly changed, Windows platform checks based on Appveyor engine was replaced by GitHub actions tests. Appveyor was removed. Also our CI/CD was extended with Mac builds, to verify project builds on Apple devices.  Important Changes:  Added: Added debug messages for get_user_config @ssbarnea (#1357)  Multiple templates per one repository feature added. @RomHartmann (#1224, #1063)  Update replay.py json.dump indent for easy viewing @nicain (#1293)  'future' library replaced with 'six' as a more lightweight python porting library @asottile (#941)  Added extension: Slugify template filter @ppanero (#1336)  Added command line option: --skip-if-file-exists, allow to skip the existing files when doing overwrite_if_exists. @chhsiao1981 (#1076)  Some packages versions limited to be compatible with python2.7 and python 3.5 @insspb (#1349)  Internal CI/CD and tests changes:  Coverage comment in future merge requests disabled @ssbarnea (#1279)  Fixed Python 3.8 travis tests and setup.py message @insspb (#1295, #1297)  Travis builds extended with Windows setup for all supported python versions @insspb (#1300, #1301)  Update .travis.yml to be compatible with latest travis cfg specs @luzfcb (#1346)  Added new test to improve tests coverage @amey589 (#1023)  Added missed coverage lines highlight to pytest-coverage report @insspb (#1352)  pytest-catchlog package removed from test_requirements, as now it is included in pytest @insspb (#1347)  Fixed cov-report tox invocation environment @insspb (#1350)  Added: Release drafter support and configuration to exclude changelog update work and focus on development @ssbarnea @insspb (#1356, #1362)  Added: CI/CD steps for Github actions to speedup CI/CD @insspb (#1360)  Removed: Appveyor CI/CD completely removed @insspb @ssbarnea @insspb (#1363, #1367)  Code style and docs changes:  Added black formatting verification on lint stage + project files reformatting @ssbarnea @insspb (#1368)  Added pep257 docstring for tests/* files @insspb (#1369, #1370, #1371, #1372, #1373, #1374, #1375, #1376, #1377, #1378, #1380, #1381)  Added pep257 docstring for tests/conftests.py @kishan (#1272, #1263)  Added pep257 docstring for tests/replay/conftest.py @kishan (#1270, #1268)  Added pep257 docstring for docs/init.py @kishan (#1273, #1265)  Added missing docstring headers to all files @croesnick (#1269, #1283)  Gitter links replaced by Slack in README @browniebroke (#1282)  flake8-docstrings tests added to CI/CD @ssbarnea (#1284)  Activated pydocstyle rule: D401 - First line should be in imperative mood @ssbarnea (#1285)  Activated pydocstyle rule: D200 - One-line docstring should fit on one line with quotes @ssbarnea (#1288)  Activated pydocstyle rule: D202 - No blank lines allowed after function docstring @ssbarnea (#1288)  Activated pydocstyle rule: D205 - 1 blank line required between summary line and description @ssbarnea (#1286, #1287)  Activated pydocstyle rule: ABS101 @ssbarnea (#1288)  Replaced click documentation links to point to version 7 @igorbasko01 (#1303)  Updated submodule link to latest version with documentation links fix @DanBoothDev (#1388)  Fixed links in main README file. @insspb (#1342)  Fix indentation of .cookiecutterrc in README.md @mhsekhavat (#1322)  Changed format of loggers invocation @insspb (#1307)  1.7.0 (2019-12-22) Old friend  Important Changes:  Drop support for EOL Python 3.4, thanks to @jamescurtin and @insspb (#1024)  Drop support for EOL Python 3.3, thanks to @hugovk (#1024)  Increase the minimum click version to 7.0, thanks to @rly and @luzfcb (#1168)  Other Changes:  PEP257 fixing docstrings in exceptions.py. Thanks to @MinchinWeb (#1237)  PEP257 fixing docstrings in replay.py. Thanks to @kishan (#1234)  PEP257 fixing docstrings in test_unzip.py. Thanks to @tonytheleg and @insspb (#1236, #1262)  Fixed tests sequence for appveyor, to exclude file not found bug. Thanks to @insspb (#1257)  Updates REAMDE.md with svg badge for appveyor. Thanks to @sobolevn (#1254)  Add missing {% endif %} to Choice Variables example. Thanks to @mattstibbs (#1249)  Core documentation converted to Markdown format thanks to @wagnernegrao, @insspb (#1216)  Tests update: use sys.executable when invoking python in python 3 only environment thanks to @vincentbernat (#1221)  Prevent click API v7.0 from showing choices when already shown, thanks to @rly and @luzfcb (#1168)  Test the codebase with python3.8 beta on tox and travis-ci (#1206), thanks to @mihrab34  Add a CODE_OF_CONDUCT.md file to the project, thanks to @andreagrandi (#1009)  Update docstrings in cookiecutter/main.py, cookiecutter/__init__.py, and cookiecutter/log.py to follow the PEP 257 style guide, thanks to @meahow (#998, #999, #1000)  Update docstrings in cookiecutter/utils.py to follow the PEP 257 style guide, thanks to @dornheimer(#1026)  Fix grammar in Choice Variables documentation, thanks to @jubrilissa (#1011)  Update installation docs with links to the Windows Subsystem and GNU utilities, thanks to @Nythiennzo for the PR and @BruceEckel for the review (#1016)  Upgrade flake8 to version 3.5.0, thanks to @cclauss (#1038)  Update tutorial with explanation for how cookiecutter finds the template file, thanks to @accraze(#1025)  Update CI config files to use TOXENV environment variable, thanks to @asottile (#1019)  Improve user documentation for writing hooks, thanks to @jonathansick (#1057)  Make sure to preserve the order of items in the generated cookiecutter context, thanks to @hackebrot (#1074)  Fixed DeprecationWarning for a regular expression on python 3.6, thanks to @reinout (#1124)  Document use of cookiecutter-template topic on GitHub, thanks to @ssbarnea (#1189)  Update README badge links, thanks to @luzfcb (#1207)  Update prompt.py to match pep257 guidelines, thanks to @jairideout (#1105)  Update link to Jinja2 extensions documentation, thanks to @dacog (#1193)  Require pip 9.0.0 or newer for tox environments, thanks to @hackebrot (#1215)  Use io.open contextmanager when reading hook files, thanks to @jcb91 (#1147)  Add more cookiecutter templates to the mix:  cookiecutter-python-cli by @xuanluong (#1003)  cookiecutter-docker-science by @takahi-i (#1040)  cookiecutter-flask-skeleton by @mjhea0 (#1052)  cookiecutter-awesome by @Pawamoy (#1051)  cookiecutter-flask-ask by @machinekoder (#1056)  cookiecutter-data-driven-journalism by @JAStark (#1020)  cookiecutter-tox-plugin by @obestwalter (#1103)  cookiecutter-django-dokku by @mashrikt (#1093)  1.6.0 (2017-10-15) Tim Tam  New Features:  Include template path or template URL in cookiecutter context under _template, thanks to @aroig (#774)  Add a URL abbreviation for GitLab template projects, thanks to @hackebrot (#963)  Add option to use templates from Zip files or Zip URLs, thanks to @freakboy3742 (#961)  Bug Fixes:  Fix an issue with missing default template abbreviations for when a user defined custom abbreviations, thanks to @noirbizarre for the issue report and @hackebrot for the fix (#966, #967)  Preserve existing output directory on project generation failure, thanks to @ionelmc for the report and @michaeljoseph for the fix (#629, #964)  Fix Python 3.x error handling for git operation failures, thanks to @jmcarp (#905)  Other Changes:  Fix broken link to Copy without Render docs, thanks to @coreysnyder04 (#912)  Improve debug log message for when a hook is not found, thanks to @raphigaziano (#160)  Fix module summary and expand_abbreviations() doc string as per pep257, thanks to @terryjbates (#772)  Update doc strings in cookiecutter/cli.py and cookiecutter/config.py according to pep257, thanks to @terryjbates (#922, #931)  Update doc string for is_copy_only_path() according to pep257, thanks to @mathagician and @terryjbates (#935, #949)  Update doc strings in cookiecutter/extensions.py according to pep257, thanks to @meahow (#996)  Fix miscellaneous issues with building docs, thanks to @stevepiercy (#889)  Re-implement Makefile and update several make rules, thanks to @hackebrot (#930)  Fix broken link to pytest docs, thanks to @eyalev for the issue report and @devstrat for the fix (#939, #940)  Add test_requirements.txt file for easier testing outside of tox, thanks to @ramnes (#945)  Improve wording in copy without render docs, thanks to @eyalev (#938)  Fix a number of typos, thanks to @delirious-lettuce (#968)  Improved extra context docs by noting that extra context keys must be present in the template\'s cookiecutter.json, thanks to @karantan for the report and fix (#863, #864)  Added more cookiecutter templates to the mix:  cookiecutter-kata-cpputest by @13coders (#901)  cookiecutter-kata-gtest by @13coders (#901)  cookiecutter-pyramid-talk-python-starter by @mikeckennedy (#915)  cookiecutter-android by @alexfu (#890)  cookiecutter-lux-python by @alexkey (#895)  cookiecutter-git by @tuxredux (#921)  cookiecutter-ansible-role-ci by @ferrarimarco (#903)  cookiecutter_dotfile by @bdcaf (#925)  painless-continuous-delivery by @painless-software         (#927)  cookiecutter-molecule by @retr0h (#954)  sublime-snippet-package-template by @agenoria (#956)  cookiecutter-conda-python by @conda (#969)  cookiecutter-flask-minimal by @candidtim (#977)  cookiecutter-pypackage-rust-cross-platform-publish by @mckaymatt (#957)  cookie-cookie by @tuxredux (#951)  cookiecutter-telegram-bot by @Ars2014 (#984)  python-project-template by @Kwpolska (#986)  wemake-django-template by @wemake-services (#990)  cookiecutter-raml by @genzj (#994)  cookiecutter-anyblok-project by @AnyBlok (#988)  cookiecutter-devenv by @greenguavalabs (#991)  1.5.1 (2017-02-04) Alfajor  New Features:  Major update to installation documentation, thanks to @stevepiercy (#880)  Bug Fixes:  Resolve an issue around default values for dict variables, thanks to @e-kolpakov for raising the issue and @hackebrot for the PR (#882, #884)  Other Changes:  Contributor documentation reST fixes, thanks to @stevepiercy (#878)  Added more cookiecutter templates to the mix:  widget-cookiecutter by @willingc (#781)  cookiecutter-django-foundation by @Parbhat (#804)  cookiecutter-tornado by @hkage (#807)  cookiecutter-django-ansible by @Ivaylo-Bachvarov(#816)  CICADA by @elenimijalis (#840)  cookiecutter-tf-module by @VDuda (#843)  cookiecutter-pyqt4 by @aeroaks (#847)  cookiecutter-golang by @mjhea0 and @lacion (#872, #873)  cookiecutter-elm, cookiecutter-java and cookiecutter-spring-boot by @m-x-k (#879)  1.5.0 (2016-12-18) Alfajor  The primary goal of this release was to add command-line support for passing extra context, address minor bugs and make a number of improvements.  New Features:  Inject extra context with command-line arguments, thanks to @msabramo and @michaeljoseph (#666).  Updated conda installation instructions to work with the new conda-forge distribution of Cookiecutter, thanks to @pydanny and especially @bollwyvl (#232, #705).  Refactor code responsible for interaction with version control systems and raise better error messages, thanks to @michaeljoseph (#778).  Add support for executing cookiecutter using python -m cookiecutter or from a checkout/zip file, thanks to @brettcannon (#788).  New CLI option --debug-file PATH to store a log file on disk. By default no log file is written. Entries for DEBUG level and     higher. Thanks to @hackebrot(#792).  Existing templates in a user\'s cookiecutters_dir (default is ~/.cookiecutters/) can now be referenced by directory name, thanks to @michaeljoseph (#825).  Add support for dict values in cookiecutter.json, thanks to @freakboy3742 and @hackebrot (#815, #858).  Add a jsonify filter to default jinja2 extensions that json.dumps a Python object into a string, thanks to @aroig (#791).  Bug Fixes:  Fix typo in the error logging text for when a hook did not exit successfully, thanks to @luzfcb    (#656)  Fix an issue around replay file names when cookiecutter is used with a relative path to a template, thanks to    @eliasdorneles for raising the issue and @hackebrot for the PR (#752, #753)  Ignore hook files with tilde-suffixes, thanks to @hackebrot (#768)  Fix a minor issue with the code that generates a name for a template, thanks to @hackebrot(#798)  Handle empty hook file or other OS errors, thanks to @christianmlong for raising this bug and @jcarbaugh and @hackebrot for the fix (#632, #729, #862)  Resolve an issue with custom extensions not being loaded for pre_gen_project and post_gen_project hooks, thanks to @cheungnj (#860)  Other Changes:  Remove external dependencies from tests, so that tests can be run w/o network connection, thanks to @hackebrot (#603)  Remove execute permissions on Python files, thanks to @mozillazg (#650)  Report code coverage info from AppVeyor build to codecov, thanks to @ewjoachim (#670)  Documented functions and methods lacking documentation, thanks to @pydanny (#673)  Documented __init__ methods for Environment objects, thanks to @pydanny (#677)  Updated whichcraft to 0.4.0, thanks to @pydanny.  Updated documentation link to Read the Docs, thanks to @natim (#687)  Moved cookiecutter templates and added category links, thanks to @willingc (#674)  Added Github Issue Template, thanks to @luzfcb (#700)  Added ssh repository examples, thanks to @pokoli (#702)  Fix links to the cookiecutter-data-science template and its documentation, thanks to @tephyr for the PR and @willingc for the review (#711, #714)  Update link to docs for Django\'s --template command line option, thanks to @purplediane (#754)  Create hook backup files during the tests as opposed to having them as static files in the repository, thanks to @hackebrot (#789)  Applied PEP 257 docstring conventions to:  environment.py, thanks to @terryjbates (#759)  find.py, thanks to @terryjbates (#761)  generate.py, thanks to @terryjbates (#764)  hooks.py, thanks to @terryjbates (#766)  repository.py, thanks to @terryjbates (#833)  vcs.py, thanks to @terryjbates (#831)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\HISTORY.md,HISTORY.md_chunk2,"Ignore hook files with tilde-suffixes, thanks to @hackebrot (#768)  Fix a minor issue with the code that generates a name for a template, thanks to @hackebrot(#798)  Handle empty hook file or other OS errors, thanks to @christianmlong for raising this bug and @jcarbaugh and @hackebrot for the fix (#632, #729, #862)  Resolve an issue with custom extensions not being loaded for pre_gen_project and post_gen_project hooks, thanks to @cheungnj (#860)  Other Changes:  Remove external dependencies from tests, so that tests can be run w/o network connection, thanks to @hackebrot (#603)  Remove execute permissions on Python files, thanks to @mozillazg (#650)  Report code coverage info from AppVeyor build to codecov, thanks to @ewjoachim (#670)  Documented functions and methods lacking documentation, thanks to @pydanny (#673)  Documented __init__ methods for Environment objects, thanks to @pydanny (#677)  Updated whichcraft to 0.4.0, thanks to @pydanny.  Updated documentation link to Read the Docs, thanks to @natim (#687)  Moved cookiecutter templates and added category links, thanks to @willingc (#674)  Added Github Issue Template, thanks to @luzfcb (#700)  Added ssh repository examples, thanks to @pokoli (#702)  Fix links to the cookiecutter-data-science template and its documentation, thanks to @tephyr for the PR and @willingc for the review (#711, #714)  Update link to docs for Django\'s --template command line option, thanks to @purplediane (#754)  Create hook backup files during the tests as opposed to having them as static files in the repository, thanks to @hackebrot (#789)  Applied PEP 257 docstring conventions to:  environment.py, thanks to @terryjbates (#759)  find.py, thanks to @terryjbates (#761)  generate.py, thanks to @terryjbates (#764)  hooks.py, thanks to @terryjbates (#766)  repository.py, thanks to @terryjbates (#833)  vcs.py, thanks to @terryjbates (#831)  Fix link to the Tryton cookiecutter, thanks to @cedk and @nicoe (#697, #698)  Added PyCon US 2016 sponsorship to README, thanks to @purplediane (#720)  Added a sprint contributor doc, thanks to @phoebebauer (#727)  Converted readthedocs links (.org -> .io), thanks to @adamchainz (#718)  Added Python 3.6 support, thanks to @suledev (#728)  Update occurrences of repo_name in documentation, thanks to @palmerev (#734)  Added case studies document, thanks to @pydanny (#735)  Added first steps cookiecutter creation tutorial, thanks to @BruceEckel (#736)  Reorganised tutorials and setup git submodule to external tutorial, thanks to @dot2dotseurat (#740)  Debian installation instructions, thanks to @ivanlyon (#738)  Usage documentation typo fix., thanks to @terryjbates (#739)  Updated documentation copyright date, thanks to @zzzirk (#747)  Add a make rule to update git submodules, thanks to @hackebrot (#746)  Split up advanced usage docs, thanks to @zzzirk (#749)  Documentation for the no_input option, thanks to @pokoli (#701)  Remove unnecessary shebangs from python files, thanks to @michaeljoseph (#763)  Refactor cookiecutter template identification, thanks to @michaeljoseph (#777)  Add a cli_runner test fixture to simplify CLI tests, thanks to @hackebrot (#790)  Add a check to ensure cookiecutter repositories have JSON context, thanks to @michaeljoseph(#782)  Rename the internal function that determines whether a file should be rendered, thanks to @audreyfeldroy for raising the issue and @hackebrotfor the PR (#741, #802)  Fix typo in docs, thanks to @mwarkentin (#828)  Fix broken link to Invoke docs, thanks to @B3QL (#820)  Add documentation to render_variable function in prompt.py, thanks to @pydanny (#678)  Fix python3.6 travis-ci and tox configuration, thanks to @luzfcb (#844)  Add missing encoding declarations to python files, thanks to @andytom (#852)  Disable poyo logging for tests, thanks to @hackebrot (#855)  Remove pycache directories in make clean-pyc, thanks to @hackebrot (#849)  Refactor hook system to only find the requested hook, thanks to @michaeljoseph (#834)  Add tests for custom extensions in pre_gen_project and post_gen_project hooks, thanks to @hackebrot (#856)  Make the build reproducible by avoiding nondeterministic keyword arguments, thanks to @lamby and @hackebrot (#800, #861)  Extend CLI help message and point users to the github project to engage with the community, thanks to @hackebrot (#859)  Added more cookiecutter templates to the mix:  cookiecutter-funkload-friendly by @tokibito (#657)  cookiecutter-reveal.js by @keimlink (#660)  cookiecutter-python-app by @mdklatt (#659)  morepath-cookiecutter by @href (#672)  hovercraft-slides by @jhermann (#665)  cookiecutter-es6-package by @ratson (#667)  cookiecutter-webpack by @hzdg (#668)  cookiecutter-django-herokuapp by @dulaccc (#374)  cookiecutter-django-aws-eb by @peterlauri (#626)  wagtail-starter-kit by @tkjone (#658)  cookiecutter-dpf-effect by @SpotlightKid (#663)  cookiecutter-dpf-audiotk by @SpotlightKid (#663)  cookiecutter-template by @eviweb (#664)  cookiecutter-angular2 by @matheuspoleza (#675)  cookiecutter-data-science by @pjbull (#680)  cc_django_ember_app by @nanuxbe (#686)  cc_project_app_drf by @nanuxbe (#686)  cc_project_app_full_with_hooks by @nanuxbe (#686)  beat-generator by @ruflin (#695)  cookiecutter-scala by @Plippe (#751)  cookiecutter-snakemake-analysis-pipeline by @xguse (#692)  cookiecutter-py3tkinter by @ivanlyon (#730)  pyramid-cookiecutter-alchemy by @stevepiercy (#745)  pyramid-cookiecutter-starter by @stevepiercy (#745)  pyramid-cookiecutter-zodb by @stevepiercy (#745)  substanced-cookiecutter by @stevepiercy (#745)  cookiecutter-simple-django-cn by @shenyushun (#765)  cookiecutter-pyqt5 by @mandeepbhutani (#797)  cookiecutter-xontrib by @laerus (#817)  cookiecutter-reproducible-science by @mkrapp (#826)  cc-automated-drf-template by @elenimijalis (#832)  1.4.0 (2016-03-20) Shortbread  The goal of this release is changing to a strict Jinja2 environment, paving the way to more awesome in the future, as well as adding support for Jinja2 extensions.  New Features:  Added support for Jinja2 extension support, thanks to @hackebrot (#617).  Now raises an error if Cookiecutter tries to render a template that contains an undefined variable. Makes generation more robust and secure (#586). Work done by @hackebrot (#111, #586, #592)  Uses strict Jinja2 env in prompt, thanks to @hackebrot (#598, #613)  Switched from pyyaml/ruamel.yaml libraries that were problematic across platforms to the pure Python poyo library, thanks to @hackebrot (#557, #569, #621)  User config values for cookiecutters_dir and replay_dir now support environment variable and user home expansion, thanks to   @nfarrar for the suggestion and @hackebrot for the PR (#640,#642)  Add jinja2-time as default extension for dates and times in templates via {% now 'utc' %},thanks to @hackebrot (#653)  Bug Fixes:  Provided way to define options that have no defaults, thanks to @johtso (#587, #588)  Make sure that replay.dump() and replay.load() use the correct user config, thanks to @hackebrot (#590, #594)  Added correct CA bundle for Git on Appveyor, thanks to @maiksensi (#599, #602)  Open HISTORY.rst with utf-8 encoding when reading the changelog, thanks to @0-wiz-0 for submitting the issue and @hackebrot for the fix (#638, #639)  Fix repository indicators for privaterepository urls, thanks to @habnabit for the fix (#595) and @hackebrot for the tests (#655)  Other Changes:  Set path before running tox, thanks to @maiksensi (#615, #620)  Removed xfail in test_cookiecutters, thanks to @hackebrot (#618)  Removed django-cms-plugin on account of 404 error, thanks to @mativs and @pydanny (#593)  Fixed docs/usage.rst, thanks to @macrotim (#604)  Update .gitignore to latest Python.gitignore and ignore PyCharm files, thanks to @audreyfeldroy  Use open context manager to read context_file in generate() function, thanks to @hackebrot (#607, #608)  Added documentation for choice variables, thanks to @maiksensi (#611)  Set up Scrutinizer to check code quality, thanks to @audreyfeldroy  Drop distutils support in setup.py, thanks to @hackebrot (#606, #609)  Change cookiecutter-pypackage-minimal link, thanks to @kragniz (#614)  Fix typo in one of the template\'s description, thanks to @ryanfreckleton (#643)  Fix broken link to _copy_without_render     in troubleshooting.rst, thanks to @ptim (#647)  Added more cookiecutter templates to the mix:  cookiecutter-pipproject by @wdm0006 (#624)  cookiecutter-flask-2 by @wdm0006 (#624)  cookiecutter-kotlin-gradle by @thomaslee (#622)  cookiecutter-tryton-fulfilio by @cedk (#631)  django-starter by @tkjone (#635)  django-docker-bootstrap by @legios89 (#636)  cookiecutter-mediawiki-extension by @JonasGroeger (#645)  cookiecutter-django-gulp by @valerymelou (#648)  1.3.0 (2015-11-10) Pumpkin Spice  The goal of this release is to extend the user config feature and to make hook execution more robust.  New Features:  Abort project generation if pre_gen_project or post_gen_project hook scripts fail, thanks to @eliasdorneles (#464, #549)  Extend user config capabilities with additional cli options --config-file and --default-config and environment variable   COOKIECUTTER_CONFIG, thanks to @jhermann, @pfmoore, and @hackebrot (#258, #424, #565)  Bug Fixes:  Fixed conditional dependencies for wheels in setup.py, thanks to @hackebrot (#557, #568)  Reverted skipif markers to use correct reasons (bug fixed in pytest), thanks to @hackebrot (#574)  Other Changes:  Improved path and documentation for rendering the Sphinx documentation, thanks to @eliasdorneles and @hackebrot (#562, #583)  Added additional help entrypoints, thanks to @michaeljoseph (#563, #492)  Added Two Scoops Academy to the README, thanks to @hackebrot (#576)  Now handling trailing slash on URL, thanks to @ramiroluz (#573, #546)  Support for testing x86 and x86-64 architectures on appveyor, thanks to @maiksensi (#567)  Made tests work without installing Cookiecutter, thanks to @vincentbernat (#550)  Encoded the result of the hook template to utf8, thanks to @ionelmc (#577. #578)  Added test for _run_hook_from_repo_dir, thanks to @hackebrot (#579, #580)  Implemented bumpversion, thanks to @hackebrot (#582)  Added more cookiecutter templates to the mix:  cookiecutter-octoprint-plugin by @foosel (#560)  wagtail-cookiecutter-foundation by @chrisdev, et al. (#566)  1.2.1 (2015-10-18) Zimtsterne  Zimtsterne are cinnamon star cookies.  New Feature:  Returns rendered project dir, thanks to @hackebrot (#553)  Bug Fixes:  Factor in choice variables (as introduced in 1.1.0) when using a user config or extra context, thanks to @ionelmc and @hackebrot (#536, #542).  Other Changes:  Enable py35 support on Travis by using Python 3.5 as base Python (@maiksensi / #540)  If a filename is empty, do not generate. Log instead (@iljabauer / #444)  Fix tests as per last changes in cookiecutter-pypackage, thanks to @eliasdorneles(#555).  Removed deprecated cookiecutter-pylibrary-minimal from the list, thanks to @ionelmc (#556)  Moved to using rualmel.yaml instead of PyYAML, except for Windows users on Python 2.7, thanks     to @pydanny (#557)  Why 1.2.1 instead of 1.2.0? There was a problem in the distribution that we pushed to PyPI. Since you can\'t replace previous files uploaded to PyPI, we deleted the files on PyPI and released 1.2.1.  1.1.0 (2015-09-26) Snickerdoodle  The goals of this release were copy without render and a few additional command-line options such as --overwrite-if-exists, ---replay, and output-dir.  Features:  Added copy without render feature, making it much easier for developers of Ansible, Salt Stack, and other recipe-based tools to work with Cookiecutter. Thanks to @osantana and @LucianU for their innovation, as well as @hackebrot for fixing the Windows problems (#132, #184, #425).  Added specify output directory, thanks to @tony and @hackebrot (#531, #452).  Abort template rendering if the project output directory already exists, thanks to @lgp171188 (#470, #471).  Add a flag to overwrite existing output directory, thanks to @lgp171188 for the implementation (#495) and @schacki, @ionelmc, @pydanny and @hackebrot for submitting issues and code reviews (#475, #493).  Remove test command in favor of tox, thanks to @hackebrot (#480).  Allow cookiecutter invocation, even without installing it, via python -m cookiecutter.cli, thanks to @vincentbernat and @hackebrot (#449, #487).  Improve the type detection handler for online and offline repositories, thanks to @charlax (#490).  Add replay feature, thanks to @hackebrot (#501).  Be more precise when raising an error for an invalid user config file, thanks to @vaab and @hackebrot (#378, #528).  Added official Python 3.5 support, thanks to @pydanny and @hackebrot (#522).  Added support for choice variables and switch to click style prompts, thanks to @hackebrot (#441, #455).  Other Changes:  Updated click requirement to \< 6.0, thanks to @pydanny (#473).  Added landscape.io flair, thanks to @michaeljoseph (#439).  Descriptions of PEP8 specifications and milestone management, thanks to @michaeljoseph (#440).  Added alternate installation options in the documentation, thanks to @pydanny (#117, #315).  The test of the which() function now tests against the date command, thanks to @vincentbernat (#446)  Ensure file handles in setup.py are closed using with statement, thanks to @svisser (#280).  Removed deprecated and fully extraneous compat.is_exe() function, thanks to @hackebrot (#485).  Disabled sudo in .travis, thanks to @hackebrot (#482).  Switched to shields.io for problematic badges, thanks to @pydanny (#491).  Added whichcraft and removed compat.which(), thanks to @pydanny (#511).  Changed to export tox environment variables to codecov, thanks to @maiksensi. (#508).  Moved to using click version command, thanks to @hackebrot (#489).  Don\'t use unicode_literals to please click, thanks to @vincentbernat (#503).  Remove warning for Python 2.6 from __init__.py, thanks to @hackebrot.  Removed compat.py module, thanks to @hackebrot.  Added future to requirements, thanks to @hackebrot.  Fixed problem where expanduser does not resolve \""\~\"" correctly on windows 10 using tox, thanks to @maiksensi. (#527)  Added more cookiecutter templates to the mix:  cookiecutter-beamer by @luismartingil (#307)  cookiecutter-pytest-plugin by @pytest-dev and         @hackebrot (#481)  cookiecutter-csharp-objc-binding by @SandyChapman (#460)  cookiecutter-flask-foundation by @JackStouffer (#457)  cookiecutter-tryton-fulfilio by @fulfilio (#465)  cookiecutter-tapioca by @vintasoftware (#496)  cookiecutter-sublime-text-3-plugin by @kkujawinski (#500)  cookiecutter-muffin by @drgarcia1986 (#494)  cookiecutter-django-rest by @agconti (#520)  cookiecutter-es6-boilerplate by @agconti (#521)  cookiecutter-tampermonkey by @christabor (#516)  cookiecutter-wagtail by @torchbox (#533)  1.0.0 (2015-03-13) Chocolate Chip  The goals of this release was to formally remove support for Python 2.6 and continue the move to using py.test.  Features:  Convert the unittest suite to py.test for the sake of comprehensibility, thanks to @hackebrot (#322, #332, #334, #336, #337, #338, #340, #341, #343, #345, #347, #351, #412, #413, #414).  Generate pytest coverage, thanks to @michaeljoseph (#326).  Documenting of Pull Request merging and HISTORY.rst maintenance, thanks to @michaeljoseph (#330).  Large expansions to the tutorials thanks to @hackebrot (#384)  Switch to using Click for command-line options, thanks to @michaeljoseph (#391, #393).  Added support for working with private repos, thanks to @marctc (#265).  Wheel configuration thanks to @michaeljoseph (#118).  Other Changes:  Formally removed support for 2.6, thanks to @pydanny (#201).  Moved to codecov for continuous integration test coverage and badges, thanks to @michaeljoseph (#71, #369).  Made JSON parsing errors easier to debug, thanks to @rsyring and @mark0978 (#355, #358, #388)."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\HISTORY.md,HISTORY.md_chunk3,"Removed compat.py module, thanks to @hackebrot.  Added future to requirements, thanks to @hackebrot.  Fixed problem where expanduser does not resolve \""\~\"" correctly on windows 10 using tox, thanks to @maiksensi. (#527)  Added more cookiecutter templates to the mix:  cookiecutter-beamer by @luismartingil (#307)  cookiecutter-pytest-plugin by @pytest-dev and         @hackebrot (#481)  cookiecutter-csharp-objc-binding by @SandyChapman (#460)  cookiecutter-flask-foundation by @JackStouffer (#457)  cookiecutter-tryton-fulfilio by @fulfilio (#465)  cookiecutter-tapioca by @vintasoftware (#496)  cookiecutter-sublime-text-3-plugin by @kkujawinski (#500)  cookiecutter-muffin by @drgarcia1986 (#494)  cookiecutter-django-rest by @agconti (#520)  cookiecutter-es6-boilerplate by @agconti (#521)  cookiecutter-tampermonkey by @christabor (#516)  cookiecutter-wagtail by @torchbox (#533)  1.0.0 (2015-03-13) Chocolate Chip  The goals of this release was to formally remove support for Python 2.6 and continue the move to using py.test.  Features:  Convert the unittest suite to py.test for the sake of comprehensibility, thanks to @hackebrot (#322, #332, #334, #336, #337, #338, #340, #341, #343, #345, #347, #351, #412, #413, #414).  Generate pytest coverage, thanks to @michaeljoseph (#326).  Documenting of Pull Request merging and HISTORY.rst maintenance, thanks to @michaeljoseph (#330).  Large expansions to the tutorials thanks to @hackebrot (#384)  Switch to using Click for command-line options, thanks to @michaeljoseph (#391, #393).  Added support for working with private repos, thanks to @marctc (#265).  Wheel configuration thanks to @michaeljoseph (#118).  Other Changes:  Formally removed support for 2.6, thanks to @pydanny (#201).  Moved to codecov for continuous integration test coverage and badges, thanks to @michaeljoseph (#71, #369).  Made JSON parsing errors easier to debug, thanks to @rsyring and @mark0978 (#355, #358, #388).  Updated to Jinja 2.7 or higher in order to control trailing new lines in templates, thanks to @sfermigier (#356).  Tweaked flake8 to ignore e731, thanks to @michaeljoseph (#390).  Fixed failing Windows tests and corrected AppVeyor badge link thanks to @msabramo (#403).  Added more Cookiecutters to the list:  cookiecutter-scala-spark by @jpzk  cookiecutter-atari2600 by @joeyjoejoejr  cookiecutter-bottle by @avelino  cookiecutter-latex-article by @Kreger51  cookiecutter-django-rest-framework by @jpadilla  cookiedozer by @hackebrot  0.9.0 (2015-01-13)  The goals of this release were to add the ability to Jinja2ify the cookiecutter.json default values, and formally launch support for Python 3.4.  Features:  Python 3.4 is now a first class citizen, thanks to everyone.  cookiecutter.json values are now rendered Jinja2 templates, thanks to \@bollwyvl (#291).  Move to py.test, thanks to @pfmoore (#319) and @ramiroluz (#310).  Add PendingDeprecation warning for users of Python 2.6, as support for it is gone in Python 2.7, thanks to @michaeljoseph (#201).  Bug Fixes:  Corrected typo in Makefile, thanks to @inglesp (#297).  Raise an exception when users don\'t have git or hg installed, thanks to @pydanny (#303).  Other changes:  Creation of gitter account for logged chat, thanks to @michaeljoseph.  Added ReadTheDocs badge, thanks to @michaeljoseph.  Added AppVeyor badge, thanks to @pydanny  Documentation and PyPI trove classifier updates, thanks to @thedrow (#323 and #324)  0.8.0 (2014-10-30)  The goal of this release was to allow for injection of extra context via the Cookiecutter API, and to fix minor bugs.  Features:  cookiecutter() now takes an optional extra_context parameter, thanks to @michaeljoseph, @fcurella, @aventurella,  @emonty, @schacki, @ryanolson, @pfmoore, @pydanny, @audreyfeldroy (#260).  Context is now injected into hooks, thanks to @michaeljoseph and @dinopetrone.  Moved all Python 2/3 compatibility code into cookiecutter.compat, making the eventual move to six easier, thanks to @michaeljoseph (#60, #102).  Added cookiecutterrc defined aliases for cookiecutters, thanks to @pfmoore (#246)  Added flake8 to tox to check for pep8 violations, thanks to @natim.  Bug Fixes:  Newlines at the end of files are no longer stripped, thanks to @treyhunner (#183).  Cloning prompt suppressed by respecting the no\_input flag, thanks to @trustrachel (#285)  With Python 3, input is no longer converted to bytes, thanks to @uranusjr (#98).  Other Changes:  Added more Cookiecutters to the list:  Python-iOS-template by @freakboy3742  Python-Android-template by @freakboy3742  cookiecutter-djangocms-plugin by @mishbahr  cookiecutter-pyvanguard by @robinandeer  0.7.2 (2014-08-05)  The goal of this release was to fix cross-platform compatibility, primarily Windows bugs that had crept in during the addition of new features. As of this release, Windows is a first-class citizen again, now complete with continuous integration.  Bug Fixes:  Fixed the contributing file so it displays nicely in Github, thanks to @pydanny.  Updates 2.6 requirements to include simplejson, thanks to @saxix.  Avoid unwanted extra spaces in string literal, thanks to @merwok.  Fix @unittest.skipIf error on Python 2.6.  Let sphinx parse :param: properly by inserting newlines #213, thanks to @mineo.  Fixed Windows test prompt failure by replacing stdin per @cjrh in #195.  Made rmtree remove readonly files, thanks to @pfmoore.  Now using tox to run tests on Appveyor, thanks to @pfmoore (#241).  Fixed tests that assumed the system encoding was utf-8, thanks to @pfmoore (#242, #244).  Added a tox ini file that uses py.test, thanks to @pfmoore (#245).  Other Changes:  @audreyfeldroy formally accepted position as BDFL of cookiecutter.  Elevated @pydanny, @michaeljoseph, and @pfmoore to core committer status.  Added Core Committer guide, by @audreyfeldroy.  Generated apidocs from make docs, by @audreyfeldroy.  Added contributing command to the makedocs function, by @pydanny.  Refactored contributing documentation, included adding core committer instructions, by @pydanny and @audreyfeldroy.  Do not convert input prompt to bytes, thanks to @uranusjr (#192).  Added troubleshooting info about Python 3.3 tests and tox.  Added documentation about command line arguments, thanks to @saxix.  Style cleanups.  Added environment variable to disable network tests for environments without networking, thanks to @vincentbernat.  Added Appveyor support to aid Windows integrations, thanks to @pydanny (#215).  CONTRIBUTING.rst is now generated via make contributing, thanks to @pydanny (#220).  Removed unnecessary endoing argument to json.load, thanks to @pfmoore (#234).  Now generating shell hooks dynamically for Unix/Windows portability, thanks to @pfmoore (#236).  Removed non-portable assumptions about directory structure, thanks to @pfmoore (#238).  Added a note on portability to the hooks documentation, thanks to @pfmoore (#239).  Replaced unicode_open with direct use of io.open, thanks to @pfmoore (#229).  Added more Cookiecutters to the list:  cookiecutter-kivy by @hackebrot  BoilerplatePP by @Paspartout  cookiecutter-pypackage-minimal by @borntyping  cookiecutter-ansible-role by @iknite  cookiecutter-pylibrary by @ionelmc  cookiecutter-pylibrary-minimal by @ionelmc  0.7.1 (2014-04-26)  Bug fixes:  Use the current Python interpreter to run Python hooks, thanks to @coderanger.  Include tests and documentation in source distribution, thanks to @vincentbernat.  Fix various warnings and missing things in the docs (#129, #130), thanks to @nedbat.  Add command line option to get version (#89), thanks to @davedash and @cyberj.  Other changes:  Add more Cookiecutters to the list:  cookiecutter-avr by @solarnz  cookiecutter-tumblr-theme by @relekang  cookiecutter-django-paas by @pbacterio  0.7.0 (2013-11-09)  This is a release with significant improvements and changes. Please read through this list before you upgrade.  New features:  Support for --checkout argument, thanks to @foobacca.  Support for pre-generate and post-generate hooks, thanks to @raphigaziano. Hooks are Python or shell scripts that run before and/or after your project is generated.  Support for absolute paths to cookiecutters, thanks to @krallin.  Support for Mercurial version control system, thanks to @pokoli.  When a cookiecutter contains invalid Jinja2 syntax, you get a better message that shows the location of the TemplateSyntaxError. Thanks to @benjixx.  Can now prompt the user to enter values during generation from a local cookiecutter, thanks to @ThomasChiroux. This is now always the default behavior. Prompts can also be suppressed with --no-input.  Your cloned cookiecutters are stored by default in your ~/.cookiecutters/ directory (or Windows equivalent). The location is configurable. (This is a major change from the pre-0.7.0 behavior, where cloned cookiecutters were deleted at the end of project generation.) Thanks @raphigaziano.  User config in a \~/.cookiecutterrc file, thanks to @raphigaziano. Configurable settings are cookiecutters_dir and default_context.  File permissions are now preserved during project generation, thanks to @benjixx.  Bug fixes:  Unicode issues with prompts and answers are fixed, thanks to @s-m-i-t-a.  The test suite now runs on Windows, which was a major effort. Thanks to @pydanny, who collaborated on this with me.  Other changes:  Quite a bit of refactoring and API changes.  Lots of documentation improvements. Thanks @sloria, @alex, @pydanny, @freakboy3742, @es128, @rolo.  Better naming and organization of test suite.  A CookiecutterCleanSystemTestCase to use for unit tests affected by the user\'s config and cookiecutters directory.  Improvements to the project\'s Makefile.  Improvements to tests. Thanks @gperetin, @s-m-i-t-a.  Removal of subprocess32 dependency. Now using non-context manager version of subprocess.Popen for Python 2 compatibility.  Removal of cookiecutter\'s cleanup module.  A bit of setup.py cleanup, thanks to @oubiga.  Now depends on binaryornot 0.2.0.  0.6.4 (2013-08-21)  Windows support officially added.  Fix TemplateNotFound Exception on Windows (#37).  0.6.3 (2013-08-20)  Fix copying of binary files in nested paths (#41), thanks to @sloria.  0.6.2 (2013-08-19)  Depend on Jinja2>=2.4 instead of Jinja2==2.7.  Fix errors on attempt to render binary files. Copy them over from the project template without rendering.  Fix Python 2.6/2.7 UnicodeDecodeError when values containing Unicode chars are in cookiecutter.json.  Set encoding in Python 3 unicode_open() to always be utf-8.  0.6.1 (2013-08-12)  Improved project template finding. Now looks for the occurrence of {{,cookiecutter, and }} in a directory name.  Fix help message for input_dir arg at command prompt.  Minor edge cases found and corrected, as a result of improved test coverage.  0.6.0 (2013-08-08)  Config is now in a single cookiecutter.json instead of in json/.  When you create a project from a git repo template, Cookiecutter prompts you to enter custom values for the fields defined in cookiecutter.json.  0.5 (2013-07-28)  Friendlier, more simplified command line usage:  bash     # Create project from the cookiecutter-pypackage/ template     $ cookiecutter cookiecutter-pypackage/     # Create project from the cookiecutter-pypackage.git repo template     $ cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage.git  Can now use Cookiecutter from Python as a package:  ```python     from cookiecutter.main import cookiecutter  ```  Internal refactor to remove any code that changes the working     directory.  0.4 (2013-07-22)  Only takes in one argument now: the input directory. The output directory is generated by rendering the name of the input directory.  Output directory cannot be the same as input directory.  0.3 (2013-07-17)  Takes in command line args for the input and output directories.  0.2.1 (2013-07-17)  Minor cleanup.  0.2 (2013-07-17)  Bumped to ""Development Status :: 3 - Alpha"".  Works with any type of text file.  Directory names and filenames can be templated.  0.1.0 (2013-07-11)  First release on PyPI."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\index.rst,index.rst_chunk0,"Cookiecutter: Better Project Templates  Cookiecutter creates projects from cookiecutters (project templates), e.g. Python package projects from Python package templates.  Basics  README overview installation usage cli_options tutorials/index advanced/index troubleshooting  API Reference  cookiecutter  Project Info  CONTRIBUTING AUTHORS HISTORY case_studies CODE_OF_CONDUCT  Index  genindex  modindex"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\installation.rst,installation.rst_chunk0,"Installation  Prerequisites  Python interpreter  Adjust your path  Packaging tools  Python interpreter  Install Python for your operating system. On Windows and macOS this is usually necessary. Most Linux distributions come with Python pre-installed. Consult the official Python documentation for details.  You can install the Python binaries from python.org. Alternatively on macOS, you can use the homebrew package manager.  brew install python3  Adjust your path  Ensure that your bin folder is on your path for your platform. Typically ~/.local/ for UNIX and macOS, or %APPDATA%\Python on Windows. (See the Python documentation for site.USER_BASE for full details.)  UNIX and macOS  For bash shells, add the following to your .bash_profile (adjust for other shells):  # Add ~/.local/ to PATH  export PATH=$HOME/.local/bin:$PATH  Remember to load changes with source ~/.bash_profile or open a new shell session.  Windows  Ensure the directory where cookiecutter will be installed is in your environment's Path in order to make it possible to invoke it from a command prompt. To do so, search for ""Environment Variables"" on your computer (on Windows 10, it is under System Properties --> Advanced) and add that directory to the Path environment variable, using the GUI to edit path segments.  Example segments should look like %APPDATA%\Python\Python3x\Scripts, where you have your version of Python instead of Python3x.  You may need to restart your command prompt session to load the environment variables.  See Configuring Python (on Windows) for full details.  Unix on Windows  You may also install Windows Subsystem for Linux or GNU utilities for Win32 to use Unix commands on Windows.  Packaging tools  See the Python Packaging Authority's (PyPA) documentation Requirements for Installing Packages for full details.  Install cookiecutter  At the command line:  python3 -m pip install --user cookiecutter  Or, if you do not have pip:  easy_install --user cookiecutter  Though, pip is recommended, easy_install is deprecated.  Or, if you are using conda, first add conda-forge to your channels:  conda config --add channels conda-forge  Once the conda-forge channel has been enabled, cookiecutter can be installed with:  conda install cookiecutter  Alternate installations  Homebrew (Mac OS X only):  brew install cookiecutter  Void Linux:  xbps-install cookiecutter  Pipx (Linux, OSX and Windows):  pipx install cookiecutter  Upgrading  from 0.6.4 to 0.7.0 or greater  First, read HISTORY in detail. There are a lot of major changes. The big ones are:  Cookiecutter no longer deletes the cloned repo after generating a project.  Cloned repos are saved into ~/.cookiecutters/.  You can optionally create a ~/.cookiecutterrc config file.  Or with pip:  python3 -m pip install --upgrade cookiecutter  Upgrade Cookiecutter either with easy_install (deprecated):  easy_install --upgrade cookiecutter  Then you should be good to go."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\overview.rst,overview.rst_chunk0,"Overview  Cookiecutter takes a template provided as a directory structure with template-files. Templates can be located in the filesystem, as a ZIP-file or on a VCS-Server (Git/Hg) like GitHub.  It reads a settings file and prompts the user interactively whether or not to change the settings.  Then it takes both and generates an output directory structure from it.  Additionally the template can provide code (Python or shell-script) to be executed before and after generation (pre-gen- and post-gen-hooks).  Input  This is a directory structure for a simple cookiecutter:  You must have:  A cookiecutter.json file.  A {{ cookiecutter.project_name }}/ directory, where project_name is defined in your cookiecutter.json.  Beyond that, you can have whatever files/directories you want.  See https://github.com/audreyfeldroy/cookiecutter-pypackage for a real-world example of this.  Output  This is what will be generated locally, in your current directory:"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\README.md,README.md_chunk0,../README.md
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\troubleshooting.rst,troubleshooting.rst_chunk0,"Troubleshooting  I created a cookiecutter, but it doesn't work, and I can't figure out why  Try upgrading to Cookiecutter 0.8.0, which prints better error messages and has fixes for several common bugs.  I'm having trouble generating Jinja templates from Jinja templates  Make sure you escape things properly, like this:  Or this:  Or this:  See https://jinja.palletsprojects.com/en/latest/templates/#escaping for more info.  You can also use the _copy_without_render key in your cookiecutter.json file to escape entire files and directories.  Other common issues  TODO: add a bunch of common new user issues here.  This document is incomplete. If you have knowledge that could help other users, adding a section or filing an issue with details would be greatly appreciated."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\usage.rst,usage.rst_chunk0,"Usage  Grab a Cookiecutter template  First, clone a Cookiecutter project template:  Make your changes  Modify the variables defined in cookiecutter.json.  Open up the skeleton project. If you need to change it around a bit, do so.  You probably also want to create a repo, name it differently, and push it as your own new Cookiecutter project template, for handy future use.  Generate your project  Then generate your project from the project template:  The only argument is the input directory. (The output directory is generated by rendering that, and it can't be the same as the input directory.)  Note  see command_line_options for extra command line arguments  Try it out!  Works directly with git and hg (mercurial) repos too  To create a project from the cookiecutter-pypackage.git repo template:  Cookiecutter knows abbreviations for Github (gh), Bitbucket (bb), and GitLab (gl) projects, but you can also give it the full URL to any repository:  You will be prompted to enter a bunch of project config values. (These are defined in the project's cookiecutter.json.)  Then, Cookiecutter will generate a project from the template, using the values that you entered. It will be placed in your current directory.  And if you want to specify a branch you can do that with:  Works with private repos  If you want to work with repos that are not hosted in github or bitbucket you can indicate explicitly the type of repo that you want to use prepending hg+ or git+ to repo url:  In addition, one can provide a path to the cookiecutter stored on a local server:  Works with Zip files  You can also distribute cookiecutter templates as Zip files. To use a Zip file template, point cookiecutter at a Zip file on your local machine:  Or, if the Zip file is online:  If the template has already been downloaded, or a template with the same name has already been downloaded, you will be prompted to delete the existing template before proceeding.  The Zip file contents should be the same as a git/hg repository for a template -that is, the zipfile should unpack into a top level directory that contains the name of the template. The name of the zipfile doesn't have to match the name of the template - for example, you can label a zipfile with a version number, but omit the version number from the directory inside the Zip file.  If you want to see an example Zipfile, find any Cookiecutter repository on Github and download that repository as a zip file - Github repository downloads are in a valid format for Cookiecutter.  Password-protected Zip files  If your repository Zip file is password protected, Cookiecutter will prompt you for that password whenever the template is used.  Alternatively, if you want to use a password-protected Zip file in an automated environment, you can export the COOKIECUTTER_REPO_PASSWORD environment variable; the value of that environment variable will be used whenever a password is required.  Keeping your cookiecutters organized  As of the Cookiecutter 0.7.0 release:  Whenever you generate a project with a cookiecutter, the resulting project is output to your current directory.  Your cloned cookiecutters are stored by default in your ~/.cookiecutters/ directory (or Windows equivalent). The location is configurable: see advanced/user_config for details.  Pre-0.7.0, this is how it worked:  Whenever you generate a project with a cookiecutter, the resulting project is output to your current directory.  Cloned cookiecutters were not saved locally."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\__init__.py,__init__.py_chunk0,"""""""Main package for docs."""""""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\boolean_variables.rst,boolean_variables.rst_chunk0,"Boolean Variables  2.2.0  Boolean variables are used for answering True/False questions.  Basic Usage  Boolean variables are regular key / value pairs, but with the value being True/False.  For example, if you provide the following boolean variable in your cookiecutter.json:  you will get the following user input when running Cookiecutter:  User input will be parsed by ~cookiecutter.prompt.read_user_yes_no. The following values are considered as valid user input:  True values: ""1"", ""true"", ""t"", ""yes"", ""y"", ""on""  False values: ""0"", ""false"", ""f"", ""no"", ""n"", ""off""  The above run_as_docker boolean variable creates cookiecutter.run_as_docker, which can be used like this:  Cookiecutter is using Jinja2's if conditional expression <https://jinja.palletsprojects .com/en/latest/templates/#if> to determine the correct run_as_docker.  Input Validation  If a non valid value is inserted to a boolean field, the following error will be printed:  run_as_docker [True]: docker  Error: docker is not a valid boolean"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\calling_from_python.rst,calling_from_python.rst_chunk0,"Calling Cookiecutter Functions From Python  You can use Cookiecutter from Python:  from cookiecutter.main import cookiecutter  # Create project from the cookiecutter-pypackage/ template  cookiecutter('cookiecutter-pypackage/')  # Create project from the cookiecutter-pypackage.git repo template  cookiecutter('https://github.com/audreyfeldroy/cookiecutter-pypackage.git')  This is useful if, for example, you're writing a web framework and need to provide developers with a tool similar to django-admin.py startproject or npm init.  See the API Reference <apiref> for more details."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\choice_variables.rst,choice_variables.rst_chunk0,"Choice Variables  New in Cookiecutter 1.1  Choice variables provide different choices when creating a project. Depending on a user's choice the template renders things differently.  Basic Usage  Choice variables are regular key / value pairs, but with the value being a list of strings.  For example, if you provide the following choice variable in your cookiecutter.json:  ""license"": [""MIT"", ""BSD-3"", ""GNU GPL v3.0"", ""Apache Software License 2.0""]  you'd get the following choices when running Cookiecutter:  Depending on an user's choice, a different license is rendered by Cookiecutter.  The above license choice variable creates cookiecutter.license, which can be used like this:  Cookiecutter is using Jinja2's if conditional expression to determine the correct license.  The created choice variable is still a regular Cookiecutter variable and can be used like this:  Overwriting Default Choice Values  Choice Variables are overwritable using a user-config file.  For example, a choice variable can be created in cookiecutter.json by using a list as value:  ""license"": [""MIT"", ""BSD-3"", ""GNU GPL v3.0"", ""Apache Software License 2.0""]  By default, the first entry in the values list serves as default value in the prompt.  Setting the default license agreement to Apache Software License 2.0 can be done using:  default_context:  license: ""Apache Software License 2.0""  in the user-config file.  The resulting prompt changes and looks like:  Note  As you can see the order of the options changed from 1 - MIT to 1 - Apache Software License 2.0. Cookiecutter takes the first value in the list as the default."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\copy_without_render.rst,copy_without_render.rst_chunk0,"Copy without Render  New in Cookiecutter 1.1  To avoid rendering directories and files of a cookiecutter, the _copy_without_render key can be used in the cookiecutter.json. The value of this key accepts a list of Unix shell-style wildcards:  ""project_slug"": ""sample"",  ""_copy_without_render"": [  ""*.html"",  ""*not_rendered_dir"",  ""rendered_dir/not_rendered_file.ini""  Note: Only the content of the files will be copied without being rendered. The paths are subject to rendering. This allows you to write:  ""project_slug"": ""sample"",  ""_copy_without_render"": [  ""{{cookiecutter.repo_name}}/templates/*.html"",  In this example, {{cookiecutter.repo_name}} will be rendered as expected but the html file content will be copied without rendering."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\dict_variables.rst,dict_variables.rst_chunk0,"Dictionary Variables  New in Cookiecutter 1.5  Dictionary variables provide a way to define deep structured information when rendering a template.  Basic Usage  Dictionary variables are, as the name suggests, dictionaries of key-value pairs. The dictionary values can, themselves, be other dictionaries and lists - the data structure can be as deep as you need.  For example, you could provide the following dictionary variable in your cookiecutter.json:  ""project_slug"": ""new_project"",  ""file_types"": {  ""png"": {  ""name"": ""Portable Network Graphic"",  ""library"": ""libpng"",  ""apps"": [  ""GIMP""  },  ""bmp"": {  ""name"": ""Bitmap"",  ""library"": ""libbmp"",  ""apps"": [  ""Paint"",  ""GIMP""  The above file_types dictionary variable creates cookiecutter.file_types, which can be used like this:  Cookiecutter is using Jinja2's for expression to iterate over the items in the dictionary."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\directories.rst,directories.rst_chunk0,"Organizing cookiecutters in directories  New in Cookiecutter 1.7  Cookiecutter introduces the ability to organize several templates in one repository or zip file, separating them by directories. This allows using symlinks for general files. Here's an example repository demonstrating this feature:  To activate one of templates within a subdirectory, use the --directory option:  cookiecutter https://github.com/user/repo-name.git --directory=""directory1-name"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\hooks.rst,hooks.rst_chunk0,"Hooks  Cookiecutter hooks are scripts executed at specific stages during the project generation process. They are either Python or shell scripts, facilitating automated tasks like data validation, pre-processing, and post-processing. These hooks are instrumental in customizing the generated project structure and executing initial setup tasks.  Types of Hooks  Hook Execution Timing Working Directory Template Variables Version pre_prompt Before any question is rendered. A copy of the repository directory No 2.4.0 pre_gen_project After questions, before template process. Root of the generated project Yes 0.7.0 post_gen_project After the project generation. Root of the generated project Yes 0.7.0  Creating Hooks  Hooks are added to the hooks/ folder of your template. Both Python and Shell scripts are supported.  Python Hooks Structure:  Shell Scripts Structure:  Python scripts are recommended for cross-platform compatibility. However, shell scripts or .bat files can be used for platform-specific templates.  Hook Execution  Hooks should be robust and handle errors gracefully. If a hook exits with a nonzero status, the project generation halts, and the generated directory is cleaned.  Working Directory:  pre_prompt: Scripts run in the root directory of a copy of the repository directory. That allows the rewrite of cookiecutter.json to your own needs.  pre_gen_project and post_gen_project: Scripts run in the root directory of the generated project, simplifying the process of locating generated files using relative paths.  Template Variables:  The pre_gen_project and post_gen_project hooks support Jinja template rendering, similar to project templates. For instance:  module_name = '{{ cookiecutter.module_name }}'  Examples  Pre-Prompt Sanity Check:  A pre_prompt hook, like the one below in hooks/pre_prompt.py, ensures prerequisites, such as Docker, are installed before prompting the user.  import sys  import subprocess  def is_docker_installed() -> bool:  try:  subprocess.run([""docker"", ""--version""], capture_output=True, check=True)  return True  except Exception:  return False  if __name__ == ""__main__"":  if not is_docker_installed():  print(""ERROR: Docker is not installed."")  sys.exit(1)  Validating Template Variables:  A pre_gen_project hook can validate template variables. The following script checks if the provided module name is valid.  import re  import sys  MODULE_REGEX = r'^[_a-zA-Z][_a-zA-Z0-9]+$'  module_name = '{{ cookiecutter.module_name }}'  if not re.match(MODULE_REGEX, module_name):  print(f'ERROR: {module_name} is not a valid Python module name!')  sys.exit(1)  Conditional File/Directory Removal:  A post_gen_project hook can conditionally control files and directories. The example below removes unnecessary files based on the selected packaging option.  import os  REMOVE_PATHS = [  '{% if cookiecutter.packaging != ""pip"" %}requirements.txt{% endif %}',  '{% if cookiecutter.packaging != ""poetry"" %}poetry.lock{% endif %}',  for path in REMOVE_PATHS:  path = path.strip()  if path and os.path.exists(path):  os.unlink(path) if os.path.isfile(path) else os.rmdir(path)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\human_readable_prompts.rst,human_readable_prompts.rst_chunk0,"Human readable prompts  You can add human-readable prompts that will be shown to the user for each variable using the __prompts__ key. For multiple choices questions you can also provide labels for each option.  See the following cookiecutter config as example:  ""package_name"": ""my-package"",  ""module_name"": ""{{ cookiecutter.package_name.replace('-', '_') }}"",  ""package_name_stylized"": ""{{ cookiecutter.module_name.replace('_', ' ').capitalize() }}"",  ""short_description"": ""A nice python package"",  ""github_username"": ""your-org-or-username"",  ""full_name"": ""Firstname Lastname"",  ""email"": ""email@example.com"",  ""init_git"": true,  ""linting"": [""ruff"", ""flake8"", ""none""],  ""__prompts__"": {  ""package_name"": ""Select your package name"",  ""module_name"": ""Select your module name"",  ""package_name_stylized"": ""Stylized package name"",  ""short_description"": ""Short description"",  ""github_username"": ""GitHub username or organization"",  ""full_name"": ""Author full name"",  ""email"": ""Author email"",  ""command_line_interface"": ""Add CLI"",  ""init_git"": ""Initialize a git repository"",  ""linting"": {  ""__prompt__"": ""Which linting tool do you want to use?"",  ""ruff"": ""Ruff"",  ""flake8"": ""Flake8"",  ""none"": ""No linting tool"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\index.rst,index.rst_chunk0,"Advanced Usage  Various advanced topics regarding cookiecutter usage.  hooks user_config calling_from_python injecting_context suppressing_prompts templates_in_context private_variables copy_without_render replay choice_variables boolean_variables dict_variables templates template_extensions directories jinja_env new_line_characters local_extensions nested_config_files human_readable_prompts"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\injecting_context.rst,injecting_context.rst_chunk0,"Injecting Extra Context  You can specify an extra_context dictionary that will override values from cookiecutter.json or .cookiecutterrc:  cookiecutter(  'cookiecutter-pypackage/',  extra_context={'project_name': 'TheGreatest'},  This works as command-line parameters as well:  cookiecutter --no-input cookiecutter-pypackage/ project_name=TheGreatest  You will also need to add these keys to the cookiecutter.json or .cookiecutterrc.  Example: Injecting a Timestamp  If you have cookiecutter.json that has the following keys:  ""timestamp"": ""{{ cookiecutter.timestamp }}""  This Python script will dynamically inject a timestamp value as the project is generated:  from cookiecutter.main import cookiecutter  from datetime import datetime  cookiecutter(  'cookiecutter-django',  extra_context={'timestamp': datetime.utcnow().isoformat()}  How this works:  The script uses datetime to get the current UTC time in ISO format.  To generate the project, cookiecutter() is called, passing the timestamp in as context via the extra_context` dict."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\jinja_env.rst,jinja_env.rst_chunk0,"Customizing the Jinja2 environment  The special template variable _jinja2_env_vars can be used to customize the [Jinja2 environment](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Environment).  This example shows how to control whitespace with lstrip_blocks and trim_blocks:  ""project_slug"": ""sample"",  ""_jinja2_env_vars"": {""lstrip_blocks"": true, ""trim_blocks"": true}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\local_extensions.rst,local_extensions.rst_chunk0,"Local Extensions  New in Cookiecutter 2.1  A template may extend the Cookiecutter environment with local extensions. These can be part of the template itself, providing it with more sophisticated custom tags and filters.  To do so, a template author must specify the required extensions in cookiecutter.json as follows:  ""project_slug"": ""Foobar"",  ""year"": ""{% now 'utc', '%Y' %}"",  ""_extensions"": [""local_extensions.FoobarExtension""]  This example uses a simple module local_extensions.py which exists in the template root, containing the following (for instance):  from jinja2.ext import Extension  class FoobarExtension(Extension):  def __init__(self, environment):  super(FoobarExtension, self).__init__(environment)  environment.filters['foobar'] = lambda v: v * 2  This will register the foobar filter for the template.  For many cases, this will be unnecessarily complicated. It's likely that we'd only want to register a single function as a filter. For this, we can use the simple_filter decorator:  ""project_slug"": ""Foobar"",  ""year"": ""{% now 'utc', '%Y' %}"",  ""_extensions"": [""local_extensions.simplefilterextension""]  from cookiecutter.utils import simple_filter  @simple_filter  def simplefilterextension(v):  return v * 2  This snippet will achieve the exact same result as the previous one.  For complex use cases, a python module local_extensions (a folder with an __init__.py) can also be created in the template root. Here, for example, a module main.py would have to export all extensions with from .main import FoobarExtension, simplefilterextension or from .main import * in the __init__.py."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\nested_config_files.rst,nested_config_files.rst_chunk0,"Nested configuration files  New in Cookiecutter 2.5.0  If you wish to create a hierarchy of templates and use cookiecutter to choose among them, you need just to specify the key templates in the main configuration file to reach the other ones.  Let's imagine to have the following structure:  It is possible to specify in the main cookiecutter.json how to reach the other config files as follows:  ""templates"": {  ""project-1"": {  ""path"": ""./project-1"",  ""title"": ""Project 1"",  ""description"": ""A cookiecutter template for a project""  },  ""package"": {  ""path"": ""./package"",  ""title"": ""Package"",  ""description"": ""A cookiecutter template for a package""  Then, when cookiecutter is launched in the main directory it will ask to choose among the possible templates:  Once a template is chosen, for example 1, it will continue to ask the info required by cookiecutter.json in the project-1 folder, such as project-slug  Old Format  New in Cookiecutter 2.2.0  In the main cookiecutter.json add a template key with the following format:  ""template"": [  ""Project 1 (./project-1)"",  ""Project 2 (./project-2)""  Then, when cookiecutter is launched in the main directory it will ask to choose among the possible templates:  Once a template is chosen, for example 1, it will continue to ask the info required by cookiecutter.json in the project-1 folder, such as project-slug"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\new_line_characters.rst,new_line_characters.rst_chunk0,"Working with line-ends special symbols LF/CRLF  New in Cookiecutter 2.0  Note  Before version 2.0 Cookiecutter silently used system line end character. LF for POSIX and CRLF for Windows. Since version 2.0 this behaviour changed and now can be forced at template level.  By default Cookiecutter checks every file at render stage and uses the same line end as in source. This allow template developers to have both types of files in the same template. Developers should correctly configure their .gitattributes file to avoid line-end character overwrite by git.  The special template variable _new_lines enforces a specific line ending. Acceptable variables: '\r\n' for CRLF and '\n' for POSIX.  Here is example how to force line endings to CRLF on any deployment:  ""project_slug"": ""sample"",  ""_new_lines"": ""\r\n"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\private_variables.rst,private_variables.rst_chunk0,"Private Variables  Cookiecutter allows the definition private variables by prepending an underscore to the variable name. The user will not be required to fill those variables in. These can either be not rendered, by using a prepending underscore, or rendered, prepending a double underscore. For example, the cookiecutter.json:  ""project_name"": ""Really cool project"",  ""_not_rendered"": ""{{ cookiecutter.project_name|lower }}"",  ""__rendered"": ""{{ cookiecutter.project_name|lower }}""  Will be rendered as:  ""project_name"": ""Really cool project"",  ""_not_rendered"": ""{{ cookiecutter.project_name|lower }}"",  ""__rendered"": ""really cool project""  The user will only be asked for project_name.  Non-rendered private variables can be used for defining constants. An example of where you may wish to use private rendered variables is creating a Python package repository and want to enforce naming consistency. To ensure the repository and package name are based on the project name, you could create a cookiecutter.json such as:  ""project_name"": ""Project Name"",  ""__project_slug"": ""{{ cookiecutter.project_name|lower|replace(' ', '-') }}"",  ""__package_name"": ""{{ cookiecutter.project_name|lower|replace(' ', '_') }}"",  Which could create a structure like this:  The README.md can then have a plain English project title."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\replay.rst,replay.rst_chunk0,"Replay Project Generation  New in Cookiecutter 1.1  On invocation Cookiecutter dumps a json file to ~/.cookiecutter_replay/ which enables you to replay later on.  In other words, it persists your input for a template and fetches it when you run the same template again.  Example for a replay file (which was created via cookiecutter gh:hackebrot/cookiedozer):  ""cookiecutter"": {  ""app_class_name"": ""FooBarApp"",  ""app_title"": ""Foo Bar"",  ""email"": ""raphael@example.com"",  ""full_name"": ""Raphael Pierzina"",  ""github_username"": ""hackebrot"",  ""kivy_version"": ""1.8.0"",  ""project_slug"": ""foobar"",  ""short_description"": ""A sleek slideshow app that supports swipe gestures."",  ""version"": ""0.1.0"",  ""year"": ""2015""  To fetch this context data without being prompted on the command line you can use either of the following methods.  Pass the according option on the CLI:  cookiecutter --replay gh:hackebrot/cookiedozer  Or use the Python API:  from cookiecutter.main import cookiecutter  cookiecutter('gh:hackebrot/cookiedozer', replay=True)  This feature comes in handy if, for instance, you want to create a new project from an updated template.  Custom replay file  New in Cookiecutter 2.0  To specify a custom filename, you can use the --replay-file option:  cookiecutter --replay-file ./cookiedozer.json gh:hackebrot/cookiedozer  This may be useful to run the same replay file over several machines, in tests or when a user of the template reports a problem."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\suppressing_prompts.rst,suppressing_prompts.rst_chunk0,"Suppressing Command-Line Prompts  To suppress the prompts asking for input, use no_input.  Note: this option will force a refresh of cached resources.  Basic Example: Using the Defaults  Cookiecutter will pick a default value if used with no_input:  from cookiecutter.main import cookiecutter  cookiecutter(  'cookiecutter-django',  no_input=True,  In this case it will be using the default defined in cookiecutter.json or .cookiecutterrc.  Note  values from cookiecutter.json will be overridden by values from .cookiecutterrc  Advanced Example: Defaults + Extra Context  If you combine an extra_context dict with the no_input argument, you can programmatically create the project with a set list of context parameters and without any command line prompts:  cookiecutter('cookiecutter-pypackage/',  no_input=True,  extra_context={'project_name': 'TheGreatest'})  See also injecting-extra-content and the API Reference <apiref> for more details."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\templates.rst,templates.rst_chunk0,"Templates inheritance (2.2+)  New in Cookiecutter 2.2+  Sometimes you need to extend a base template with a different configuration to avoid nested blocks.  Cookiecutter introduces the ability to use common templates using the power of jinja: extends, include and super.  Here's an example repository:  every file in the templates directory will become referable inside the project itself, and the path should be relative from the templates folder like :  see more on https://jinja.palletsprojects.com/en/2.11.x/templates/"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\templates_in_context.rst,templates_in_context.rst_chunk0,"Templates in Context Values  The values (but not the keys!) of cookiecutter.json are also Jinja2 templates. Values from user prompts are added to the context immediately, such that one context value can be derived from previous values. This approach can potentially save your user a lot of keystrokes by providing more sensible defaults.  Basic Example: Templates in Context  Python packages show some patterns for their naming conventions:  a human-readable project name  a lowercase, dashed repository name  an importable, dash-less package name  Here is a cookiecutter.json with templated values for this pattern:  ""project_name"": ""My New Project"",  ""project_slug"": ""{{ cookiecutter.project_name|lower|replace(' ', '-') }}"",  ""pkg_name"": ""{{ cookiecutter.project_slug|replace('-', '') }}""  If the user takes the defaults, or uses no_input, the templated values will be:  my-new-project  mynewproject  Or, if the user gives Yet Another New Project, the values will be:  yet-another-new-project  yetanothernewproject"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\template_extensions.rst,template_extensions.rst_chunk0,"Template Extensions  New in Cookiecutter 1.4  A template may extend the Cookiecutter environment with custom Jinja2 extensions. It can add extra filters, tests, globals or even extend the parser.  To do so, a template author must specify the required extensions in cookiecutter.json as follows:  ""project_slug"": ""Foobar"",  ""year"": ""{% now 'utc', '%Y' %}"",  ""_extensions"": [""jinja2_time.TimeExtension""]  On invocation Cookiecutter tries to import the extensions and add them to its environment respectively.  In the above example, Cookiecutter provides the additional tag now, after installing the jinja2_time.TimeExtension and enabling it in cookiecutter.json.  Please note that Cookiecutter will not install any dependencies on its own! As a user you need to make sure you have all the extensions installed, before running Cookiecutter on a template that requires custom Jinja2 extensions.  By default Cookiecutter includes the following extensions:  cookiecutter.extensions.JsonifyExtension  cookiecutter.extensions.RandomStringExtension  cookiecutter.extensions.SlugifyExtension  cookiecutter.extensions.TimeExtension  cookiecutter.extensions.UUIDExtension  Warning  The above is just an example to demonstrate how this is used. There is no need to require jinja2_time.TimeExtension, since its functionality is included by default (by cookiecutter.extensions.TimeExtension) without needing an extra install.  Jsonify extension  The cookiecutter.extensions.JsonifyExtension extension provides a jsonify filter in templates that converts a Python object to JSON:  Would output:  {""a"": true}  It supports an optional indent param, the default value is 4:  Would output:  ""a"": true,  ""foo"": ""bar""  Random string extension  New in Cookiecutter 1.7  The cookiecutter.extensions.RandomStringExtension extension provides a random_ascii_string method in templates that generates a random fixed-length string, optionally with punctuation.  Generate a random n-size character string. Example for n=12:  Outputs:  The second argument controls if punctuation and special characters !""#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ should be present in the result:  Outputs:  Slugify extension  The cookiecutter.extensions.SlugifyExtension extension provides a slugify filter in templates that converts string into its dashed (""slugified"") version:  Would output:  It is different from a mere replace of spaces since it also treats some special characters differently such as ' in the example above. The function accepts all arguments that can be passed to the slugify function of python-slugify. For example to change the output from it-s-a-random-version to it_s_a_random_version, the separator parameter would be passed: slugify(separator='_')`.  UUID4 extension  New in Cookiecutter 1.x  The cookiecutter.extensions.UUIDExtension extension provides a uuid4() method in templates that generates a uuid4.  Generate a uuid4 string:  Outputs:"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\advanced\user_config.rst,user_config.rst_chunk0,"User Config  New in Cookiecutter 0.7  If you use Cookiecutter a lot, you'll find it useful to have a user config file. By default Cookiecutter tries to retrieve settings from a .cookiecutterrc file in your home directory.  New in Cookiecutter 1.3  You can also specify a config file on the command line via --config-file.  cookiecutter --config-file /home/audreyr/my-custom-config.yaml cookiecutter-pypackage  Or you can set the COOKIECUTTER_CONFIG environment variable:  export COOKIECUTTER_CONFIG=/home/audreyr/my-custom-config.yaml  If you wish to stick to the built-in config and not load any user config file at all, use the CLI option --default-config instead. Preventing Cookiecutter from loading user settings is crucial for writing integration tests in an isolated environment.  Example user config:  default_context:  full_name: ""Audrey Roy""  email: ""audreyr@example.com""  github_username: ""audreyr""  cookiecutters_dir: ""/home/audreyr/my-custom-cookiecutters-dir/""  replay_dir: ""/home/audreyr/my-custom-replay-dir/""  abbreviations:  pp: https://github.com/audreyfeldroy/cookiecutter-pypackage.git  gh: https://github.com/{0}.git  bb: https://bitbucket.org/{0}  Possible settings are:  A list of key/value pairs that you want injected as context whenever you generate a project with Cookiecutter. These values are treated like the defaults in cookiecutter.json, upon generation of any project.  Directory where your cookiecutters are cloned to when you use Cookiecutter with a repo argument.  Directory where Cookiecutter dumps context data to, which you can fetch later on when using the replay feature <replay-feature>.  A list of abbreviations for cookiecutters. Abbreviations can be simple aliases for a repo name, or can be used as a prefix, in the form abbr:suffix. Any suffix will be inserted into the expansion in place of the text {0}, using standard Python string formatting. With the above aliases, you could use the cookiecutter-pypackage template simply by saying cookiecutter pp, or cookiecutter gh:audreyr/cookiecutter-pypackage. The gh (GitHub), bb (Bitbucket), and gl (Gitlab) abbreviations shown above are actually built in, and can be used without defining them yourself.  Read also: injecting-extra-content"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\tutorials\index.rst,index.rst_chunk0,"Tutorials  Tutorials by @audreyfeldroy  tutorial1 tutorial2  External Links  Learn the Basics of Cookiecutter by Creating a Cookiecutter - first steps tutorial with example template by @BruceEckel  Project Templates Made Easy by @pydanny  Cookiedozer Tutorials by @hackebrot  Part 1: Create your own Cookiecutter template Part 2: Extending our Cookiecutter template Part 3: Wrapping up our Cookiecutter template"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\tutorials\tutorial1.rst,tutorial1.rst_chunk0,"Getting to Know Cookiecutter  Note  Before you begin, please install Cookiecutter 0.7.0 or higher. Instructions are in ../installation.  Cookiecutter is a tool for creating projects from cookiecutters (project templates).  What exactly does this mean? Read on!  Case Study: cookiecutter-pypackage  cookiecutter-pypackage is a cookiecutter template that creates the starter boilerplate for a Python package.  Note  There are several variations of it, but for this tutorial we'll use the original version at https://github.com/audreyfeldroy/cookiecutter-pypackage/.  Step 1: Generate a Python Package Project  Open your shell and cd into the directory where you'd like to create a starter Python package project.  At the command line, run the cookiecutter command, passing in the link to cookiecutter-pypackage's HTTPS clone URL like this:  $ cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage.git  Local Cloning of Project Template  First, cookiecutter-pypackage gets cloned to ~/.cookiecutters/ (or equivalent on Windows). Cookiecutter does this for you, so sit back and wait.  Local Generation of Project  When cloning is complete, you will be prompted to enter a bunch of values, such as full_name, email, and project_name. Either enter your info, or simply press return/enter to accept the default values.  This info will be used to fill in the blanks for your project. For example, your name and the year will be placed into the LICENSE file.  Step 2: Explore What Got Generated  In your current directory, you should see that a project got generated:  $ ls  boilerplate  Looking inside the boilerplate/ (or directory corresponding to your project_slug) directory, you should see something like this:  $ ls boilerplate/  AUTHORS.rst      MANIFEST.in      docs             tox.ini  CONTRIBUTING.rst Makefile         requirements.txt  HISTORY.rst      README.rst       setup.py  LICENSE          boilerplate      tests  That's your new project!  If you open the AUTHORS.rst file, you should see something like this:  =======  Credits  =======  Development Lead  ----------------  Audrey Roy <audreyr@gmail.com>  Contributors  ------------  None yet. Why not be the first?  Notice how it was auto-populated with your (or my) name and email.  Also take note of the fact that you are looking at a ReStructuredText file. Cookiecutter can generate a project with text files of any type.  Great, you just generated a skeleton Python package. How did that work?  Step 3: Observe How It Was Generated  Let's take a look at cookiecutter-pypackage together. Open https://github.com/audreyfeldroy/cookiecutter-pypackage in a new browser window.  {{ cookiecutter.project_slug }}  Find the directory called {{ cookiecutter.project_slug }}. Click on it. Observe the files inside of it. You should see that this directory and its contents corresponds to the project that you just generated.  This happens in find.py, where the find_template() method looks for the first jinja-like directory name that starts with cookiecutter.  AUTHORS.rst  Look at the raw version of {{ cookiecutter.project_slug }}/AUTHORS.rst, at https://raw.github.com/audreyfeldroy/cookiecutter-pypackage/master/%7B%7Bcookiecutter.project_slug%7D%7D/AUTHORS.rst.  Observe how it corresponds to the AUTHORS.rst file that you generated.  cookiecutter.json  Now navigate back up to cookiecutter-pypackage/ and look at the cookiecutter.json file.  You should see JSON that corresponds to the prompts and default values shown earlier during project generation:  ""full_name"": ""Audrey Roy Greenfeld"",  ""email"": ""aroy@alum.mit.edu"",  ""github_username"": ""audreyr"",  ""project_name"": ""Python Boilerplate"",  ""project_slug"": ""{{ cookiecutter.project_name.lower().replace(' ', '_') }}"",  ""project_short_description"": ""Python Boilerplate contains all the boilerplate you need to create a Python package."",  ""pypi_username"": ""{{ cookiecutter.github_username }}"",  ""version"": ""0.1.0"",  ""use_pytest"": ""n"",  ""use_pypi_deployment_with_travis"": ""y"",  ""create_author_file"": ""y"",  ""open_source_license"": [""MIT"", ""BSD"", ""ISCL"", ""Apache Software License 2.0"", ""Not open source""]  Questions?  If anything needs better explanation, please take a moment to file an issue at https://github.com/audreyfeldroy/cookiecutter/issues with what could be improved about this tutorial.  Summary  You have learned how to use Cookiecutter to generate your first project from a cookiecutter project template.  In tutorial 2 (tutorial2), you'll see how to create cookiecutters of your own, from scratch."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\docs\tutorials\tutorial2.rst,tutorial2.rst_chunk0,"Create a Cookiecutter From Scratch  In this tutorial, we are creating cookiecutter-website-simple, a cookiecutter for generating simple, bare-bones websites.  Step 1: Name Your Cookiecutter  Create the directory for your cookiecutter and cd into it:  $ mkdir cookiecutter-website-simple  $ cd cookiecutter-website-simple/  Step 2: Create cookiecutter.json  cookiecutter.json is a JSON file that contains fields which can be referenced in the cookiecutter template. For each, default value is defined and user will be prompted for input during cookiecutter execution. Only mandatory field is project_slug and it should comply with package naming conventions defined in PEP8 Naming Conventions .  ""project_name"": ""Cookiecutter Website Simple"",  ""project_slug"": ""{{ cookiecutter.project_name.lower().replace(' ', '_') }}"",  ""author"": ""Anonymous""  Step 3: Create project_slug Directory  Create a directory called {{ cookiecutter.project_slug }}.  This value will be replaced with the repo name of projects that you generate from this cookiecutter.  Step 4: Create index.html  Inside of {{ cookiecutter.project_slug }}, create index.html with following content:  <!doctype html>  <html>  <head>  <meta charset=""utf-8"">  <title>{{ cookiecutter.project_name }}</title>  </head>  <body>  <h1>{{ cookiecutter.project_name }}</h1>  <p>by {{ cookiecutter.author }}</p>  </body>  </html>  Step 5: Pack cookiecutter into ZIP  There are many ways to run Cookiecutter templates, and they are described in details in Usage chapter. In this tutorial we are going to ZIP cookiecutter and then run it for testing.  By running following command cookiecutter.zip will get generated which can be used to run cookiecutter. Script will generate cookiecutter.zip ZIP file and echo full path to the file.  $ (SOURCE_DIR=$(basename $PWD) ZIP=cookiecutter.zip && # Set variables  pushd .. && # Set parent directory as working directory  zip -r $ZIP $SOURCE_DIR --exclude $SOURCE_DIR/$ZIP --quiet && # ZIP cookiecutter  mv $ZIP $SOURCE_DIR/$ZIP && # Move ZIP to original directory  popd && # Restore original work directory  echo  ""Cookiecutter full path: $PWD/$ZIP"")  Step 6: Run cookiecutter  Set your work directory to whatever directory you would like to run cookiecutter at. Use cookiecutter full path and run the following command:  $ cookiecutter <replace with Cookiecutter full path>  You can expect similar output:  $ cookiecutter /Users/admin/cookiecutter-website-simple/cookiecutter.zip  project_name [Cookiecutter Website Simple]: Test web  project_slug [test_web]:  author [Anonymous]: Cookiecutter Developer  Resulting directory should be inside your work directory with a name that matches project_slug you defined. Inside that directory there should be index.html with generated source:  <!doctype html>  <html>  <head>  <meta charset=""utf-8"">  <title>Test web</title>  </head>  <body>  <h1>Test web</h1>  <p>by Cookiecutter Developer</p>  </body>  </html>"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\conftest.py,conftest.py_chunk0,"""""""pytest fixtures which are globally available throughout the suite.""""""  import os import shutil from pathlib import Path  import pytest from typing_extensions import TypedDict  from cookiecutter import utils from cookiecutter.config import DEFAULT_CONFIG  USER_CONFIG = """""" cookiecutters_dir: '{cookiecutters_dir}' replay_dir: '{replay_dir}' """"""   @pytest.fixture(autouse=True) def isolated_filesystem(monkeypatch, tmp_path) -> None:     """"""Ensure filesystem isolation, set the user home to a tmp_path.""""""     root_path = tmp_path.joinpath(""home"")     root_path.mkdir()     cookiecutters_dir = root_path.joinpath("".cookiecutters/"")     replay_dir = root_path.joinpath("".cookiecutter_replay/"")     monkeypatch.setitem(DEFAULT_CONFIG, 'cookiecutters_dir', str(cookiecutters_dir))     monkeypatch.setitem(DEFAULT_CONFIG, 'replay_dir', str(replay_dir))      monkeypatch.setenv(""HOME"", str(root_path))     monkeypatch.setenv(""USERPROFILE"", str(root_path))   def backup_dir(original_dir, backup_dir) -> bool:     """"""Generate backup directory based on original directory.""""""     # If the default original_dir is pre-existing, move it to a temp location     if not os.path.isdir(original_dir):         return False      # Remove existing stale backups before backing up.     if os.path.isdir(backup_dir):         utils.rmtree(backup_dir)      shutil.copytree(original_dir, backup_dir)     return True   def restore_backup_dir(original_dir, backup_dir, original_dir_found) -> None:     """"""Restore default contents.""""""     original_dir_is_dir = os.path.isdir(original_dir)     if original_dir_found:         # Delete original_dir if a backup exists         if original_dir_is_dir and os.path.isdir(backup_dir):             utils.rmtree(original_dir)     else:         # Delete the created original_dir.         # There's no backup because it never existed         if original_dir_is_dir:             utils.rmtree(original_dir)      # Restore the user's default original_dir contents     if os.path.isdir(backup_dir):         shutil.copytree(backup_dir, original_dir)     if os.path.isdir(original_dir):         utils.rmtree(backup_dir)   @pytest.fixture(scope='function') def clean_system(request) -> None:     """"""Fixture. Simulates a clean system with no configured or cloned cookiecutters.      It runs code which can be regarded as setup code as known from a unittest     TestCase. Additionally it defines a local function referring to values     which have been stored to local variables in the setup such as the location     of the cookiecutters on disk. This function is registered as a teardown     hook with `request.addfinalizer` at the very end of the fixture. Pytest     runs the named hook as soon as the fixture is out of scope, when the test     finished to put it another way.      During setup:      * Back up the `~/.cookiecutterrc` config file to `~/.cookiecutterrc.backup`     * Back up the `~/.cookiecutters/` dir to `~/.cookiecutters.backup/`     * Back up the `~/.cookiecutter_replay/` dir to       `~/.cookiecutter_replay.backup/`     * Starts off a test case with no pre-existing `~/.cookiecutterrc` or       `~/.cookiecutters/` or `~/.cookiecutter_replay/`      During teardown:      * Delete `~/.cookiecutters/` only if a backup is present at       `~/.cookiecutters.backup/`     * Delete `~/.cookiecutter_replay/` only if a backup is present at       `~/.cookiecutter_replay.backup/`     * Restore the `~/.cookiecutterrc` config file from       `~/.cookiecutterrc.backup`     * Restore the `~/.cookiecutters/` dir from `~/.cookiecutters.backup/`     * Restore the `~/.cookiecutter_replay/` dir from       `~/.cookiecutter_replay.backup/`      """"""     # If ~/.cookiecutterrc is pre-existing, move it to a temp location     user_config_path = os.path.expanduser('~/.cookiecutterrc')     user_config_path_backup = os.path.expanduser('~/.cookiecutterrc.backup')     if os.path.exists(user_config_path):         user_config_found = True         shutil.copy(user_config_path, user_config_path_backup)         os.remove(user_config_path)     else:         user_config_found = False      # If the default cookiecutters_dir is pre-existing, move it to a     # temp location     cookiecutters_dir = os.path.expanduser('~/.cookiecutters')     cookiecutters_dir_backup = os.path.expanduser('~/.cookiecutters.backup')     cookiecutters_dir_found = backup_dir(cookiecutters_dir, cookiecutters_dir_backup)      # If the default cookiecutter_replay_dir is pre-existing, move it to a     # temp location     cookiecutter_replay_dir = os.path.expanduser('~/.cookiecutter_replay')     cookiecutter_replay_dir_backup = os.path.expanduser('~/.cookiecutter_replay.backup')     cookiecutter_replay_dir_found = backup_dir(         cookiecutter_replay_dir, cookiecutter_replay_dir_backup     )      def restore_backup() -> None:         # If it existed, restore ~/.cookiecutterrc         # We never write to ~/.cookiecutterrc, so this logic is simpler.         if user_config_found and os.path.exists(user_config_path_backup):             shutil.copy(user_config_path_backup, user_config_path)             os.remove(user_config_path_backup)          # Carefully delete the created ~/.cookiecutters dir only in certain         # conditions.         restore_backup_dir(             cookiecutters_dir, cookiecutters_dir_backup, cookiecutters_dir_found         )          # Carefully delete the created ~/.cookiecutter_replay dir only in         # certain conditions.         restore_backup_dir(             cookiecutter_replay_dir,             cookiecutter_replay_dir_backup,             cookiecutter_replay_dir_found,         )      request.addfinalizer(restore_backup)   @pytest.fixture(scope='session') def user_dir(tmp_path_factory):     """"""Fixture that simulates the user's home directory.""""""     return tmp_path_factory.mktemp('user_dir')   class UserConfigData(TypedDict):     cookiecutters_dir: str     replay_dir: str   @pytest.fixture(scope='session') def user_config_data(user_dir) -> UserConfigData:     """"""Fixture that creates 2 Cookiecutter user config dirs.       It will create it in the user's home directory.      * `cookiecutters_dir`     * `cookiecutter_replay`      :returns: Dict with name of both user config dirs     """"""     cookiecutters_dir = user_dir.joinpath('cookiecutters')     cookiecutters_dir.mkdir()     replay_dir = user_dir.joinpath('cookiecutter_replay')     replay_dir.mkdir()     return {         'cookiecutters_dir': str(cookiecutters_dir),         'replay_dir': str(replay_dir),     }   @pytest.fixture(scope='session') def user_config_file(user_dir, user_config_data) -> str:     """"""Fixture that creates a config file called `config`.       It will create it in the user's home directory, with YAML from      `user_config_data`.      :param user_dir: Simulated user's home directory     :param user_config_data: Dict of config values     :returns: String of path to config file     """"""     config_file = user_dir.joinpath('config')      config_text = USER_CONFIG.format(**user_config_data)     config_file.write_text(config_text)     return str(config_file)   @pytest.fixture def output_dir(tmp_path) -> str:     """"""Fixture to prepare test output directory.""""""     output_path = tmp_path.joinpath(""output"")     output_path.mkdir()     return str(output_path)   @pytest.fixture def clone_dir(tmp_path: Path) -> Path:     """"""Simulate creation of a directory called `clone_dir` inside of `tmp_path`. \     Returns a str to said directory.""""""     clone_dir = tmp_path.joinpath(""clone_dir"")     clone_dir.mkdir()     return clone_dir"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_abort_generate_on_hook_error.py,test_abort_generate_on_hook_error.py_chunk0,""""""" test_abort_generate_on_hook_error.  Tests to ensure cookiecutter properly exits with a non-zero exit code whenever errors occur in (optional) pre- or pos-gen hooks. """"""  import pytest  from cookiecutter import exceptions, generate   @pytest.mark.parametrize(     (""abort_pre_gen"", ""abort_post_gen""),     ((""yes"", ""no""), (""no"", ""yes"")),     ids=(""pre_gen_hook_raises_error"", ""post_gen_hook_raises_error""), ) @pytest.mark.usefixtures(""clean_system"") def test_hooks_raises_errors(tmp_path, abort_pre_gen, abort_post_gen) -> None:     """"""Verify pre- and pos-gen errors raises correct error code from script.      This allows developers to make different error codes in their code,     for different errors.     """"""     context = {         ""cookiecutter"": {             ""repo_dir"": ""foobar"",             ""abort_pre_gen"": abort_pre_gen,             ""abort_post_gen"": abort_post_gen,         }     }      with pytest.raises(exceptions.FailedHookException):         generate.generate_files(             repo_dir=""tests/hooks-abort-render"",             context=context,             output_dir=str(tmp_path),         )     assert not tmp_path.joinpath(""foobar"").is_dir()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cli.py,test_cli.py_chunk0,"""""""Collection of tests around cookiecutter's command-line interface.""""""  import json import os import re from pathlib import Path  import pytest from click.testing import CliRunner  from cookiecutter import utils from cookiecutter.cli import main from cookiecutter.environment import StrictEnvironment from cookiecutter.exceptions import UnknownExtension from cookiecutter.main import cookiecutter   @pytest.fixture(scope='session') def cli_runner():     """"""Fixture that returns a helper function to run the cookiecutter cli.""""""     runner = CliRunner()      def cli_main(*cli_args, **cli_kwargs):         """"""Run cookiecutter cli main with the given args.""""""         return runner.invoke(main, cli_args, **cli_kwargs)      return cli_main   @pytest.fixture def remove_fake_project_dir(request) -> None:     """"""Remove the fake project directory created during the tests.""""""      def fin_remove_fake_project_dir() -> None:         for prefix in ('', 'input'):             dir_name = f'{prefix}fake-project'             if os.path.isdir(dir_name):                 utils.rmtree(dir_name)      request.addfinalizer(fin_remove_fake_project_dir)   @pytest.fixture def remove_tmp_dir(request) -> None:     """"""Remove the fake project directory created during the tests.""""""     if os.path.isdir('tests/tmp'):         utils.rmtree('tests/tmp')      def fin_remove_tmp_dir() -> None:         if os.path.isdir('tests/tmp'):             utils.rmtree('tests/tmp')      request.addfinalizer(fin_remove_tmp_dir)   @pytest.fixture def make_fake_project_dir() -> None:     """"""Create a fake project to be overwritten in the according tests.""""""     os.makedirs('fake-project')   @pytest.fixture(params=['-V', '--version']) def version_cli_flag(request):     """"""Pytest fixture return both version invocation options.""""""     return request.param   def test_cli_version(cli_runner, version_cli_flag) -> None:     """"""Verify Cookiecutter version output by `cookiecutter` on cli invocation.""""""     result = cli_runner(version_cli_flag)     assert result.exit_code == 0     assert result.output.startswith('Cookiecutter')   @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir') def test_cli_error_on_existing_output_directory(cli_runner) -> None:     """"""Test cli invocation without `overwrite-if-exists` fail if dir exist.""""""     result = cli_runner('tests/fake-repo-pre/', '--no-input')     assert result.exit_code != 0     expected_error_msg = 'Error: ""fake-project"" directory already exists\n'     assert result.output == expected_error_msg   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli(cli_runner) -> None:     """"""Test cli invocation work without flags if directory not exist.""""""     result = cli_runner('tests/fake-repo-pre/', '--no-input')     assert result.exit_code == 0     assert os.path.isdir('fake-project')     content = Path(""fake-project"", ""README.rst"").read_text()     assert 'Project name: **Fake Project**' in content   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_verbose(cli_runner) -> None:     """"""Test cli invocation display log if called with `verbose` flag.""""""     result = cli_runner('tests/fake-repo-pre/', '--no-input', '-v')     assert result.exit_code == 0     assert os.path.isdir('fake-project')     content = Path(""fake-project"", ""README.rst"").read_text()     assert 'Project name: **Fake Project**' in content   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_replay(mocker, cli_runner) -> None:     """"""Test cli invocation display log with `verbose` and `replay` flags.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--replay', '-v')      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=True,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_replay_file(mocker, cli_runner) -> None:     """"""Test cli invocation correctly pass --replay-file option.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--replay-file', '~/custom-replay-file', '-v')      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay='~/custom-replay-file',         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   @pytest.mark.usefixtures('remove_tmp_dir') def test_cli_replay_generated(cli_runner) -> None:     """"""Test cli invocation correctly generates a project with replay.""""""     template_path = 'tests/fake-repo-replay/'     result = cli_runner(         template_path,         '--replay-file',         'tests/test-replay/valid_replay.json',         '-o',         'tests/tmp/',         '-v',     )     assert result.exit_code == 0     with open('tests/tmp/replay-project/README.md') as f:         assert f.read().strip() == 'replayed'   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_exit_on_noinput_and_replay(mocker, cli_runner) -> None:     """"""Test cli invocation fail if both `no-input` and `replay` flags passed.""""""     mock_cookiecutter = mocker.patch(         'cookiecutter.cli.cookiecutter', side_effect=cookiecutter     )      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--no-input', '--replay', '-v')      assert result.exit_code == 1      expected_error_msg = (         ""You can not use both replay and no_input or extra_context at the same time.""     )      assert expected_error_msg in result.output      mock_cookiecutter.assert_called_once_with(         template_path,         None,         True,         replay=True,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   @pytest.fixture(params=['-f', '--overwrite-if-exists']) def overwrite_cli_flag(request):     """"""Pytest fixture return all `overwrite-if-exists` invocation options.""""""     return request.param   @pytest.mark.usefixtures('remove_fake_project_dir') def test_run_cookiecutter_on_overwrite_if_exists_and_replay(     mocker, cli_runner, overwrite_cli_flag ) -> None:     """"""Test cli invocation with `overwrite-if-exists` and `replay` flags.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--replay', '-v', overwrite_cli_flag)      assert result.exit_code == 0      mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=True,         overwrite_if_exists=True,         skip_if_file_exists=False,         output_dir='.',         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_overwrite_if_exists_when_output_dir_does_not_exist(     cli_runner, overwrite_cli_flag ) -> None:     """"""Test cli invocation with `overwrite-if-exists` and `no-input` flags.      Case when output dir not exist.     """"""     result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)      assert result.exit_code == 0     assert os.path.isdir('fake-project')   @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir') def test_cli_overwrite_if_exists_when_output_dir_exists(     cli_runner, overwrite_cli_flag ) -> None:     """"""Test cli invocation with `overwrite-if-exists` and `no-input` flags.      Case when output dir already exist.     """"""     result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)     assert result.exit_code == 0     assert os.path.isdir('fake-project')   @pytest.fixture(params=['-o', '--output-dir']) def output_dir_flag(request):     """"""Pytest fixture return all output-dir invocation options.""""""     return request.param   def test_cli_output_dir(mocker, cli_runner, output_dir_flag, output_dir) -> None:     """"""Test cli invocation with `output-dir` flag changes output directory.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, output_dir_flag, output_dir)      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=False,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir=output_dir,         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   @pytest.fixture(params=['-h', '--help', 'help']) def help_cli_flag(request):     """"""Pytest fixture return all help invocation options.""""""     return request.param   def test_cli_help(cli_runner, help_cli_flag) -> None:     """"""Test cli invocation display help message with `help` flag.""""""     result = cli_runner(help_cli_flag)     assert result.exit_code == 0     assert result.output.startswith('Usage')   @pytest.fixture def user_config_path(tmp_path):     """"""Pytest fixture return `user_config` argument as string.""""""     return str(tmp_path.joinpath(""tests"", ""config.yaml""))   def test_user_config(mocker, cli_runner, user_config_path) -> None:     """"""Test cli invocation works with `config-file` option.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--config-file', user_config_path)      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=False,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=user_config_path,         default_config=False,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   def test_default_user_config_overwrite(mocker, cli_runner, user_config_path) -> None:     """"""Test cli invocation ignores `config-file` if `default-config` passed.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(         template_path,         '--config-file',         user_config_path,         '--default-config',     )      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=False,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=user_config_path,         default_config=True,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   def test_default_user_config(mocker, cli_runner) -> None:     """"""Test cli invocation accepts `default-config` flag correctly.""""""     mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')      template_path = 'tests/fake-repo-pre/'     result = cli_runner(template_path, '--default-config')      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=False,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         config_file=None,         default_config=True,         extra_context=None,         password=None,         directory=None,         accept_hooks=True,         keep_project_on_failure=False,     )   def test_echo_undefined_variable_error(output_dir, cli_runner) -> None:     """"""Cli invocation return error if variable undefined in template.""""""     template_path = 'tests/undefined-variable/file-name/'      result = cli_runner(         '--no-input',         '--default-config',         '--output-dir',         output_dir,         template_path,     )      assert result.exit_code == 1      error = ""Unable to create file '{{cookiecutter.foobar}}'""     assert error in result.output      message = (         ""Error message: 'collections.OrderedDict object' has no attribute 'foobar'""     )     assert message in result.output      context = {         '_cookiecutter': {             'github_username': 'hackebrot',             'project_slug': 'testproject',         },         'cookiecutter': {             'github_username': 'hackebrot',             'project_slug': 'testproject',             '_template': template_path,             '_repo_dir': template_path,             '_output_dir': output_dir,             '_checkout': None,         },     }     context_str = json.dumps(context, indent=4, sort_keys=True)     assert context_str in result.output   def test_echo_unknown_extension_error(output_dir, cli_runner) -> None:     """"""Cli return error if extension incorrectly defined in template.""""""     template_path = 'tests/test-extensions/unknown/'      result = cli_runner(         '--no-input',         '--default-config',         '--output-dir',         output_dir,         template_path,     )      assert result.exit_code == 1      assert 'Unable to load extension: ' in result.output   def test_local_extension(tmpdir, cli_runner) -> None:     """"""Test to verify correct work of extension, included in template.""""""     output_dir = str(tmpdir.mkdir('output'))     template_path = 'tests/test-extensions/local_extension/'      result = cli_runner(         '--no-input',         '--default-config',         '--output-dir',         output_dir,         template_path,     )     assert result.exit_code == 0     content = Path(output_dir, 'Foobar', 'HISTORY.rst').read_text()     assert 'FoobarFoobar' in content     assert 'FOOBAR' in content   def test_local_extension_not_available() -> None:     """"""Test handling of included but unavailable local extension.""""""     context = {'cookiecutter': {'_extensions': ['foobar']}}      with pytest.raises(UnknownExtension) as err:         StrictEnvironment(context=context, keep_trailing_newline=True)      assert 'Unable to load extension: ' in str(err.value)   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_extra_context(cli_runner) -> None:     """"""Cli invocation replace content if called with replacement pairs.""""""     result = cli_runner(         'tests/fake-repo-pre/',         '--no-input',         '-v',         'project_name=Awesomez',     )     assert result.exit_code == 0     assert os.path.isdir('fake-project')     content = Path('fake-project', 'README.rst').read_text()     assert 'Project name: **Awesomez**' in content"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cli.py,test_cli.py_chunk1,"def test_echo_unknown_extension_error(output_dir, cli_runner) -> None:     """"""Cli return error if extension incorrectly defined in template.""""""     template_path = 'tests/test-extensions/unknown/'      result = cli_runner(         '--no-input',         '--default-config',         '--output-dir',         output_dir,         template_path,     )      assert result.exit_code == 1      assert 'Unable to load extension: ' in result.output   def test_local_extension(tmpdir, cli_runner) -> None:     """"""Test to verify correct work of extension, included in template.""""""     output_dir = str(tmpdir.mkdir('output'))     template_path = 'tests/test-extensions/local_extension/'      result = cli_runner(         '--no-input',         '--default-config',         '--output-dir',         output_dir,         template_path,     )     assert result.exit_code == 0     content = Path(output_dir, 'Foobar', 'HISTORY.rst').read_text()     assert 'FoobarFoobar' in content     assert 'FOOBAR' in content   def test_local_extension_not_available() -> None:     """"""Test handling of included but unavailable local extension.""""""     context = {'cookiecutter': {'_extensions': ['foobar']}}      with pytest.raises(UnknownExtension) as err:         StrictEnvironment(context=context, keep_trailing_newline=True)      assert 'Unable to load extension: ' in str(err.value)   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_extra_context(cli_runner) -> None:     """"""Cli invocation replace content if called with replacement pairs.""""""     result = cli_runner(         'tests/fake-repo-pre/',         '--no-input',         '-v',         'project_name=Awesomez',     )     assert result.exit_code == 0     assert os.path.isdir('fake-project')     content = Path('fake-project', 'README.rst').read_text()     assert 'Project name: **Awesomez**' in content   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_extra_context_invalid_format(cli_runner) -> None:     """"""Cli invocation raise error if called with unknown argument.""""""     result = cli_runner(         'tests/fake-repo-pre/',         '--no-input',         '-v',         'ExtraContextWithNoEqualsSoInvalid',     )     assert result.exit_code == 2     assert ""Error: Invalid value for '[EXTRA_CONTEXT]...'"" in result.output     assert 'should contain items of the form key=value' in result.output   @pytest.fixture def debug_file(tmp_path):     """"""Pytest fixture return `debug_file` argument as path object.""""""     return tmp_path.joinpath('fake-repo.log')   @pytest.mark.usefixtures('remove_fake_project_dir') def test_debug_file_non_verbose(cli_runner, debug_file) -> None:     """"""Test cli invocation writes log to `debug-file` if flag enabled.      Case for normal log output.     """"""     assert not debug_file.exists()      result = cli_runner(         '--no-input',         '--debug-file',         str(debug_file),         'tests/fake-repo-pre/',     )     assert result.exit_code == 0      assert debug_file.exists()      context_log = (         ""DEBUG cookiecutter.main: context_file is ""         ""tests/fake-repo-pre/cookiecutter.json""     )     assert context_log in debug_file.read_text()     assert context_log not in result.output   @pytest.mark.usefixtures('remove_fake_project_dir') def test_debug_file_verbose(cli_runner, debug_file) -> None:     """"""Test cli invocation writes log to `debug-file` if flag enabled.      Case for verbose log output.     """"""     assert not debug_file.exists()      result = cli_runner(         '--verbose',         '--no-input',         '--debug-file',         str(debug_file),         'tests/fake-repo-pre/',     )     assert result.exit_code == 0      assert debug_file.exists()      context_log = (         ""DEBUG cookiecutter.main: context_file is ""         ""tests/fake-repo-pre/cookiecutter.json""     )     assert context_log in debug_file.read_text()     assert context_log in result.output   @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir') def test_debug_list_installed_templates(     cli_runner, debug_file, user_config_path ) -> None:     """"""Verify --list-installed command correct invocation.""""""     fake_template_dir = os.path.dirname(os.path.abspath('fake-project'))     os.makedirs(os.path.dirname(user_config_path))     # Single quotes in YAML will not parse escape codes (\).     Path(user_config_path).write_text(f""cookiecutters_dir: '{fake_template_dir}'"")     Path(""fake-project"", ""cookiecutter.json"").write_text('{}')      result = cli_runner(         '--list-installed',         '--config-file',         user_config_path,         str(debug_file),     )      assert ""1 installed templates:"" in result.output     assert result.exit_code == 0   def test_debug_list_installed_templates_failure(     cli_runner, debug_file, user_config_path ) -> None:     """"""Verify --list-installed command error on invocation.""""""     os.makedirs(os.path.dirname(user_config_path))     Path(user_config_path).write_text('cookiecutters_dir: ""/notarealplace/""')      result = cli_runner(         '--list-installed', '--config-file', user_config_path, str(debug_file)     )      assert ""Error: Cannot list installed templates."" in result.output     assert result.exit_code == -1   @pytest.mark.usefixtures('remove_fake_project_dir') def test_directory_repo(cli_runner) -> None:     """"""Test cli invocation works with `directory` option.""""""     result = cli_runner(         'tests/fake-repo-dir/',         '--no-input',         '-v',         '--directory=my-dir',     )     assert result.exit_code == 0     assert os.path.isdir(""fake-project"")     content = Path(""fake-project"", ""README.rst"").read_text()     assert ""Project name: **Fake Project**"" in content   cli_accept_hook_arg_testdata = [     (""--accept-hooks=yes"", None, True),     (""--accept-hooks=no"", None, False),     (""--accept-hooks=ask"", ""yes"", True),     (""--accept-hooks=ask"", ""no"", False), ]   @pytest.mark.parametrize(     ""accept_hooks_arg,user_input,expected"", cli_accept_hook_arg_testdata ) def test_cli_accept_hooks(     mocker,     cli_runner,     output_dir_flag,     output_dir,     accept_hooks_arg,     user_input,     expected, ) -> None:     """"""Test cli invocation works with `accept-hooks` option.""""""     mock_cookiecutter = mocker.patch(""cookiecutter.cli.cookiecutter"")      template_path = ""tests/fake-repo-pre/""     result = cli_runner(         template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input     )      assert result.exit_code == 0     mock_cookiecutter.assert_called_once_with(         template_path,         None,         False,         replay=False,         overwrite_if_exists=False,         output_dir=output_dir,         config_file=None,         default_config=False,         extra_context=None,         password=None,         directory=None,         skip_if_file_exists=False,         accept_hooks=expected,         keep_project_on_failure=False,     )   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_with_json_decoding_error(cli_runner) -> None:     """"""Test cli invocation with a malformed JSON file.""""""     template_path = 'tests/fake-repo-bad-json/'     result = cli_runner(template_path, '--no-input')     assert result.exit_code != 0      # Validate the error message.     # original message from json module should be included     pattern = 'Expecting \'{0,1}:\'{0,1} delimiter: line 1 column (19|20) \\(char 19\\)'     assert re.search(pattern, result.output)     # File name should be included too...for testing purposes, just test the     # last part of the file. If we wanted to test the absolute path, we'd have     # to do some additional work in the test which doesn't seem that needed at     # this point.     path = os.path.sep.join(['tests', 'fake-repo-bad-json', 'cookiecutter.json'])     assert path in result.output   @pytest.mark.usefixtures('remove_fake_project_dir') def test_cli_with_pre_prompt_hook(cli_runner) -> None:     """"""Test cli invocation in a template with pre_prompt hook.""""""     template_path = 'tests/test-pyhooks/'     result = cli_runner(template_path, '--no-input')     assert result.exit_code == 0     dir_name = 'inputfake-project'     assert os.path.isdir(dir_name)     content = Path(dir_name, ""README.rst"").read_text()     assert 'foo' in content   def test_cli_with_pre_prompt_hook_fail(cli_runner, monkeypatch) -> None:     """"""Test cli invocation will fail when a given env var is present.""""""     template_path = 'tests/test-pyhooks/'     with monkeypatch.context() as m:         m.setenv('COOKIECUTTER_FAIL_PRE_PROMPT', '1')         result = cli_runner(template_path, '--no-input')     assert result.exit_code == 1     dir_name = 'inputfake-project'     assert not Path(dir_name).exists()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cookiecutter_invocation.py,test_cookiecutter_invocation.py_chunk0,""""""" test_cookiecutter_invocation.  Tests to make sure that cookiecutter can be called from the cli without using the entry point set up for the package. """"""  import os import subprocess import sys  import pytest  from cookiecutter import utils   @pytest.fixture def project_dir():     """"""Return test project folder name and remove it after the test.""""""     yield 'fake-project-templated'      if os.path.isdir('fake-project-templated'):         utils.rmtree('fake-project-templated')   @pytest.mark.usefixtures('clean_system') def test_should_invoke_main(monkeypatch, project_dir) -> None:     """"""Should create a project and exit with 0 code on cli invocation.""""""     monkeypatch.setenv('PYTHONPATH', '.')      exit_code = subprocess.check_call(         [             sys.executable,             '-m',             'cookiecutter.cli',             'tests/fake-repo-tmpl',             '--no-input',         ]     )     assert exit_code == 0     assert os.path.isdir(project_dir)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cookiecutter_local_no_input.py,test_cookiecutter_local_no_input.py_chunk0,"""""""Test cookiecutter for work without any input.  Tests in this file execute `cookiecutter()` with `no_input=True` flag and verify result with different settings in `cookiecutter.json`. """"""  import os import textwrap from pathlib import Path  import pytest  from cookiecutter import main, utils   @pytest.fixture(scope='function') def remove_additional_dirs(request) -> None:     """"""Fixture. Remove special directories which are created during the tests.""""""      def fin_remove_additional_dirs() -> None:         if os.path.isdir('fake-project'):             utils.rmtree('fake-project')         if os.path.isdir('fake-project-extra'):             utils.rmtree('fake-project-extra')         if os.path.isdir('fake-project-templated'):             utils.rmtree('fake-project-templated')         if os.path.isdir('fake-project-dict'):             utils.rmtree('fake-project-dict')         if os.path.isdir('fake-tmp'):             utils.rmtree('fake-tmp')      request.addfinalizer(fin_remove_additional_dirs)   @pytest.mark.parametrize('path', ['tests/fake-repo-pre/', 'tests/fake-repo-pre']) @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_no_input_return_project_dir(path) -> None:     """"""Verify `cookiecutter` create project dir on input with or without slash.""""""     project_dir = main.cookiecutter(path, no_input=True)     assert os.path.isdir('tests/fake-repo-pre/{{cookiecutter.repo_name}}')     assert not os.path.isdir('tests/fake-repo-pre/fake-project')     assert os.path.isdir(project_dir)     assert os.path.isfile('fake-project/README.rst')     assert not os.path.exists('fake-project/json/')   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_no_input_extra_context() -> None:     """"""Verify `cookiecutter` accept `extra_context` argument.""""""     main.cookiecutter(         'tests/fake-repo-pre',         no_input=True,         extra_context={'repo_name': 'fake-project-extra'},     )     assert os.path.isdir('fake-project-extra')   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_templated_context() -> None:     """"""Verify Jinja2 templating correctly works in `cookiecutter.json` file.""""""     main.cookiecutter('tests/fake-repo-tmpl', no_input=True)     assert os.path.isdir('fake-project-templated')   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_no_input_return_rendered_file() -> None:     """"""Verify Jinja2 templating correctly works in `cookiecutter.json` file.""""""     project_dir = main.cookiecutter('tests/fake-repo-pre', no_input=True)     assert project_dir == os.path.abspath('fake-project')     content = Path(project_dir, 'README.rst').read_text()     assert ""Project name: **Fake Project**"" in content   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_dict_values_in_context() -> None:     """"""Verify configured dictionary from `cookiecutter.json` correctly unpacked.""""""     project_dir = main.cookiecutter('tests/fake-repo-dict', no_input=True)     assert project_dir == os.path.abspath('fake-project-dict')      content = Path(project_dir, 'README.md').read_text()     assert (         content         == textwrap.dedent(             """"""         # README           <dl>           <dt>Format name:</dt>           <dd>Bitmap</dd>            <dt>Extension:</dt>           <dd>bmp</dd>            <dt>Applications:</dt>           <dd>               <ul>               <li>Paint</li>               <li>GIMP</li>               </ul>           </dd>         </dl>          <dl>           <dt>Format name:</dt>           <dd>Portable Network Graphic</dd>            <dt>Extension:</dt>           <dd>png</dd>            <dt>Applications:</dt>           <dd>               <ul>               <li>GIMP</li>               </ul>           </dd>         </dl>      """"""         ).lstrip()     )   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_template_cleanup(mocker) -> None:     """"""Verify temporary folder for zip unpacking dropped.""""""     mocker.patch('tempfile.mkdtemp', return_value='fake-tmp', autospec=True)      mocker.patch(         'cookiecutter.prompt.prompt_and_delete', return_value=True, autospec=True     )      main.cookiecutter('tests/files/fake-repo-tmpl.zip', no_input=True)     assert os.path.isdir('fake-project-templated')      # The tmp directory will still exist, but the     # extracted template directory *in* the temp directory will not.     assert os.path.exists('fake-tmp')     assert not os.path.exists('fake-tmp/fake-repo-tmpl')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cookiecutter_local_with_input.py,test_cookiecutter_local_with_input.py_chunk0,"""""""Test main cookiecutter invocation with user input enabled (mocked).""""""  import os  import pytest  from cookiecutter import main, utils   @pytest.fixture(scope='function') def remove_additional_dirs():     """"""Remove special directories which are created during the tests.""""""     yield     if os.path.isdir('fake-project'):         utils.rmtree('fake-project')     if os.path.isdir('fake-project-input-extra'):         utils.rmtree('fake-project-input-extra')   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_local_with_input(monkeypatch) -> None:     """"""Verify simple cookiecutter run results, without extra_context provided.""""""     monkeypatch.setattr(         'cookiecutter.prompt.read_user_variable',         lambda _var, default, _prompts, _prefix: default,     )     main.cookiecutter('tests/fake-repo-pre/', no_input=False)     assert os.path.isdir('tests/fake-repo-pre/{{cookiecutter.repo_name}}')     assert not os.path.isdir('tests/fake-repo-pre/fake-project')     assert os.path.isdir('fake-project')     assert os.path.isfile('fake-project/README.rst')     assert not os.path.exists('fake-project/json/')   @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs') def test_cookiecutter_input_extra_context(monkeypatch) -> None:     """"""Verify simple cookiecutter run results, with extra_context provided.""""""     monkeypatch.setattr(         'cookiecutter.prompt.read_user_variable',         lambda _var, default, _prompts, _prefix: default,     )     main.cookiecutter(         'tests/fake-repo-pre',         no_input=False,         extra_context={'repo_name': 'fake-project-input-extra'},     )     assert os.path.isdir('fake-project-input-extra')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_cookiecutter_nested_templates.py,test_cookiecutter_nested_templates.py_chunk0,"""""""Test cookiecutter invocation with nested configuration structure.""""""  from pathlib import Path  import pytest  from cookiecutter import main   @pytest.mark.parametrize(     ""template_dir,output_dir"",     [         [""fake-nested-templates"", ""fake-project""],         [""fake-nested-templates-old-style"", ""fake-package""],     ], ) def test_cookiecutter_nested_templates(     mocker, template_dir: str, output_dir: str ) -> None:     """"""Verify cookiecutter nested configuration files mechanism.""""""     mock_generate_files = mocker.patch(""cookiecutter.main.generate_files"")     main_dir = (Path(""tests"") / template_dir).resolve()     main.cookiecutter(f""{main_dir}"", no_input=True)     expected = (Path(main_dir) / output_dir).resolve()     assert mock_generate_files.call_args[1][""repo_dir""] == f""{expected}"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_custom_extensions_in_hooks.py,test_custom_extensions_in_hooks.py_chunk0,""""""" test_custom_extension_in_hooks.  Tests to ensure custom cookiecutter extensions are properly made available to pre- and post-gen hooks. """"""  from pathlib import Path  import pytest  from cookiecutter import main   @pytest.fixture(     params=['custom-extension-pre', 'custom-extension-post'],     ids=['pre_gen_hook', 'post_gen_hook'], ) def template(request) -> str:     """"""Fixture. Allows to split pre and post hooks test directories.""""""     return f""tests/test-extensions/{request.param}""   @pytest.fixture(autouse=True) def modify_syspath(monkeypatch) -> None:     """"""Fixture. Make sure that the custom extension can be loaded.""""""     monkeypatch.syspath_prepend('tests/test-extensions/hello_extension')   def test_hook_with_extension(template, output_dir) -> None:     """"""Verify custom Jinja2 extension correctly work in hooks and file rendering.      Each file in hooks has simple tests inside and will raise error if not     correctly rendered.     """"""     project_dir = main.cookiecutter(         template,         no_input=True,         output_dir=output_dir,         extra_context={'project_slug': 'foobar', 'name': 'Cookiemonster'},     )      readme = Path(project_dir, 'README.rst').read_text(encoding=""utf-8"")     assert readme.strip() == 'Hello Cookiemonster!'"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_default_extensions.py,test_default_extensions.py_chunk0,"""""""Verify Jinja2 filters/extensions are available from pre-gen/post-gen hooks.""""""  import os import uuid from pathlib import Path  import freezegun import pytest  from cookiecutter.main import cookiecutter   @pytest.fixture(autouse=True) def freeze():     """"""Fixture. Make time stating during all tests in this file.""""""     freezer = freezegun.freeze_time(""2015-12-09 23:33:01"")     freezer.start()     yield     freezer.stop()   def test_jinja2_time_extension(tmp_path) -> None:     """"""Verify Jinja2 time extension work correctly.""""""     project_dir = cookiecutter(         'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)     )     changelog_file = os.path.join(project_dir, 'HISTORY.rst')     assert os.path.isfile(changelog_file)      with Path(changelog_file).open(encoding='utf-8') as f:         changelog_lines = f.readlines()      expected_lines = [         'History\n',         '-------\n',         '\n',         '0.1.0 (2015-12-09)\n',         '------------------\n',         '\n',         'First release on PyPI.\n',     ]     assert expected_lines == changelog_lines   def test_jinja2_slugify_extension(tmp_path) -> None:     """"""Verify Jinja2 slugify extension work correctly.""""""     project_dir = cookiecutter(         'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)     )      assert os.path.basename(project_dir) == ""it-s-slugified-foobar""   def test_jinja2_uuid_extension(tmp_path) -> None:     """"""Verify Jinja2 uuid extension work correctly.""""""     project_dir = cookiecutter(         'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)     )     changelog_file = os.path.join(project_dir, 'id')     assert os.path.isfile(changelog_file)      with Path(changelog_file).open(encoding='utf-8') as f:         changelog_lines = f.read().strip()      uuid.UUID(changelog_lines, version=4)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_environment.py,test_environment.py_chunk0,"""""""Collection of tests around loading extensions.""""""  import pytest  from cookiecutter.environment import StrictEnvironment from cookiecutter.exceptions import UnknownExtension   def test_env_should_raise_for_unknown_extension() -> None:     """"""Test should raise if extension not installed in system.""""""     context = {'cookiecutter': {'_extensions': ['foobar']}}      with pytest.raises(UnknownExtension) as err:         StrictEnvironment(context=context, keep_trailing_newline=True)      assert 'Unable to load extension: ' in str(err.value)   def test_env_should_come_with_default_extensions() -> None:     """"""Verify default extensions loaded with StrictEnvironment.""""""     env = StrictEnvironment(keep_trailing_newline=True)     assert 'cookiecutter.extensions.JsonifyExtension' in env.extensions     assert 'cookiecutter.extensions.RandomStringExtension' in env.extensions     assert 'cookiecutter.extensions.SlugifyExtension' in env.extensions     assert 'cookiecutter.extensions.TimeExtension' in env.extensions     assert 'cookiecutter.extensions.UUIDExtension' in env.extensions"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_exceptions.py,test_exceptions.py_chunk0,"""""""Collection of tests around general exception handling.""""""  from jinja2.exceptions import UndefinedError  from cookiecutter import exceptions   def test_undefined_variable_to_str() -> None:     """"""Verify string representation of errors formatted in expected form.""""""     undefined_var_error = exceptions.UndefinedVariableInTemplate(         'Beautiful is better than ugly',         UndefinedError('Errors should never pass silently'),         {'cookiecutter': {'foo': 'bar'}},     )      expected_str = (         ""Beautiful is better than ugly. ""         ""Error message: Errors should never pass silently. ""         ""Context: {'cookiecutter': {'foo': 'bar'}}""     )      assert str(undefined_var_error) == expected_str"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_find.py,test_find.py_chunk0,"""""""Tests for `cookiecutter.find` module.""""""  from contextlib import nullcontext as does_not_raise from pathlib import Path  import pytest  from cookiecutter import find from cookiecutter.exceptions import NonTemplatedInputDirException from cookiecutter.utils import create_env_with_context   @pytest.fixture(params=['fake-repo-pre', 'fake-repo-pre2']) def repo_dir(request):     """"""Fixture returning path for `test_find_template` test.""""""     return Path('tests', request.param)   @pytest.fixture() def env(context):     """"""Fixture return the env generated from context.""""""     return create_env_with_context(context)   @pytest.mark.parametrize(     ""repo_name,context,error_expectation,expected"",     [         (""fake-repo-pre"", {}, does_not_raise(), '{{cookiecutter.repo_name}}'),         (             ""fake-repo-pre2"",             {                 'cookiecutter': {                     '_jinja2_env_vars': {                         'variable_start_string': '{%{',                         'variable_end_string': '}%}',                     }                 }             },             does_not_raise(),             '{%{cookiecutter.repo_name}%}',         ),         (             ""fake-repo-pre"",             {                 'cookiecutter': {                     '_jinja2_env_vars': {                         'variable_start_string': '{%{',                         'variable_end_string': '}%}',                     }                 }             },             pytest.raises(NonTemplatedInputDirException),             None,         ),         (""fake-repo-bad"", {}, pytest.raises(NonTemplatedInputDirException), None),     ],     ids=[         'template with default jinja strings',         'template with custom jinja strings',         'template with custom jinja strings but folder with default jinja strings',         'template missing folder',     ], ) def test_find_template(repo_name, env, error_expectation, expected) -> None:     """"""Verify correctness of `find.find_template` path detection.""""""     repo_dir = Path('tests', repo_name)      with error_expectation:         template = find.find_template(repo_dir, env)          test_dir = Path(repo_dir, expected)         assert template == test_dir"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_context.py,test_generate_context.py_chunk0,"""""""Verify generate context behaviour and context overwrite priorities.""""""  from __future__ import annotations  import os import re from collections import OrderedDict from typing import Any, Iterator  import pytest  from cookiecutter import generate from cookiecutter.exceptions import ContextDecodingException from cookiecutter.prompt import YesNoPrompt   def context_data() -> Iterator[tuple[dict[str, Any], dict[str, Any]]]:     """"""Generate pytest parametrization variables for test.      Return ('input_params, expected_context') tuples.     """"""     context = (         {'context_file': 'tests/test-generate-context/test.json'},         {'test': {'1': 2, 'some_key': 'some_val'}},     )      context_with_default = (         {             'context_file': 'tests/test-generate-context/test.json',             'default_context': {'1': 3},         },         {'test': {'1': 3, 'some_key': 'some_val'}},     )      context_with_extra = (         {             'context_file': 'tests/test-generate-context/test.json',             'extra_context': {'1': 4},         },         {'test': {'1': 4, 'some_key': 'some_val'}},     )      context_with_default_and_extra = (         {             'context_file': 'tests/test-generate-context/test.json',             'default_context': {'1': 3},             'extra_context': {'1': 5},         },         {'test': {'1': 5, 'some_key': 'some_val'}},     )      yield context     yield context_with_default     yield context_with_extra     yield context_with_default_and_extra   @pytest.mark.usefixtures('clean_system') @pytest.mark.parametrize('input_params, expected_context', context_data()) def test_generate_context(input_params, expected_context) -> None:     """"""Verify input contexts combinations result in expected content on output.""""""     assert generate.generate_context(**input_params) == expected_context   @pytest.mark.usefixtures('clean_system') def test_generate_context_with_json_decoding_error() -> None:     """"""Verify malformed JSON file generates expected error output.""""""     with pytest.raises(ContextDecodingException) as excinfo:         generate.generate_context('tests/test-generate-context/invalid-syntax.json')     # original message from json module should be included     pattern = 'Expecting \'{0,1}:\'{0,1} delimiter: line 1 column (19|20) \\(char 19\\)'     assert re.search(pattern, str(excinfo.value))     # File name should be included too...for testing purposes, just test the     # last part of the file. If we wanted to test the absolute path, we'd have     # to do some additional work in the test which doesn't seem that needed at     # this point.     path = os.path.sep.join(['tests', 'test-generate-context', 'invalid-syntax.json'])     assert path in str(excinfo.value)   def test_default_context_replacement_in_generate_context() -> None:     """"""Verify default content settings are correctly replaced by template settings.      Make sure that the default for list variables of `orientation` is based on     the user config (`choices_template.json`) and not changed to a single value     from `default_context`.     """"""     expected_context = {         'choices_template': OrderedDict(             [                 ('full_name', 'Raphael Pierzina'),                 ('github_username', 'hackebrot'),                 ('project_name', 'Kivy Project'),                 ('repo_name', '{{cookiecutter.project_name|lower}}'),                 ('orientation', ['landscape', 'all', 'portrait']),             ]         )     }      generated_context = generate.generate_context(         context_file='tests/test-generate-context/choices_template.json',         default_context={             'not_in_template': 'foobar',             'project_name': 'Kivy Project',             'orientation': 'landscape',         },         extra_context={             'also_not_in_template': 'foobar2',             'github_username': 'hackebrot',         },     )      assert generated_context == expected_context   def test_generate_context_decodes_non_ascii_chars() -> None:     """"""Verify `generate_context` correctly decodes non-ascii chars.""""""     expected_context = {         'non_ascii': OrderedDict(             [                 ('full_name', 'éèà'),             ]         )     }      generated_context = generate.generate_context(         context_file='tests/test-generate-context/non_ascii.json'     )      assert generated_context == expected_context   @pytest.fixture def template_context():     """"""Fixture. Populates template content for future tests.""""""     return OrderedDict(         [             ('full_name', 'Raphael Pierzina'),             ('github_username', 'hackebrot'),             ('project_name', 'Kivy Project'),             ('repo_name', '{{cookiecutter.project_name|lower}}'),             ('orientation', ['all', 'landscape', 'portrait']),             ('deployment_regions', ['eu', 'us', 'ap']),             (                 'deployments',                 {                     'preprod': ['eu', 'us', 'ap'],                     'prod': ['eu', 'us', 'ap'],                 },             ),         ]     )   def test_apply_overwrites_does_include_unused_variables(template_context) -> None:     """"""Verify `apply_overwrites_to_context` skips variables that are not in context.""""""     generate.apply_overwrites_to_context(         context=template_context, overwrite_context={'not in template': 'foobar'}     )      assert 'not in template' not in template_context   def test_apply_overwrites_sets_non_list_value(template_context) -> None:     """"""Verify `apply_overwrites_to_context` work with string variables.""""""     generate.apply_overwrites_to_context(         context=template_context, overwrite_context={'repo_name': 'foobar'}     )      assert template_context['repo_name'] == 'foobar'   def test_apply_overwrites_does_not_modify_choices_for_invalid_overwrite() -> None:     """"""Verify variables overwrite for list if variable not in list ignored.""""""     expected_context = {         'choices_template': OrderedDict(             [                 ('full_name', 'Raphael Pierzina'),                 ('github_username', 'hackebrot'),                 ('project_name', 'Kivy Project'),                 ('repo_name', '{{cookiecutter.project_name|lower}}'),                 ('orientation', ['all', 'landscape', 'portrait']),             ]         )     }      with pytest.warns(UserWarning, match=""Invalid default received""):         generated_context = generate.generate_context(             context_file='tests/test-generate-context/choices_template.json',             default_context={                 'not_in_template': 'foobar',                 'project_name': 'Kivy Project',                 'orientation': 'foobar',             },             extra_context={                 'also_not_in_template': 'foobar2',                 'github_username': 'hackebrot',             },         )      assert generated_context == expected_context   def test_apply_overwrites_invalid_overwrite(template_context) -> None:     """"""Verify variables overwrite for list if variable not in list not ignored.""""""     with pytest.raises(ValueError):         generate.apply_overwrites_to_context(             context=template_context, overwrite_context={'orientation': 'foobar'}         )   def test_apply_overwrites_sets_multichoice_values(template_context) -> None:     """"""Verify variable overwrite for list given multiple valid values.""""""     generate.apply_overwrites_to_context(         context=template_context,         overwrite_context={'deployment_regions': ['eu']},     )     assert template_context['deployment_regions'] == ['eu']   def test_apply_overwrites_invalid_multichoice_values(template_context) -> None:     """"""Verify variable overwrite for list given invalid list entries not ignored.""""""     with pytest.raises(ValueError):         generate.apply_overwrites_to_context(             context=template_context,             overwrite_context={'deployment_regions': ['na']},         )   def test_apply_overwrites_error_additional_values(template_context) -> None:     """"""Verify variable overwrite for list given additional entries not ignored.""""""     with pytest.raises(ValueError):         generate.apply_overwrites_to_context(             context=template_context,             overwrite_context={'deployment_regions': ['eu', 'na']},         )   def test_apply_overwrites_in_dictionaries(template_context) -> None:     """"""Verify variable overwrite for lists nested in dictionary variables.""""""     generate.apply_overwrites_to_context(         context=template_context,         overwrite_context={'deployments': {'preprod': ['eu'], 'prod': ['ap']}},     )     assert template_context['deployments']['preprod'] == ['eu']     assert template_context['deployments']['prod'] == ['ap']   def test_apply_overwrites_sets_default_for_choice_variable(template_context) -> None:     """"""Verify overwritten list member became a default value.""""""     generate.apply_overwrites_to_context(         context=template_context, overwrite_context={'orientation': 'landscape'}     )      assert template_context['orientation'] == ['landscape', 'all', 'portrait']   def test_apply_overwrites_in_nested_dict() -> None:     """"""Verify nested dict in default content settings are correctly replaced.""""""     expected_context = {         'nested_dict': OrderedDict(             [                 ('full_name', 'Raphael Pierzina'),                 ('github_username', 'hackebrot'),                 (                     'project',                     OrderedDict(                         [                             ('name', 'My Kivy Project'),                             ('description', 'My Kivy Project'),                             ('repo_name', '{{cookiecutter.project_name|lower}}'),                             ('orientation', [""all"", ""landscape"", ""portrait""]),                         ]                     ),                 ),             ]         )     }      generated_context = generate.generate_context(         context_file='tests/test-generate-context/nested_dict.json',         default_context={             'not_in_template': 'foobar',             'project': {                 'description': 'My Kivy Project',             },         },         extra_context={             'also_not_in_template': 'foobar2',             'github_username': 'hackebrot',             'project': {                 'name': 'My Kivy Project',             },         },     )      assert generated_context == expected_context   def test_apply_overwrite_context_as_in_nested_dict_with_additional_values() -> None:     """"""Verify nested dict in default content settings are correctly added.      The `apply_overwrites_to_context` function should add the extra values to the dict.     """"""     expected = OrderedDict({""key1"": ""value1"", ""key2"": ""value2""})     context = OrderedDict({""key1"": ""value1""})     overwrite_context = OrderedDict({""key2"": ""value2""})     generate.apply_overwrites_to_context(         context,         overwrite_context,         in_dictionary_variable=True,     )     assert context == expected   def test_apply_overwrites_in_nested_dict_additional_values() -> None:     """"""Verify nested dict in default content settings are correctly added.""""""     expected_context = {         'nested_dict_additional': OrderedDict(             [                 ('mainkey1', 'mainvalue1'),                 (                     'mainkey2',                     OrderedDict(                         [                             ('subkey1', 'subvalue1'),                             (                                 'subkey2',                                 OrderedDict(                                     [                                         ('subsubkey1', 'subsubvalue1'),                                         ('subsubkey2', 'subsubvalue2_default'),                                         ('subsubkey3', 'subsubvalue3_extra'),                                     ]                                 ),                             ),                             ('subkey4', 'subvalue4_default'),                             ('subkey5', 'subvalue5_extra'),                         ]                     ),                 ),             ]         )     }      generated_context = generate.generate_context(         context_file='tests/test-generate-context/nested_dict_additional.json',         default_context={             'not_in_template': 'foobar',             'mainkey2': {                 'subkey2': {                     'subsubkey2': 'subsubvalue2_default',                 },                 'subkey4': 'subvalue4_default',             },         },         extra_context={             'also_not_in_template': 'foobar2',             'mainkey2': {                 'subkey2': {                     'subsubkey3': 'subsubvalue3_extra',                 },                 'subkey5': 'subvalue5_extra',             },         },     )      assert generated_context == expected_context   @pytest.mark.parametrize(     ""overwrite_value, expected"",     [(bool_string, {'key': True}) for bool_string in YesNoPrompt.yes_choices]     + [(bool_string, {'key': False}) for bool_string in YesNoPrompt.no_choices], ) def test_apply_overwrites_overwrite_value_as_boolean_string(overwrite_value, expected):     """"""Verify boolean conversion for valid overwrite values.""""""     context = {'key': not expected['key']}     overwrite_context = {'key': overwrite_value}     generate.apply_overwrites_to_context(context, overwrite_context)     assert context == expected   def test_apply_overwrites_error_overwrite_value_as_boolean_string():     """"""Verify boolean conversion for invalid overwrite values.""""""     context = {'key': True}     overwrite_context = {'key': 'invalid'}     with pytest.raises(ValueError):         generate.apply_overwrites_to_context(context, overwrite_context)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_copy_without_render.py,test_generate_copy_without_render.py_chunk0,"""""""Verify correct work of `_copy_without_render` context option.""""""  import os from pathlib import Path  import pytest  from cookiecutter import generate, utils   @pytest.fixture def remove_test_dir():     """"""Fixture. Remove the folder that is created by the test.""""""     yield     if os.path.exists('test_copy_without_render'):         utils.rmtree('test_copy_without_render')   @pytest.mark.usefixtures('clean_system', 'remove_test_dir') def test_generate_copy_without_render_extensions() -> None:     """"""Verify correct work of `_copy_without_render` context option.      Some files/directories should be rendered during invocation,     some just copied, without any modification.     """"""     generate.generate_files(         context={             'cookiecutter': {                 'repo_name': 'test_copy_without_render',                 'render_test': 'I have been rendered!',                 '_copy_without_render': [                     '*not-rendered',                     'rendered/not_rendered.yml',                     '*.txt',                     '{{cookiecutter.repo_name}}-rendered/README.md',                 ],             }         },         repo_dir='tests/test-generate-copy-without-render',     )      dir_contents = os.listdir('test_copy_without_render')      assert 'test_copy_without_render-not-rendered' in dir_contents     assert 'test_copy_without_render-rendered' in dir_contents      file_1 = Path('test_copy_without_render/README.txt').read_text()     assert '{{cookiecutter.render_test}}' in file_1      file_2 = Path('test_copy_without_render/README.rst').read_text()     assert 'I have been rendered!' in file_2      file_3 = Path(         'test_copy_without_render/test_copy_without_render-rendered/README.txt'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_3      file_4 = Path(         'test_copy_without_render/test_copy_without_render-rendered/README.rst'     ).read_text()     assert 'I have been rendered' in file_4      file_5 = Path(         'test_copy_without_render/'         'test_copy_without_render-not-rendered/'         'README.rst'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_5      file_6 = Path('test_copy_without_render/rendered/not_rendered.yml').read_text()     assert '{{cookiecutter.render_test}}' in file_6      file_7 = Path(         'test_copy_without_render/' 'test_copy_without_render-rendered/' 'README.md'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_7"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_copy_without_render_override.py,test_generate_copy_without_render_override.py_chunk0,"""""""Verify correct work of `_copy_without_render` context option.""""""  import os from pathlib import Path  import pytest  from cookiecutter import generate, utils   @pytest.fixture def remove_test_dir():     """"""Fixture. Remove the folder that is created by the test.""""""     yield     if os.path.exists('test_copy_without_render'):         utils.rmtree('test_copy_without_render')   @pytest.mark.usefixtures('clean_system', 'remove_test_dir') def test_generate_copy_without_render_extensions() -> None:     """"""Verify correct work of `_copy_without_render` context option.      Some files/directories should be rendered during invocation,     some just copied, without any modification.     """"""     # first run     generate.generate_files(         context={             'cookiecutter': {                 'repo_name': 'test_copy_without_render',                 'render_test': 'I have been rendered!',                 '_copy_without_render': [                     '*not-rendered',                     'rendered/not_rendered.yml',                     '*.txt',                     '{{cookiecutter.repo_name}}-rendered/README.md',                 ],             }         },         repo_dir='tests/test-generate-copy-without-render-override',     )      # second run with override flag to True     generate.generate_files(         context={             'cookiecutter': {                 'repo_name': 'test_copy_without_render',                 'render_test': 'I have been rendered!',                 '_copy_without_render': [                     '*not-rendered',                     'rendered/not_rendered.yml',                     '*.txt',                     '{{cookiecutter.repo_name}}-rendered/README.md',                 ],             }         },         overwrite_if_exists=True,         repo_dir='tests/test-generate-copy-without-render',     )      dir_contents = os.listdir('test_copy_without_render')      assert 'test_copy_without_render-not-rendered' in dir_contents     assert 'test_copy_without_render-rendered' in dir_contents      file_1 = Path('test_copy_without_render/README.txt').read_text()     assert '{{cookiecutter.render_test}}' in file_1      file_2 = Path('test_copy_without_render/README.rst').read_text()     assert 'I have been rendered!' in file_2      file_3 = Path(         'test_copy_without_render/test_copy_without_render-rendered/README.txt'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_3      file_4 = Path(         'test_copy_without_render/test_copy_without_render-rendered/README.rst'     ).read_text()     assert 'I have been rendered' in file_4      file_5 = Path(         'test_copy_without_render/'         'test_copy_without_render-not-rendered/'         'README.rst'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_5      file_6 = Path('test_copy_without_render/rendered/not_rendered.yml').read_text()     assert '{{cookiecutter.render_test}}' in file_6      file_7 = Path(         'test_copy_without_render/' 'test_copy_without_render-rendered/' 'README.md'     ).read_text()     assert '{{cookiecutter.render_test}}' in file_7"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_file.py,test_generate_file.py_chunk0,"""""""Tests for `generate_file` function, part of `generate_files` function workflow.""""""  import json import os import re from pathlib import Path  import pytest from jinja2 import FileSystemLoader from jinja2.exceptions import TemplateSyntaxError  from cookiecutter import generate from cookiecutter.environment import StrictEnvironment   @pytest.fixture(scope='function', autouse=True) def tear_down():     """"""     Fixture. Remove the test text file which is created by the tests.      Used for all tests in this file.     """"""     yield     if os.path.exists('tests/files/cheese.txt'):         os.remove('tests/files/cheese.txt')     if os.path.exists('tests/files/cheese_lf_newlines.txt'):         os.remove('tests/files/cheese_lf_newlines.txt')     if os.path.exists('tests/files/cheese_crlf_newlines.txt'):         os.remove('tests/files/cheese_crlf_newlines.txt')     if os.path.exists('tests/files/cheese_mixed_newlines.txt'):         os.remove('tests/files/cheese_mixed_newlines.txt')     if os.path.exists('tests/files/{{cookiecutter.generate_file}}_mixed_newlines.txt'):         os.remove('tests/files/{{cookiecutter.generate_file}}_mixed_newlines.txt')   @pytest.fixture def env():     """"""Fixture. Set Jinja2 environment settings for other tests.""""""     environment = StrictEnvironment()     environment.loader = FileSystemLoader('.')     return environment   def test_generate_file(env) -> None:     """"""Verify simple file is generated with rendered context data.""""""     infile = 'tests/files/{{cookiecutter.generate_file}}.txt'     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'cheese'}},         env=env,     )     assert os.path.isfile('tests/files/cheese.txt')     generated_text = Path('tests/files/cheese.txt').read_text()     assert generated_text == 'Testing cheese'   def test_generate_file_jsonify_filter(env) -> None:     """"""Verify jsonify filter works during files generation process.""""""     infile = 'tests/files/{{cookiecutter.jsonify_file}}.txt'     data = {'jsonify_file': 'cheese', 'type': 'roquefort'}     generate.generate_file(         project_dir=""."", infile=infile, context={'cookiecutter': data}, env=env     )     assert os.path.isfile('tests/files/cheese.txt')     generated_text = Path('tests/files/cheese.txt').read_text()     assert json.loads(generated_text) == data   @pytest.mark.parametrize(""length"", (10, 40)) @pytest.mark.parametrize(""punctuation"", (True, False)) def test_generate_file_random_ascii_string(env, length, punctuation) -> None:     """"""Verify correct work of random_ascii_string extension on file generation.""""""     infile = 'tests/files/{{cookiecutter.random_string_file}}.txt'     data = {'random_string_file': 'cheese'}     context = {""cookiecutter"": data, ""length"": length, ""punctuation"": punctuation}     generate.generate_file(project_dir=""."", infile=infile, context=context, env=env)     assert os.path.isfile('tests/files/cheese.txt')     generated_text = Path('tests/files/cheese.txt').read_text()     assert len(generated_text) == length   def test_generate_file_with_true_condition(env) -> None:     """"""Verify correct work of boolean condition in file name on file generation.      This test has positive answer, so file should be rendered.     """"""     infile = (         'tests/files/{% if cookiecutter.generate_file == \'y\' %}cheese.txt{% endif %}'     )     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'y'}},         env=env,     )     assert os.path.isfile('tests/files/cheese.txt')     generated_text = Path('tests/files/cheese.txt').read_text()     assert generated_text == 'Testing that generate_file was y'   def test_generate_file_with_false_condition(env) -> None:     """"""Verify correct work of boolean condition in file name on file generation.      This test has negative answer, so file should not be rendered.     """"""     infile = (         'tests/files/{% if cookiecutter.generate_file == \'y\' %}cheese.txt{% endif %}'     )     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'n'}},         env=env,     )     assert not os.path.isfile('tests/files/cheese.txt')   @pytest.fixture def expected_msg_regex():     """"""Fixture. Used to ensure that exception generated text contain full data.""""""     return re.compile(         'Missing end of comment tag\n'         ' {2}File ""(.[/\\\\])*tests[/\\\\]files[/\\\\]syntax_error.txt"", line 1\n'         ' {4}I eat {{ syntax_error }} {# this comment is not closed}'     )   def test_generate_file_verbose_template_syntax_error(env, expected_msg_regex) -> None:     """"""Verify correct exception raised on syntax error in file before generation.""""""     with pytest.raises(TemplateSyntaxError) as exception:         generate.generate_file(             project_dir=""."",             infile='tests/files/syntax_error.txt',             context={'syntax_error': 'syntax_error'},             env=env,         )     assert expected_msg_regex.match(str(exception.value))   def test_generate_file_does_not_translate_lf_newlines_to_crlf(env) -> None:     """"""Verify that file generation use same line ending, as in source file.""""""     infile = 'tests/files/{{cookiecutter.generate_file}}_lf_newlines.txt'     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'cheese'}},         env=env,     )      # this generated file should have a LF line ending     gf = 'tests/files/cheese_lf_newlines.txt'     with Path(gf).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text == 'newline is LF\n'     assert f.newlines == '\n'   def test_generate_file_does_not_translate_crlf_newlines_to_lf(env) -> None:     """"""Verify that file generation use same line ending, as in source file.""""""     infile = 'tests/files/{{cookiecutter.generate_file}}_crlf_newlines.txt'     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'cheese'}},         env=env,     )      # this generated file should have a CRLF line ending     gf = 'tests/files/cheese_crlf_newlines.txt'     with Path(gf).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text == 'newline is CRLF\r\n'     assert f.newlines == '\r\n'   def test_generate_file_handles_mixed_line_endings(env) -> None:     """"""Verify that file generation gracefully handles mixed line endings.""""""     infile = 'tests/files/{{cookiecutter.generate_file}}_mixed_newlines.txt'     with open(infile, mode='w', encoding='utf-8', newline='') as f:         f.write('newline is CRLF\r\n')         f.write('newline is LF\n')     generate.generate_file(         project_dir=""."",         infile=infile,         context={'cookiecutter': {'generate_file': 'cheese'}},         env=env,     )      # this generated file should have either CRLF or LF line ending     gf = 'tests/files/cheese_mixed_newlines.txt'     with Path(gf).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text in ('newline is CRLF\r\n', 'newline is CRLF\n')     assert f.newlines in ('\r\n', '\n')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_files.py,test_generate_files.py_chunk0,"""""""Tests for `generate_files` function and related errors raising.  Use the global clean_system fixture and run additional teardown code to remove some special folders. """"""  from pathlib import Path  import pytest from binaryornot.check import is_binary from jinja2 import Environment  from cookiecutter import exceptions, generate   def test_generate_files_nontemplated_exception(tmp_path) -> None:     """"""     Verify `generate_files` raises when no directories to render exist.      Note: Check `tests/test-generate-files-nontemplated` location to understand.     """"""     with pytest.raises(exceptions.NonTemplatedInputDirException):         generate.generate_files(             context={'cookiecutter': {'food': 'pizza'}},             repo_dir='tests/test-generate-files-nontemplated',             output_dir=tmp_path,         )   def test_generate_files(tmp_path) -> None:     """"""Verify directory name correctly rendered with unicode containing context.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      simple_file = Path(tmp_path, 'inputpizzä/simple.txt')     assert simple_file.exists()     assert simple_file.is_file()      simple_text = Path(simple_file).read_text(encoding='utf-8')     assert simple_text == 'I eat pizzä\n'   def test_generate_files_with_linux_newline(tmp_path) -> None:     """"""Verify new line not removed by templating engine after folder generation.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      newline_file = Path(tmp_path, 'inputpizzä/simple-with-newline.txt')     assert newline_file.is_file()     assert newline_file.exists()      with Path(newline_file).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text == 'newline is LF\n'     assert f.newlines == '\n'   def test_generate_files_with_jinja2_environment(tmp_path) -> None:     """"""Extend StrictEnvironment with _jinja2_env_vars cookiecutter template option.""""""     generate.generate_files(         context={             'cookiecutter': {                 'food': 'pizzä',                 '_jinja2_env_vars': {'lstrip_blocks': True, 'trim_blocks': True},             }         },         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      conditions_file = tmp_path.joinpath('inputpizzä/simple-with-conditions.txt')     assert conditions_file.is_file()     assert conditions_file.exists()      simple_text = conditions_file.read_text(encoding='utf-8')     assert simple_text == 'I eat pizzä\n'   def test_generate_files_with_trailing_newline_forced_to_linux_by_context(     tmp_path, ) -> None:     """"""Verify new line not removed by templating engine after folder generation.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä', '_new_lines': '\r\n'}},         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      # assert 'Overwritting endline character with %s' in caplog.messages     newline_file = Path(tmp_path, 'inputpizzä/simple-with-newline.txt')     assert newline_file.is_file()     assert newline_file.exists()      with Path(newline_file).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text == 'newline is LF\r\n'     assert f.newlines == '\r\n'   def test_generate_files_with_windows_newline(tmp_path) -> None:     """"""Verify windows source line end not changed during files generation.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      newline_file = Path(tmp_path, 'inputpizzä/simple-with-newline-crlf.txt')     assert newline_file.is_file()     assert newline_file.exists()      with Path(newline_file).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()     assert simple_text == 'newline is CRLF\r\n'     assert f.newlines == '\r\n'   def test_generate_files_with_windows_newline_forced_to_linux_by_context(     tmp_path, ) -> None:     """"""Verify windows line end changed to linux during files generation.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä', '_new_lines': '\n'}},         repo_dir='tests/test-generate-files',         output_dir=tmp_path,     )      newline_file = Path(tmp_path, 'inputpizzä/simple-with-newline-crlf.txt')     assert newline_file.is_file()     assert newline_file.exists()      with Path(newline_file).open(encoding='utf-8', newline='') as f:         simple_text = f.readline()      assert simple_text == 'newline is CRLF\n'     assert f.newlines == '\n'   def test_generate_files_binaries(tmp_path) -> None:     """"""Verify binary files created during directory generation.""""""     generate.generate_files(         context={'cookiecutter': {'binary_test': 'binary_files'}},         repo_dir='tests/test-generate-binaries',         output_dir=tmp_path,     )      dst_dir = Path(tmp_path, 'inputbinary_files')      assert is_binary(str(Path(dst_dir, 'logo.png')))     assert is_binary(str(Path(dst_dir, '.DS_Store')))     assert not is_binary(str(Path(dst_dir, 'readme.txt')))     assert is_binary(str(Path(dst_dir, 'some_font.otf')))     assert is_binary(str(Path(dst_dir, 'binary_files/logo.png')))     assert is_binary(str(Path(dst_dir, 'binary_files/.DS_Store')))     assert not is_binary(str(Path(dst_dir, 'binary_files/readme.txt')))     assert is_binary(str(Path(dst_dir, 'binary_files/some_font.otf')))     assert is_binary(str(Path(dst_dir, 'binary_files/binary_files/logo.png')))   def test_generate_files_absolute_path(tmp_path) -> None:     """"""Verify usage of absolute path does not change files generation behaviour.""""""     generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir=Path('tests/test-generate-files').absolute(),         output_dir=tmp_path,     )     assert Path(tmp_path, 'inputpizzä/simple.txt').is_file()   def test_generate_files_output_dir(tmp_path) -> None:     """"""Verify `output_dir` option for `generate_files` changing location correctly.""""""     output_dir = Path(tmp_path, 'custom_output_dir')     output_dir.mkdir()      project_dir = generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir=Path('tests/test-generate-files').absolute(),         output_dir=output_dir,     )      assert Path(output_dir, 'inputpizzä/simple.txt').exists()     assert Path(output_dir, 'inputpizzä/simple.txt').is_file()     assert Path(project_dir) == Path(tmp_path, 'custom_output_dir/inputpizzä')   def test_generate_files_permissions(tmp_path) -> None:     """"""Verify generates files respect source files permissions.      simple.txt and script.sh should retain their respective 0o644 and 0o755     permissions.     """"""     generate.generate_files(         context={'cookiecutter': {'permissions': 'permissions'}},         repo_dir='tests/test-generate-files-permissions',         output_dir=tmp_path,     )      assert Path(tmp_path, 'inputpermissions/simple.txt').is_file()      # Verify source simple.txt should still be 0o644     tests_simple_file = Path(         'tests',         'test-generate-files-permissions',         'input{{cookiecutter.permissions}}',         'simple.txt',     )     tests_simple_file_mode = tests_simple_file.stat().st_mode      input_simple_file = Path(tmp_path, 'inputpermissions', 'simple.txt')     input_simple_file_mode = input_simple_file.stat().st_mode     assert tests_simple_file_mode == input_simple_file_mode      assert Path(tmp_path, 'inputpermissions/script.sh').exists()     assert Path(tmp_path, 'inputpermissions/script.sh').is_file()      # Verify source script.sh should still be 0o755     tests_script_file = Path(         'tests',         'test-generate-files-permissions',         'input{{cookiecutter.permissions}}',         'script.sh',     )     tests_script_file_mode = tests_script_file.stat().st_mode      input_script_file = Path(tmp_path, 'inputpermissions', 'script.sh')     input_script_file_mode = input_script_file.stat().st_mode     assert tests_script_file_mode == input_script_file_mode   def test_generate_files_with_overwrite_if_exists_with_skip_if_file_exists(     tmp_path, ) -> None:     """"""Verify `skip_if_file_exist` has priority over `overwrite_if_exists`.""""""     simple_file = Path(tmp_path, 'inputpizzä/simple.txt')     simple_with_new_line_file = Path(tmp_path, 'inputpizzä/simple-with-newline.txt')      Path(tmp_path, 'inputpizzä').mkdir(parents=True)     with Path(simple_file).open('w') as f:         f.write('temp')      generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir='tests/test-generate-files',         overwrite_if_exists=True,         skip_if_file_exists=True,         output_dir=tmp_path,     )      assert Path(simple_file).is_file()     assert Path(simple_file).exists()     assert Path(simple_with_new_line_file).is_file()     assert Path(simple_with_new_line_file).exists()      simple_text = Path(simple_file).read_text(encoding='utf-8')     assert simple_text == 'temp'   def test_generate_files_with_skip_if_file_exists(tmp_path) -> None:     """"""Verify existed files not removed if error raised with `skip_if_file_exists`.""""""     simple_file = Path(tmp_path, 'inputpizzä/simple.txt')     simple_with_new_line_file = Path(tmp_path, 'inputpizzä/simple-with-newline.txt')      Path(tmp_path, 'inputpizzä').mkdir(parents=True)     Path(simple_file).write_text('temp')      with pytest.raises(exceptions.OutputDirExistsException):         generate.generate_files(             context={'cookiecutter': {'food': 'pizzä'}},             repo_dir='tests/test-generate-files',             skip_if_file_exists=True,             output_dir=tmp_path,         )      assert Path(simple_file).is_file()     assert not Path(simple_with_new_line_file).is_file()     assert not Path(simple_with_new_line_file).exists()      simple_text = Path(simple_file).read_text(encoding='utf-8')     assert simple_text == 'temp'   def test_generate_files_with_overwrite_if_exists(tmp_path) -> None:     """"""Verify overwrite_if_exists overwrites old files.""""""     simple_file = Path(tmp_path, 'inputpizzä/simple.txt')     simple_with_new_line_file = Path(tmp_path, 'inputpizzä/simple-with-newline.txt')      Path(tmp_path, 'inputpizzä').mkdir(parents=True)     Path(simple_file).write_text('temp')      generate.generate_files(         context={'cookiecutter': {'food': 'pizzä'}},         repo_dir='tests/test-generate-files',         overwrite_if_exists=True,         output_dir=tmp_path,     )      assert Path(simple_file).is_file()     assert Path(simple_file).exists()     assert Path(simple_with_new_line_file).is_file()     assert Path(simple_with_new_line_file).exists()      simple_text = Path(simple_file).read_text(encoding='utf-8')     assert simple_text == 'I eat pizzä\n'   @pytest.fixture def undefined_context():     """"""Fixture. Populate context variable for future tests.""""""     return {         'cookiecutter': {'project_slug': 'testproject', 'github_username': 'hackebrot'}     }   def test_raise_undefined_variable_file_name(output_dir, undefined_context) -> None:     """"""Verify correct error raised when file name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/file-name/',             output_dir=output_dir,             context=undefined_context,         )     error = err.value     assert error.message == ""Unable to create file '{{cookiecutter.foobar}}'""     assert error.context == undefined_context      assert not Path(output_dir).joinpath('testproject').exists()   def test_raise_undefined_variable_file_name_existing_project(     output_dir, undefined_context ) -> None:     """"""Verify correct error raised when file name cannot be rendered.""""""     testproj_path = Path(output_dir, 'testproject')     testproj_path.mkdir()      with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/file-name/',             output_dir=output_dir,             context=undefined_context,             overwrite_if_exists=True,         )     error = err.value     assert error.message == ""Unable to create file '{{cookiecutter.foobar}}'""     assert error.context == undefined_context      assert testproj_path.exists()   def test_raise_undefined_variable_file_content(output_dir, undefined_context) -> None:     """"""Verify correct error raised when file content cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/file-content/',             output_dir=output_dir,             context=undefined_context,         )     error = err.value     assert error.message == ""Unable to create file 'README.rst'""     assert error.context == undefined_context      assert not Path(output_dir).joinpath('testproject').exists()   def test_raise_undefined_variable_dir_name(output_dir, undefined_context) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=output_dir,             context=undefined_context,         )     error = err.value      directory = Path('testproject', '{{cookiecutter.foobar}}')     msg = f""Unable to create directory '{directory}'""     assert msg == error.message      assert error.context == undefined_context      assert not Path(output_dir).joinpath('testproject').exists()   def test_keep_project_dir_on_failure(output_dir, undefined_context) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate):         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=output_dir,             context=undefined_context,             keep_project_on_failure=True,         )     assert Path(output_dir).joinpath('testproject').exists()   def test_raise_undefined_variable_dir_name_existing_project(     output_dir, undefined_context ) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     testproj_path = Path(output_dir, 'testproject')     testproj_path.mkdir()      with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=output_dir,             context=undefined_context,             overwrite_if_exists=True,         )     error = err.value      directory = Path('testproject', '{{cookiecutter.foobar}}')     msg = f""Unable to create directory '{directory}'""     assert msg == error.message      assert error.context == undefined_context      assert testproj_path.exists()   def test_raise_undefined_variable_project_dir(tmp_path) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=tmp_path,             context={},         )     error = err.value     msg = ""Unable to create project directory '{{cookiecutter.project_slug}}'""     assert msg == error.message     assert error.context == {}      assert not Path(tmp_path, 'testproject').exists()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_files.py,test_generate_files.py_chunk1,"assert not Path(output_dir).joinpath('testproject').exists()   def test_keep_project_dir_on_failure(output_dir, undefined_context) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate):         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=output_dir,             context=undefined_context,             keep_project_on_failure=True,         )     assert Path(output_dir).joinpath('testproject').exists()   def test_raise_undefined_variable_dir_name_existing_project(     output_dir, undefined_context ) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     testproj_path = Path(output_dir, 'testproject')     testproj_path.mkdir()      with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=output_dir,             context=undefined_context,             overwrite_if_exists=True,         )     error = err.value      directory = Path('testproject', '{{cookiecutter.foobar}}')     msg = f""Unable to create directory '{directory}'""     assert msg == error.message      assert error.context == undefined_context      assert testproj_path.exists()   def test_raise_undefined_variable_project_dir(tmp_path) -> None:     """"""Verify correct error raised when directory name cannot be rendered.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         generate.generate_files(             repo_dir='tests/undefined-variable/dir-name/',             output_dir=tmp_path,             context={},         )     error = err.value     msg = ""Unable to create project directory '{{cookiecutter.project_slug}}'""     assert msg == error.message     assert error.context == {}      assert not Path(tmp_path, 'testproject').exists()   def test_raise_empty_dir_name(output_dir, undefined_context):     """"""Verify correct error raised when directory name is empty.""""""     with pytest.raises(exceptions.EmptyDirNameException):         generate.render_and_create_dir(             dirname='',             output_dir=output_dir,             context=undefined_context,             environment=Environment(autoescape=True),         )     assert not Path(output_dir).joinpath('testproject').exists()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_generate_hooks.py,test_generate_hooks.py_chunk0,"""""""Test work of python and shell hooks for generated projects.""""""  import errno import os import sys from pathlib import Path  import pytest  from cookiecutter import generate, utils from cookiecutter.exceptions import FailedHookException  WINDOWS = sys.platform.startswith('win')   @pytest.fixture(scope='function') def remove_additional_folders(tmp_path):     """"""Remove some special folders which are created by the tests.""""""     yield     directories_to_delete = [         'tests/test-pyhooks/inputpyhooks',         'inputpyhooks',         'inputhooks',         tmp_path.joinpath('test-shellhooks'),         'tests/test-hooks',     ]     for directory in directories_to_delete:         if os.path.exists(directory):             utils.rmtree(directory)   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_ignore_hooks_dirs() -> None:     """"""Verify hooks directory not created in target location on files generation.""""""     generate.generate_files(         context={'cookiecutter': {'pyhooks': 'pyhooks'}},         repo_dir='tests/test-pyhooks/',         output_dir='tests/test-pyhooks/',     )     assert not os.path.exists('tests/test-pyhooks/inputpyhooks/hooks')   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_python_hooks() -> None:     """"""Verify pre and post generation python hooks executed and result in output_dir.      Each hook should create in target directory. Test verifies that these files     created.     """"""     generate.generate_files(         context={'cookiecutter': {'pyhooks': 'pyhooks'}},         repo_dir='tests/test-pyhooks/',         output_dir='tests/test-pyhooks/',     )     assert os.path.exists('tests/test-pyhooks/inputpyhooks/python_pre.txt')     assert os.path.exists('tests/test-pyhooks/inputpyhooks/python_post.txt')   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_python_hooks_cwd() -> None:     """"""Verify pre and post generation python hooks executed and result in current dir.      Each hook should create in target directory. Test verifies that these files     created.     """"""     generate.generate_files(         context={'cookiecutter': {'pyhooks': 'pyhooks'}}, repo_dir='tests/test-pyhooks/'     )     assert os.path.exists('inputpyhooks/python_pre.txt')     assert os.path.exists('inputpyhooks/python_post.txt')   @pytest.mark.skipif(WINDOWS, reason='OSError.errno=8 is not thrown on Windows') @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_empty_hooks() -> None:     """"""Verify error is raised on empty hook script. Ignored on windows.      OSError.errno=8 is not thrown on Windows when the script is empty     because it always runs through shell instead of needing a shebang.     """"""     with pytest.raises(FailedHookException) as excinfo:         generate.generate_files(             context={'cookiecutter': {'shellhooks': 'shellhooks'}},             repo_dir='tests/test-shellhooks-empty/',             overwrite_if_exists=True,         )     assert 'shebang' in str(excinfo.value)   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_oserror_hooks(mocker) -> None:     """"""Verify script error passed correctly to cookiecutter error.      Here subprocess.Popen function mocked, ie we do not call hook script,     just produce expected error.     """"""     message = 'Out of memory'      err = OSError(message)     err.errno = errno.ENOMEM      prompt = mocker.patch('subprocess.Popen')     prompt.side_effect = err      with pytest.raises(FailedHookException) as excinfo:         generate.generate_files(             context={'cookiecutter': {'shellhooks': 'shellhooks'}},             repo_dir='tests/test-shellhooks-empty/',             overwrite_if_exists=True,         )     assert message in str(excinfo.value)   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_failing_hook_removes_output_directory() -> None:     """"""Verify project directory not created or removed if hook failed.""""""     repo_path = os.path.abspath('tests/test-hooks/')     hooks_path = os.path.abspath('tests/test-hooks/hooks')      hook_dir = os.path.join(repo_path, 'hooks')     template = os.path.join(repo_path, 'input{{cookiecutter.hooks}}')     os.mkdir(repo_path)     os.mkdir(hook_dir)     os.mkdir(template)      hook_path = os.path.join(hooks_path, 'pre_gen_project.py')      with Path(hook_path).open('w') as f:         f.write(""#!/usr/bin/env python\n"")         f.write(""import sys; sys.exit(1)\n"")      with pytest.raises(FailedHookException) as excinfo:         generate.generate_files(             context={'cookiecutter': {'hooks': 'hooks'}},             repo_dir='tests/test-hooks/',             overwrite_if_exists=True,         )      assert 'Hook script failed' in str(excinfo.value)     assert not os.path.exists('inputhooks')   @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_failing_hook_preserves_existing_output_directory() -> None:     """"""Verify project directory not removed if exist before hook failed.""""""     repo_path = os.path.abspath('tests/test-hooks/')     hooks_path = os.path.abspath('tests/test-hooks/hooks')      hook_dir = os.path.join(repo_path, 'hooks')     template = os.path.join(repo_path, 'input{{cookiecutter.hooks}}')     os.mkdir(repo_path)     os.mkdir(hook_dir)     os.mkdir(template)      hook_path = os.path.join(hooks_path, 'pre_gen_project.py')      with Path(hook_path).open('w') as f:         f.write(""#!/usr/bin/env python\n"")         f.write(""import sys; sys.exit(1)\n"")      os.mkdir('inputhooks')     with pytest.raises(FailedHookException) as excinfo:         generate.generate_files(             context={'cookiecutter': {'hooks': 'hooks'}},             repo_dir='tests/test-hooks/',             overwrite_if_exists=True,         )      assert 'Hook script failed' in str(excinfo.value)     assert os.path.exists('inputhooks')   @pytest.mark.skipif(sys.platform.startswith('win'), reason=""Linux only test"") @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_shell_hooks(tmp_path) -> None:     """"""Verify pre and post generate project shell hooks executed.      This test for .sh files.     """"""     generate.generate_files(         context={'cookiecutter': {'shellhooks': 'shellhooks'}},         repo_dir='tests/test-shellhooks/',         output_dir=tmp_path.joinpath('test-shellhooks'),     )     shell_pre_file = tmp_path.joinpath(         'test-shellhooks', 'inputshellhooks', 'shell_pre.txt'     )     shell_post_file = tmp_path.joinpath(         'test-shellhooks', 'inputshellhooks', 'shell_post.txt'     )     assert shell_pre_file.exists()     assert shell_post_file.exists()   @pytest.mark.skipif(not sys.platform.startswith('win'), reason=""Win only test"") @pytest.mark.usefixtures('clean_system', 'remove_additional_folders') def test_run_shell_hooks_win(tmp_path) -> None:     """"""Verify pre and post generate project shell hooks executed.      This test for .bat files.     """"""     generate.generate_files(         context={'cookiecutter': {'shellhooks': 'shellhooks'}},         repo_dir='tests/test-shellhooks-win/',         output_dir=tmp_path.joinpath('test-shellhooks-win'),     )     shell_pre_file = tmp_path.joinpath(         'test-shellhooks-win', 'inputshellhooks', 'shell_pre.txt'     )     shell_post_file = tmp_path.joinpath(         'test-shellhooks-win', 'inputshellhooks', 'shell_post.txt'     )     assert shell_pre_file.exists()     assert shell_post_file.exists()   @pytest.mark.usefixtures(""clean_system"", ""remove_additional_folders"") def test_ignore_shell_hooks(tmp_path) -> None:     """"""Verify *.txt files not created, when accept_hooks=False.""""""     generate.generate_files(         context={""cookiecutter"": {""shellhooks"": ""shellhooks""}},         repo_dir=""tests/test-shellhooks/"",         output_dir=tmp_path.joinpath('test-shellhooks'),         accept_hooks=False,     )     shell_pre_file = tmp_path.joinpath(""test-shellhooks/inputshellhooks/shell_pre.txt"")     shell_post_file = tmp_path.joinpath(         ""test-shellhooks/inputshellhooks/shell_post.txt""     )     assert not shell_pre_file.exists()     assert not shell_post_file.exists()   @pytest.mark.usefixtures(""clean_system"", ""remove_additional_folders"") def test_deprecate_run_hook_from_repo_dir(tmp_path) -> None:     """"""Test deprecation warning in generate._run_hook_from_repo_dir.""""""     repo_dir = ""tests/test-shellhooks/""     project_dir = Path(tmp_path.joinpath('test-shellhooks'))     project_dir.mkdir()     with pytest.deprecated_call():         generate._run_hook_from_repo_dir(             repo_dir=repo_dir,             hook_name=""pre_gen_project"",             project_dir=project_dir,             context={},             delete_project_on_failure=False,         )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_get_config.py,test_get_config.py_chunk0,"""""""Collection of tests around loading cookiecutter config.""""""  from pathlib import Path  import pytest import yaml  from cookiecutter import config from cookiecutter.exceptions import ConfigDoesNotExistException, InvalidConfiguration   def test_merge_configs() -> None:     """"""Verify default and user config merged in expected way.""""""     default = {         'cookiecutters_dir': '/home/example/some-path-to-templates',         'replay_dir': '/home/example/some-path-to-replay-files',         'default_context': {},         'abbreviations': {             'gh': 'https://github.com/{0}.git',             'gl': 'https://gitlab.com/{0}.git',             'bb': 'https://bitbucket.org/{0}',         },     }      user_config = {         'default_context': {             'full_name': 'Raphael Pierzina',             'github_username': 'hackebrot',         },         'abbreviations': {             'gl': 'https://gitlab.com/hackebrot/{0}.git',             'pytest-plugin': 'https://github.com/pytest-dev/pytest-plugin.git',         },     }      expected_config = {         'cookiecutters_dir': '/home/example/some-path-to-templates',         'replay_dir': '/home/example/some-path-to-replay-files',         'default_context': {             'full_name': 'Raphael Pierzina',             'github_username': 'hackebrot',         },         'abbreviations': {             'gh': 'https://github.com/{0}.git',             'gl': 'https://gitlab.com/hackebrot/{0}.git',             'bb': 'https://bitbucket.org/{0}',             'pytest-plugin': 'https://github.com/pytest-dev/pytest-plugin.git',         },     }      assert config.merge_configs(default, user_config) == expected_config   def test_get_config() -> None:     """"""Verify valid config opened and rendered correctly.""""""     conf = config.get_config('tests/test-config/valid-config.yaml')     expected_conf = {         'cookiecutters_dir': '/home/example/some-path-to-templates',         'replay_dir': '/home/example/some-path-to-replay-files',         'default_context': {             'full_name': 'Firstname Lastname',             'email': 'firstname.lastname@gmail.com',             'github_username': 'example',             'project': {                 'description': 'description',                 'tags': [                     'first',                     'second',                     'third',                 ],             },         },         'abbreviations': {             'gh': 'https://github.com/{0}.git',             'gl': 'https://gitlab.com/{0}.git',             'bb': 'https://bitbucket.org/{0}',             'helloworld': 'https://github.com/hackebrot/helloworld',         },     }     assert conf == expected_conf   def test_get_config_does_not_exist() -> None:     """"""Check that `exceptions.ConfigDoesNotExistException` is raised when \     attempting to get a non-existent config file.""""""     expected_error_msg = 'Config file tests/not-exist.yaml does not exist.'     with pytest.raises(ConfigDoesNotExistException) as exc_info:         config.get_config('tests/not-exist.yaml')     assert str(exc_info.value) == expected_error_msg   def test_invalid_config() -> None:     """"""An invalid config file should raise an `InvalidConfiguration` \     exception.""""""     expected_error_msg = (         'Unable to parse YAML file tests/test-config/invalid-config.yaml.'     )     with pytest.raises(InvalidConfiguration) as exc_info:         config.get_config('tests/test-config/invalid-config.yaml')         assert expected_error_msg in str(exc_info.value)         assert isinstance(exc_info.value.__cause__, yaml.YAMLError)   def test_get_config_with_defaults() -> None:     """"""A config file that overrides 1 of 3 defaults.""""""     conf = config.get_config('tests/test-config/valid-partial-config.yaml')     default_cookiecutters_dir = Path('~/.cookiecutters').expanduser()     default_replay_dir = Path('~/.cookiecutter_replay').expanduser()     expected_conf = {         'cookiecutters_dir': str(default_cookiecutters_dir),         'replay_dir': str(default_replay_dir),         'default_context': {             'full_name': 'Firstname Lastname',             'email': 'firstname.lastname@gmail.com',             'github_username': 'example',         },         'abbreviations': {             'gh': 'https://github.com/{0}.git',             'gl': 'https://gitlab.com/{0}.git',             'bb': 'https://bitbucket.org/{0}',         },     }     assert conf == expected_conf   def test_get_config_empty_config_file() -> None:     """"""An empty config file results in the default config.""""""     conf = config.get_config('tests/test-config/empty-config.yaml')     assert conf == config.DEFAULT_CONFIG   def test_get_config_invalid_file_with_array_as_top_level_element() -> None:     """"""An exception should be raised if top-level element is array.""""""     expected_error_msg = (         'Top-level element of YAML file '         'tests/test-config/invalid-config-w-array.yaml should be an object.'     )     with pytest.raises(InvalidConfiguration) as exc_info:         config.get_config('tests/test-config/invalid-config-w-array.yaml')     assert expected_error_msg in str(exc_info.value)   def test_get_config_invalid_file_with_multiple_docs() -> None:     """"""An exception should be raised if config file contains multiple docs.""""""     expected_error_msg = (         'Unable to parse YAML file '         'tests/test-config/invalid-config-w-multiple-docs.yaml.'     )     with pytest.raises(InvalidConfiguration) as exc_info:         config.get_config('tests/test-config/invalid-config-w-multiple-docs.yaml')     assert expected_error_msg in str(exc_info.value)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_get_user_config.py,test_get_user_config.py_chunk0,"""""""Tests to verify correct work with user configs and system/user variables inside.""""""  import os import shutil  import pytest  from cookiecutter import config from cookiecutter.exceptions import InvalidConfiguration   @pytest.fixture(scope='module') def user_config_path():     """"""Fixture. Return user config path for current user.""""""     return os.path.expanduser('~/.cookiecutterrc')   @pytest.fixture(scope='function') def back_up_rc(user_config_path):     """"""     Back up an existing cookiecutter rc and restore it after the test.      If ~/.cookiecutterrc is pre-existing, move it to a temp location     """"""     user_config_path_backup = os.path.expanduser('~/.cookiecutterrc.backup')      if os.path.exists(user_config_path):         shutil.copy(user_config_path, user_config_path_backup)         os.remove(user_config_path)      yield     # Remove the ~/.cookiecutterrc that has been created in the test.     if os.path.exists(user_config_path):         os.remove(user_config_path)      # If it existed, restore the original ~/.cookiecutterrc.     if os.path.exists(user_config_path_backup):         shutil.copy(user_config_path_backup, user_config_path)         os.remove(user_config_path_backup)   @pytest.fixture def custom_config():     """"""Fixture. Return expected custom configuration for future tests validation.""""""     return {         'default_context': {             'full_name': 'Firstname Lastname',             'email': 'firstname.lastname@gmail.com',             'github_username': 'example',             'project': {                 'description': 'description',                 'tags': [                     'first',                     'second',                     'third',                 ],             },         },         'cookiecutters_dir': '/home/example/some-path-to-templates',         'replay_dir': '/home/example/some-path-to-replay-files',         'abbreviations': {             'gh': 'https://github.com/{0}.git',             'gl': 'https://gitlab.com/{0}.git',             'bb': 'https://bitbucket.org/{0}',             'helloworld': 'https://github.com/hackebrot/helloworld',         },     }   @pytest.mark.usefixtures('back_up_rc') def test_get_user_config_valid(user_config_path, custom_config) -> None:     """"""Validate user config correctly parsed if exist and correctly formatted.""""""     shutil.copy('tests/test-config/valid-config.yaml', user_config_path)     conf = config.get_user_config()      assert conf == custom_config   @pytest.mark.usefixtures('back_up_rc') def test_get_user_config_invalid(user_config_path) -> None:     """"""Validate `InvalidConfiguration` raised when provided user config malformed.""""""     shutil.copy('tests/test-config/invalid-config.yaml', user_config_path)     with pytest.raises(InvalidConfiguration):         config.get_user_config()   @pytest.mark.usefixtures('back_up_rc') def test_get_user_config_nonexistent() -> None:     """"""Validate default app config returned, if user does not have own config.""""""     assert config.get_user_config() == config.DEFAULT_CONFIG   @pytest.fixture def custom_config_path() -> str:     """"""Fixture. Return path to custom user config for tests.""""""     return 'tests/test-config/valid-config.yaml'   def test_specify_config_path(mocker, custom_config_path, custom_config) -> None:     """"""Validate provided custom config path should be respected and parsed.""""""     spy_get_config = mocker.spy(config, 'get_config')      user_config = config.get_user_config(custom_config_path)     spy_get_config.assert_called_once_with(custom_config_path)      assert user_config == custom_config   def test_default_config_path(user_config_path) -> None:     """"""Validate app configuration. User config path should match default path.""""""     assert user_config_path == config.USER_CONFIG_PATH   def test_default_config_from_env_variable(     monkeypatch, custom_config_path, custom_config ) -> None:     """"""Validate app configuration. User config path should be parsed from sys env.""""""     monkeypatch.setenv('COOKIECUTTER_CONFIG', custom_config_path)      user_config = config.get_user_config()     assert user_config == custom_config   def test_force_default_config(mocker, custom_config_path) -> None:     """"""Validate `default_config=True` should ignore provided custom user config.""""""     spy_get_config = mocker.spy(config, 'get_config')      user_config = config.get_user_config(custom_config_path, default_config=True)      assert user_config == config.DEFAULT_CONFIG     assert not spy_get_config.called   def test_expand_user_for_directories_in_config(monkeypatch) -> None:     """"""Validate user pointers expanded in user configs.""""""      def _expanduser(path):         return path.replace('~', 'Users/bob')      monkeypatch.setattr('os.path.expanduser', _expanduser)      config_file = 'tests/test-config/config-expand-user.yaml'      user_config = config.get_user_config(config_file)     assert user_config['replay_dir'] == 'Users/bob/replay-files'     assert user_config['cookiecutters_dir'] == 'Users/bob/templates'   def test_expand_vars_for_directories_in_config(monkeypatch) -> None:     """"""Validate environment variables expanded in user configs.""""""     monkeypatch.setenv('COOKIES', 'Users/bob/cookies')      config_file = 'tests/test-config/config-expand-vars.yaml'      user_config = config.get_user_config(config_file)     assert user_config['replay_dir'] == 'Users/bob/cookies/replay-files'     assert user_config['cookiecutters_dir'] == 'Users/bob/cookies/templates'   def test_specify_config_values() -> None:     """"""Validate provided custom config values should be respected.""""""     replay_dir = 'Users/bob/cookies/custom-replay-dir'     custom_config_updated = {**config.DEFAULT_CONFIG, 'replay_dir': replay_dir}      user_config = config.get_user_config(default_config={'replay_dir': replay_dir})      assert user_config == custom_config_updated"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_hooks.py,test_hooks.py_chunk0,"""""""Tests for `cookiecutter.hooks` module.""""""  import errno import os import stat import sys import textwrap from pathlib import Path  import pytest  from cookiecutter import exceptions, hooks, utils   def make_test_repo(name: str, multiple_hooks: bool = False) -> str:     """"""Create test repository for test setup methods.""""""     hook_dir = os.path.join(name, 'hooks')     template = os.path.join(name, 'input{{hooks}}')     os.mkdir(name)     os.mkdir(hook_dir)     os.mkdir(template)      Path(template, 'README.rst').write_text(""foo\n===\n\nbar\n"")      with Path(hook_dir, 'pre_gen_project.py').open('w') as f:         f.write(""#!/usr/bin/env python\n"")         f.write(""# -*- coding: utf-8 -*-\n"")         f.write(""from __future__ import print_function\n"")         f.write(""\n"")         f.write(""print('pre generation hook')\n"")         f.write(""f = open('python_pre.txt', 'w')\n"")         f.write(""f.close()\n"")      if sys.platform.startswith('win'):         post = 'post_gen_project.bat'         with Path(hook_dir, post).open('w') as f:             f.write(""@echo off\n"")             f.write(""\n"")             f.write(""echo post generation hook\n"")             f.write(""echo. >shell_post.txt\n"")     else:         post = 'post_gen_project.sh'         filename = os.path.join(hook_dir, post)         with Path(filename).open('w') as f:             f.write(""#!/bin/bash\n"")             f.write(""\n"")             f.write(""echo 'post generation hook';\n"")             f.write(""touch 'shell_post.txt'\n"")         # Set the execute bit         os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)      # Adding an additional pre script     if multiple_hooks:         if sys.platform.startswith('win'):             pre = 'pre_gen_project.bat'             with Path(hook_dir, pre).open('w') as f:                 f.write(""@echo off\n"")                 f.write(""\n"")                 f.write(""echo post generation hook\n"")                 f.write(""echo. >shell_pre.txt\n"")         else:             pre = 'pre_gen_project.sh'             filename = os.path.join(hook_dir, pre)             with Path(filename).open('w') as f:                 f.write(""#!/bin/bash\n"")                 f.write(""\n"")                 f.write(""echo 'post generation hook';\n"")                 f.write(""touch 'shell_pre.txt'\n"")             # Set the execute bit             os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)      return post   class TestFindHooks:     """"""Class to unite find hooks related tests in one place.""""""      repo_path = 'tests/test-hooks'      def setup_method(self, _method) -> None:         """"""Find hooks related tests setup fixture.""""""         self.post_hook = make_test_repo(self.repo_path)      def teardown_method(self, _method) -> None:         """"""Find hooks related tests teardown fixture.""""""         utils.rmtree(self.repo_path)      def test_find_hook(self) -> None:         """"""Finds the specified hook.""""""         with utils.work_in(self.repo_path):             expected_pre = os.path.abspath('hooks/pre_gen_project.py')             actual_hook_path = hooks.find_hook('pre_gen_project')             assert actual_hook_path             assert expected_pre == actual_hook_path[0]              expected_post = os.path.abspath(f'hooks/{self.post_hook}')             actual_hook_path = hooks.find_hook('post_gen_project')             assert actual_hook_path             assert expected_post == actual_hook_path[0]      def test_no_hooks(self) -> None:         """"""`find_hooks` should return None if the hook could not be found.""""""         with utils.work_in('tests/fake-repo'):             assert None is hooks.find_hook('pre_gen_project')      def test_unknown_hooks_dir(self) -> None:         """"""`find_hooks` should return None if hook directory not found.""""""         with utils.work_in(self.repo_path):             assert hooks.find_hook('pre_gen_project', hooks_dir='hooks_dir') is None      def test_hook_not_found(self) -> None:         """"""`find_hooks` should return None if the hook could not be found.""""""         with utils.work_in(self.repo_path):             assert hooks.find_hook('unknown_hook') is None   class TestExternalHooks:     """"""Class to unite tests for hooks with different project paths.""""""      repo_path = os.path.abspath('tests/test-hooks/')     hooks_path = os.path.abspath('tests/test-hooks/hooks')      def setup_method(self, _method) -> None:         """"""External hooks related tests setup fixture.""""""         self.post_hook = make_test_repo(self.repo_path, multiple_hooks=True)      def teardown_method(self, _method) -> None:         """"""External hooks related tests teardown fixture.""""""         utils.rmtree(self.repo_path)          if os.path.exists('python_pre.txt'):             os.remove('python_pre.txt')         if os.path.exists('shell_post.txt'):             os.remove('shell_post.txt')         if os.path.exists('shell_pre.txt'):             os.remove('shell_pre.txt')         if os.path.exists('tests/shell_post.txt'):             os.remove('tests/shell_post.txt')         if os.path.exists('tests/test-hooks/input{{hooks}}/python_pre.txt'):             os.remove('tests/test-hooks/input{{hooks}}/python_pre.txt')         if os.path.exists('tests/test-hooks/input{{hooks}}/shell_post.txt'):             os.remove('tests/test-hooks/input{{hooks}}/shell_post.txt')         if os.path.exists('tests/context_post.txt'):             os.remove('tests/context_post.txt')      def test_run_script(self) -> None:         """"""Execute a hook script, independently of project generation.""""""         hooks.run_script(os.path.join(self.hooks_path, self.post_hook))         assert os.path.isfile('shell_post.txt')      def test_run_failing_script(self, mocker) -> None:         """"""Test correct exception raise if run_script fails.""""""         err = OSError()          prompt = mocker.patch('subprocess.Popen')         prompt.side_effect = err          with pytest.raises(exceptions.FailedHookException) as excinfo:             hooks.run_script(os.path.join(self.hooks_path, self.post_hook))         assert f'Hook script failed (error: {err})' in str(excinfo.value)      def test_run_failing_script_enoexec(self, mocker) -> None:         """"""Test correct exception raise if run_script fails.""""""         err = OSError()         err.errno = errno.ENOEXEC          prompt = mocker.patch('subprocess.Popen')         prompt.side_effect = err          with pytest.raises(exceptions.FailedHookException) as excinfo:             hooks.run_script(os.path.join(self.hooks_path, self.post_hook))         assert 'Hook script failed, might be an empty file or missing a shebang' in str(             excinfo.value         )      def test_run_script_cwd(self) -> None:         """"""Change directory before running hook.""""""         hooks.run_script(os.path.join(self.hooks_path, self.post_hook), 'tests')         assert os.path.isfile('tests/shell_post.txt')         assert 'tests' not in os.getcwd()      def test_run_script_with_context(self) -> None:         """"""Execute a hook script, passing a context.""""""         hook_path = os.path.join(self.hooks_path, 'post_gen_project.sh')          if sys.platform.startswith('win'):             post = 'post_gen_project.bat'             with Path(self.hooks_path, post).open('w') as f:                 f.write(""@echo off\n"")                 f.write(""\n"")                 f.write(""echo post generation hook\n"")                 f.write(""echo. >{{cookiecutter.file}}\n"")         else:             with Path(hook_path).open('w') as fh:                 fh.write(""#!/bin/bash\n"")                 fh.write(""\n"")                 fh.write(""echo 'post generation hook';\n"")                 fh.write(""touch 'shell_post.txt'\n"")                 fh.write(""touch '{{cookiecutter.file}}'\n"")                 os.chmod(hook_path, os.stat(hook_path).st_mode | stat.S_IXUSR)          hooks.run_script_with_context(             os.path.join(self.hooks_path, self.post_hook),             'tests',             {'cookiecutter': {'file': 'context_post.txt'}},         )         assert os.path.isfile('tests/context_post.txt')         assert 'tests' not in os.getcwd()      def test_run_hook(self) -> None:         """"""Execute hook from specified template in specified output \         directory.""""""         tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')         with utils.work_in(self.repo_path):             hooks.run_hook('pre_gen_project', tests_dir, {})             assert os.path.isfile(os.path.join(tests_dir, 'python_pre.txt'))             assert os.path.isfile(os.path.join(tests_dir, 'shell_pre.txt'))              hooks.run_hook('post_gen_project', tests_dir, {})             assert os.path.isfile(os.path.join(tests_dir, 'shell_post.txt'))      def test_run_failing_hook(self) -> None:         """"""Test correct exception raise if hook exit code is not zero.""""""         hook_path = os.path.join(self.hooks_path, 'pre_gen_project.py')         tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')          with Path(hook_path).open('w') as f:             f.write(""#!/usr/bin/env python\n"")             f.write(""import sys; sys.exit(1)\n"")          with utils.work_in(self.repo_path):             with pytest.raises(exceptions.FailedHookException) as excinfo:                 hooks.run_hook('pre_gen_project', tests_dir, {})             assert 'Hook script failed' in str(excinfo.value)   @pytest.fixture() def dir_with_hooks(tmp_path):     """"""Yield a directory that contains hook backup files.""""""     hooks_dir = tmp_path.joinpath('hooks')     hooks_dir.mkdir()      pre_hook_content = textwrap.dedent(         """"""         #!/usr/bin/env python         # -*- coding: utf-8 -*-         print('pre_gen_project.py~')         """"""     )     pre_gen_hook_file = hooks_dir.joinpath('pre_gen_project.py~')     pre_gen_hook_file.write_text(pre_hook_content, encoding='utf8')      post_hook_content = textwrap.dedent(         """"""         #!/usr/bin/env python         # -*- coding: utf-8 -*-         print('post_gen_project.py~')         """"""     )      post_gen_hook_file = hooks_dir.joinpath('post_gen_project.py~')     post_gen_hook_file.write_text(post_hook_content, encoding='utf8')      # Make sure to yield the parent directory as `find_hooks()`     # looks into `hooks/` in the current working directory     yield str(tmp_path)      pre_gen_hook_file.unlink()     post_gen_hook_file.unlink()   def test_ignore_hook_backup_files(monkeypatch, dir_with_hooks) -> None:     """"""Test `find_hook` correctly use `valid_hook` verification function.""""""     # Change the current working directory that contains `hooks/`     monkeypatch.chdir(dir_with_hooks)     assert hooks.find_hook('pre_gen_project') is None     assert hooks.find_hook('post_gen_project') is None"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_log.py,test_log.py_chunk0,"""""""Collection of tests around log handling.""""""  import logging  import pytest  from cookiecutter.log import configure_logger   def create_log_records() -> None:     """"""Test function, create log entries in expected stage of test.""""""     cookiecutter_logger = logging.getLogger('cookiecutter')     foo_logger = logging.getLogger('cookiecutter.foo')     foobar_logger = logging.getLogger('cookiecutter.foo.bar')      cookiecutter_logger.info('Welcome to Cookiecutter')     cookiecutter_logger.debug('Generating project from pytest-plugin')     foo_logger.info('Loading user config from home dir')     foobar_logger.debug(""I don't know."")     foobar_logger.debug('I wanted to save the world.')     foo_logger.error('Aw, snap! Something went wrong')     cookiecutter_logger.debug('Successfully generated project')   @pytest.fixture def info_messages():     """"""Fixture. List of test info messages.""""""     return [         'INFO: Welcome to Cookiecutter',         'INFO: Loading user config from home dir',         'ERROR: Aw, snap! Something went wrong',     ]   @pytest.fixture def debug_messages():     """"""Fixture. List of test debug messages.""""""     return [         ""INFO cookiecutter: Welcome to Cookiecutter"",         ""DEBUG cookiecutter: Generating project from pytest-plugin"",         ""INFO cookiecutter.foo: Loading user config from home dir"",         ""DEBUG cookiecutter.foo.bar: I don't know."",         ""DEBUG cookiecutter.foo.bar: I wanted to save the world."",         ""ERROR cookiecutter.foo: Aw, snap! Something went wrong"",         ""DEBUG cookiecutter: Successfully generated project"",     ]   @pytest.fixture def info_logger():     """"""Fixture. Call cookiecutter logger setup with `info` debug level.""""""     return configure_logger(stream_level='INFO')   @pytest.fixture def debug_logger():     """"""Fixture. Call cookiecutter logger setup with `debug` debug level.""""""     return configure_logger(stream_level='DEBUG')   @pytest.fixture def debug_file(tmp_path):     """"""Fixture. Generate debug file location for tests.""""""     return tmp_path.joinpath('pytest-plugin.log')   @pytest.fixture def info_logger_with_file(debug_file):     """"""Fixture. Call cookiecutter logger setup with `info` debug level + `file`.""""""     return configure_logger(stream_level='INFO', debug_file=str(debug_file))   def test_info_stdout_logging(caplog, info_logger, info_messages) -> None:     """"""Test that stdout logs use info format and level.""""""     [stream_handler] = info_logger.handlers     assert isinstance(stream_handler, logging.StreamHandler)     assert stream_handler.level == logging.INFO      create_log_records()      stream_messages = [         stream_handler.format(r)         for r in caplog.records         if r.levelno >= stream_handler.level     ]      assert stream_messages == info_messages   def test_debug_stdout_logging(caplog, debug_logger, debug_messages) -> None:     """"""Test that stdout logs use debug format and level.""""""     [stream_handler] = debug_logger.handlers     assert isinstance(stream_handler, logging.StreamHandler)     assert stream_handler.level == logging.DEBUG      create_log_records()      stream_messages = [         stream_handler.format(r)         for r in caplog.records         if r.levelno >= stream_handler.level     ]      assert stream_messages == debug_messages   def test_debug_file_logging(info_logger_with_file, debug_file, debug_messages) -> None:     """"""Test that logging to stdout uses a different format and level than \     the the file handler.""""""     [file_handler, stream_handler] = info_logger_with_file.handlers     assert isinstance(file_handler, logging.FileHandler)     assert isinstance(stream_handler, logging.StreamHandler)     assert stream_handler.level == logging.INFO     assert file_handler.level == logging.DEBUG      create_log_records()      assert debug_file.exists()      # Last line in the log file is an empty line     with debug_file.open() as f:         assert f.read().split('\n') == [*debug_messages, '']"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_main.py,test_main.py_chunk0,"""""""Collection of tests around cookiecutter's replay feature.""""""  from cookiecutter.main import cookiecutter   def test_original_cookiecutter_options_preserved_in__cookiecutter(     monkeypatch,     mocker,     user_config_file, ) -> None:     """"""Preserve original context options.      Tests you can access the original context options via     `context['_cookiecutter']`.     """"""     monkeypatch.chdir('tests/fake-repo-tmpl-_cookiecutter')     mock_generate_files = mocker.patch('cookiecutter.main.generate_files')     cookiecutter(         '.',         no_input=True,         replay=False,         config_file=user_config_file,     )     assert mock_generate_files.call_args[1]['context']['_cookiecutter'][         'test_list'     ] == [1, 2, 3, 4]     assert mock_generate_files.call_args[1]['context']['_cookiecutter'][         'test_dict'     ] == {""foo"": ""bar""}   def test_replay_dump_template_name(     monkeypatch, mocker, user_config_data, user_config_file ) -> None:     """"""Check that replay_dump is called with a valid template_name.      Template name must not be a relative path.      Otherwise files such as ``..json`` are created, which are not just cryptic     but also later mistaken for replay files of other templates if invoked with     '.' and '--replay'.      Change the current working directory temporarily to 'tests/fake-repo-tmpl'     for this test and call cookiecutter with '.' for the target template.     """"""     monkeypatch.chdir('tests/fake-repo-tmpl')      mock_replay_dump = mocker.patch('cookiecutter.main.dump')     mocker.patch('cookiecutter.main.generate_files')      cookiecutter(         '.',         no_input=True,         replay=False,         config_file=user_config_file,     )      mock_replay_dump.assert_called_once_with(         user_config_data['replay_dir'],         'fake-repo-tmpl',         mocker.ANY,     )   def test_replay_load_template_name(     monkeypatch, mocker, user_config_data, user_config_file ) -> None:     """"""Check that replay_load is called correctly.      Calls require valid template_name that is not a relative path.      Change the current working directory temporarily to 'tests/fake-repo-tmpl'     for this test and call cookiecutter with '.' for the target template.     """"""     monkeypatch.chdir('tests/fake-repo-tmpl')      mock_replay_load = mocker.patch('cookiecutter.main.load')     mocker.patch('cookiecutter.main.generate_context').return_value = {         'cookiecutter': {}     }     mocker.patch('cookiecutter.main.generate_files')     mocker.patch('cookiecutter.main.dump')      cookiecutter(         '.',         replay=True,         config_file=user_config_file,     )      mock_replay_load.assert_called_once_with(         user_config_data['replay_dir'],         'fake-repo-tmpl',     )   def test_custom_replay_file(monkeypatch, mocker, user_config_file) -> None:     """"""Check that reply.load is called with the custom replay_file.""""""     monkeypatch.chdir('tests/fake-repo-tmpl')      mock_replay_load = mocker.patch('cookiecutter.main.load')     mocker.patch('cookiecutter.main.generate_context').return_value = {         'cookiecutter': {}     }     mocker.patch('cookiecutter.main.generate_files')     mocker.patch('cookiecutter.main.dump')      cookiecutter(         '.',         replay='./custom-replay-file',         config_file=user_config_file,     )      mock_replay_load.assert_called_once_with(         '.',         'custom-replay-file',     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_output_folder.py,test_output_folder.py_chunk0,""""""" tests_output_folder.  Test formerly known from a unittest residing in test_generate.py named TestOutputFolder.test_output_folder """"""  import os from pathlib import Path  import pytest  from cookiecutter import exceptions, generate, utils   @pytest.fixture(scope='function') def remove_output_folder():     """"""Remove the output folder after test.""""""     yield     if os.path.exists('output_folder'):         utils.rmtree('output_folder')   @pytest.mark.usefixtures('clean_system', 'remove_output_folder') def test_output_folder() -> None:     """"""Tests should correctly create content, as output_folder does not yet exist.""""""     context = generate.generate_context(         context_file='tests/test-output-folder/cookiecutter.json'     )     generate.generate_files(context=context, repo_dir='tests/test-output-folder')      something = """"""Hi! My name is Audrey Greenfeld. It is 2014. """"""     something2 = Path('output_folder/something.txt').read_text()     assert something == something2      in_folder = ""The color is green and the letter is D.\n""     in_folder2 = Path('output_folder/folder/in_folder.txt').read_text()     assert in_folder == in_folder2      assert os.path.isdir('output_folder/im_a.dir')     assert os.path.isfile('output_folder/im_a.dir/im_a.file.py')   @pytest.mark.usefixtures('clean_system', 'remove_output_folder') def test_exception_when_output_folder_exists() -> None:     """"""Tests should raise error as output folder created before `generate_files`.""""""     context = generate.generate_context(         context_file='tests/test-output-folder/cookiecutter.json'     )     output_folder = context['cookiecutter']['test_name']      if not os.path.exists(output_folder):         os.makedirs(output_folder)     with pytest.raises(exceptions.OutputDirExistsException):         generate.generate_files(context=context, repo_dir='tests/test-output-folder')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_preferred_encoding.py,test_preferred_encoding.py_chunk0,"""""""Collection of tests around character encodings.""""""  import codecs import locale import sys  import pytest  PY3 = sys.version_info[0] == 3   @pytest.mark.skipif(not PY3, reason='Only necessary on Python3') def test_not_ascii() -> None:     """"""Make sure that the systems preferred encoding is not `ascii`.      Otherwise `click` is raising a RuntimeError for Python3. For a detailed     description of this very problem please consult the following gist:     https://gist.github.com/hackebrot/937245251887197ef542      This test also checks that `tox.ini` explicitly copies the according     system environment variables to the test environments.     """"""     try:         preferred_encoding = locale.getpreferredencoding()         fs_enc = codecs.lookup(preferred_encoding).name     except Exception:         fs_enc = 'ascii'     assert fs_enc != 'ascii'"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_pre_prompt_hooks.py,test_pre_prompt_hooks.py_chunk0,"""""""Test work of python and shell hooks on repository.""""""  import sys from pathlib import Path  import pytest  from cookiecutter import hooks, utils from cookiecutter.exceptions import FailedHookException  WINDOWS = sys.platform.startswith('win')   @pytest.fixture(scope='function') def remove_tmp_repo_dir():     """"""Remove the generate repo_dir.""""""      def _func(repo_dir: Path) -> None:         if repo_dir.exists():             utils.rmtree(repo_dir)      return _func   def test_run_pre_prompt_python_hook(remove_tmp_repo_dir) -> None:     """"""Verify pre_prompt.py runs and creates a copy of cookiecutter.json.""""""     new_repo_dir = hooks.run_pre_prompt_hook(repo_dir='tests/test-pyhooks/')     assert new_repo_dir.exists()  # type: ignore[union-attr]     bkp_config = new_repo_dir / ""_cookiecutter.json""  # type: ignore[operator]     assert bkp_config.exists()     remove_tmp_repo_dir(new_repo_dir)   def test_run_pre_prompt_python_hook_fail(monkeypatch) -> None:     """"""Verify pre_prompt.py will fail when a given env var is present.""""""     message = 'Pre-Prompt Hook script failed'     with monkeypatch.context() as m:         m.setenv('COOKIECUTTER_FAIL_PRE_PROMPT', '1')         with pytest.raises(FailedHookException) as excinfo:             hooks.run_pre_prompt_hook(repo_dir='tests/test-pyhooks/')     assert message in str(excinfo.value)   @pytest.mark.skipif(WINDOWS, reason='shell script will not run in Windows') def test_run_pre_prompt_shell_hook(remove_tmp_repo_dir) -> None:     """"""Verify pre_prompt.sh runs and creates a copy of cookiecutter.json.""""""     new_repo_dir = hooks.run_pre_prompt_hook(repo_dir='tests/test-pyshellhooks/')     assert new_repo_dir.exists()  # type: ignore[union-attr]     bkp_config = new_repo_dir / ""_cookiecutter.json""  # type: ignore[operator]     assert bkp_config.exists()     remove_tmp_repo_dir(new_repo_dir)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_prompt.py,test_prompt.py_chunk0,"""""""Tests for `cookiecutter.prompt` module.""""""  from __future__ import annotations  import json import platform import sys from collections import OrderedDict from pathlib import Path from typing import Any  import click import pytest  from cookiecutter import environment, exceptions, prompt   @pytest.fixture(autouse=True) def patch_readline_on_win(monkeypatch) -> None:     """"""Fixture. Overwrite windows end of line to linux standard.""""""     if 'windows' in platform.platform().lower():         monkeypatch.setattr('sys.stdin.readline', lambda: '\n')   class TestRenderVariable:     """"""Class to unite simple and complex tests for render_variable function.""""""      @pytest.mark.parametrize(         'raw_var, rendered_var',         [             (1, '1'),             (True, True),             ('foo', 'foo'),             ('{{cookiecutter.project}}', 'foobar'),             (None, None),         ],     )     def test_convert_to_str(self, mocker, raw_var, rendered_var) -> None:         """"""Verify simple items correctly rendered to strings.""""""         env = environment.StrictEnvironment()         from_string = mocker.patch(             'cookiecutter.utils.StrictEnvironment.from_string', wraps=env.from_string         )         context = {'project': 'foobar'}          result = prompt.render_variable(env, raw_var, context)         assert result == rendered_var          # Make sure that non None non str variables are converted beforehand         if raw_var is not None and not isinstance(raw_var, bool):             if not isinstance(raw_var, str):                 raw_var = str(raw_var)             from_string.assert_called_once_with(raw_var)         else:             assert not from_string.called      @pytest.mark.parametrize(         'raw_var, rendered_var',         [             ({1: True, 'foo': False}, {'1': True, 'foo': False}),             (                 {'{{cookiecutter.project}}': ['foo', 1], 'bar': False},                 {'foobar': ['foo', '1'], 'bar': False},             ),             (['foo', '{{cookiecutter.project}}', None], ['foo', 'foobar', None]),         ],     )     def test_convert_to_str_complex_variables(self, raw_var, rendered_var) -> None:         """"""Verify tree items correctly rendered.""""""         env = environment.StrictEnvironment()         context = {'project': 'foobar'}          result = prompt.render_variable(env, raw_var, context)         assert result == rendered_var   class TestPrompt:     """"""Class to unite user prompt related tests.""""""      @pytest.mark.parametrize(         'context',         [             {'cookiecutter': {'full_name': 'Your Name'}},             {'cookiecutter': {'full_name': 'Řekni či napiš své jméno'}},         ],         ids=['ASCII default prompt/input', 'Unicode default prompt/input'],     )     def test_prompt_for_config(self, monkeypatch, context) -> None:         """"""Verify `prompt_for_config` call `read_user_variable` on text request.""""""         monkeypatch.setattr(             'cookiecutter.prompt.read_user_variable',             lambda _var, default, _prompts, _prefix: default,         )          cookiecutter_dict = prompt.prompt_for_config(context)         assert cookiecutter_dict == context['cookiecutter']      @pytest.mark.parametrize(         'context',         [             {                 'cookiecutter': {                     'full_name': 'Your Name',                     'check': ['yes', 'no'],                     'nothing': 'ok',                     '__prompts__': {                         'full_name': 'Name please',                         'check': 'Checking',                     },                 }             },         ],         ids=['ASCII default prompt/input'],     )     def test_prompt_for_config_with_human_prompts(self, monkeypatch, context) -> None:         """"""Verify call `read_user_variable` on request when human-readable prompts.""""""         monkeypatch.setattr(             'cookiecutter.prompt.read_user_variable',             lambda _var, default, _prompts, _prefix: default,         )         monkeypatch.setattr(             'cookiecutter.prompt.read_user_yes_no',             lambda _var, default, _prompts, _prefix: default,         )         monkeypatch.setattr(             'cookiecutter.prompt.read_user_choice',             lambda _var, default, _prompts, _prefix: default,         )          cookiecutter_dict = prompt.prompt_for_config(context)         assert cookiecutter_dict == context['cookiecutter']      @pytest.mark.parametrize(         'context',         [             {                 'cookiecutter': {                     'full_name': 'Your Name',                     'check': ['yes', 'no'],                     '__prompts__': {                         'check': 'Checking',                     },                 }             },             {                 'cookiecutter': {                     'full_name': 'Your Name',                     'check': ['yes', 'no'],                     '__prompts__': {                         'full_name': 'Name please',                         'check': {'__prompt__': 'Checking', 'yes': 'Yes', 'no': 'No'},                     },                 }             },             {                 'cookiecutter': {                     'full_name': 'Your Name',                     'check': ['yes', 'no'],                     '__prompts__': {                         'full_name': 'Name please',                         'check': {'no': 'No'},                     },                 }             },         ],     )     def test_prompt_for_config_with_human_choices(self, context) -> None:         """"""Test prompts when human-readable labels for user choices.""""""         runner = click.testing.CliRunner()         with runner.isolation(input=""\n\n\n""):             cookiecutter_dict = prompt.prompt_for_config(context)          assert dict(cookiecutter_dict) == {'full_name': 'Your Name', 'check': 'yes'}      def test_prompt_for_config_dict(self, monkeypatch) -> None:         """"""Verify `prompt_for_config` call `read_user_variable` on dict request.""""""         monkeypatch.setattr(             'cookiecutter.prompt.read_user_dict',             lambda _var, _default, _prompts, _prefix: {""key"": ""value"", ""integer"": 37},         )         context: dict[str, Any] = {'cookiecutter': {'details': {}}}          cookiecutter_dict = prompt.prompt_for_config(context)         assert cookiecutter_dict == {'details': {'key': 'value', 'integer': 37}}      def test_should_render_dict(self) -> None:         """"""Verify template inside dictionary variable rendered.""""""         context = {             'cookiecutter': {                 'project_name': 'Slartibartfast',                 'details': {                     '{{cookiecutter.project_name}}': '{{cookiecutter.project_name}}'                 },             }         }          cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == {             'project_name': 'Slartibartfast',             'details': {'Slartibartfast': 'Slartibartfast'},         }      def test_should_render_deep_dict(self) -> None:         """"""Verify nested structures like dict in dict, rendered correctly.""""""         context = {             'cookiecutter': {                 'project_name': ""Slartibartfast"",                 'details': {                     ""key"": ""value"",                     ""integer_key"": 37,                     ""other_name"": '{{cookiecutter.project_name}}',                     ""dict_key"": {                         ""deep_key"": ""deep_value"",                         ""deep_integer"": 42,                         ""deep_other_name"": '{{cookiecutter.project_name}}',                         ""deep_list"": [                             ""deep value 1"",                             ""{{cookiecutter.project_name}}"",                             ""deep value 3"",                         ],                     },                     ""list_key"": [                         ""value 1"",                         ""{{cookiecutter.project_name}}"",                         ""value 3"",                     ],                 },             }         }          cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == {             'project_name': ""Slartibartfast"",             'details': {                 ""key"": ""value"",                 ""integer_key"": ""37"",                 ""other_name"": ""Slartibartfast"",                 ""dict_key"": {                     ""deep_key"": ""deep_value"",                     ""deep_integer"": ""42"",                     ""deep_other_name"": ""Slartibartfast"",                     ""deep_list"": [""deep value 1"", ""Slartibartfast"", ""deep value 3""],                 },                 ""list_key"": [""value 1"", ""Slartibartfast"", ""value 3""],             },         }      def test_should_render_deep_dict_with_human_prompts(self) -> None:         """"""Verify dict rendered correctly when human-readable prompts.""""""         context = {             'cookiecutter': {                 'project_name': ""Slartibartfast"",                 'details': {                     ""key"": ""value"",                     ""integer_key"": 37,                     ""other_name"": '{{cookiecutter.project_name}}',                     ""dict_key"": {                         ""deep_key"": ""deep_value"",                     },                 },                 '__prompts__': {'project_name': 'Project name'},             }         }         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == {             'project_name': ""Slartibartfast"",             'details': {                 ""key"": ""value"",                 ""integer_key"": ""37"",                 ""other_name"": ""Slartibartfast"",                 ""dict_key"": {                     ""deep_key"": ""deep_value"",                 },             },         }      def test_internal_use_no_human_prompts(self) -> None:         """"""Verify dict rendered correctly when human-readable prompts empty.""""""         context = {             'cookiecutter': {                 'project_name': ""Slartibartfast"",                 '__prompts__': {},             }         }         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == {             'project_name': ""Slartibartfast"",         }      def test_prompt_for_templated_config(self, monkeypatch) -> None:         """"""Verify Jinja2 templating works in unicode prompts.""""""         monkeypatch.setattr(             'cookiecutter.prompt.read_user_variable',             lambda _var, default, _prompts, _prefix: default,         )         context = {             'cookiecutter': OrderedDict(                 [                     ('project_name', 'A New Project'),                     (                         'pkg_name',                         '{{ cookiecutter.project_name|lower|replace("" "", """") }}',                     ),                 ]             )         }          exp_cookiecutter_dict = {             'project_name': 'A New Project',             'pkg_name': 'anewproject',         }         cookiecutter_dict = prompt.prompt_for_config(context)         assert cookiecutter_dict == exp_cookiecutter_dict      def test_dont_prompt_for_private_context_var(self, monkeypatch) -> None:         """"""Verify `read_user_variable` not called for private context variables.""""""         monkeypatch.setattr(             'cookiecutter.prompt.read_user_variable',             lambda _var, _default: pytest.fail(                 'Should not try to read a response for private context var'             ),         )         context = {'cookiecutter': {'_copy_without_render': ['*.html']}}         cookiecutter_dict = prompt.prompt_for_config(context)         assert cookiecutter_dict == {'_copy_without_render': ['*.html']}      def test_should_render_private_variables_with_two_underscores(self) -> None:         """"""Test rendering of private variables with two underscores.          There are three cases:         1. Variables beginning with a single underscore are private and not rendered.         2. Variables beginning with a double underscore are private and are rendered.         3. Variables beginning with anything other than underscores are not private and            are rendered.         """"""         context = {             'cookiecutter': OrderedDict(                 [                     ('foo', 'Hello world'),                     ('bar', 123),                     ('rendered_foo', '{{ cookiecutter.foo|lower }}'),                     ('rendered_bar', 123),                     ('_hidden_foo', '{{ cookiecutter.foo|lower }}'),                     ('_hidden_bar', 123),                     ('__rendered_hidden_foo', '{{ cookiecutter.foo|lower }}'),                     ('__rendered_hidden_bar', 123),                 ]             )         }         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == OrderedDict(             [                 ('foo', 'Hello world'),                 ('bar', '123'),                 ('rendered_foo', 'hello world'),                 ('rendered_bar', '123'),                 ('_hidden_foo', '{{ cookiecutter.foo|lower }}'),                 ('_hidden_bar', 123),                 ('__rendered_hidden_foo', 'hello world'),                 ('__rendered_hidden_bar', '123'),             ]         )      def test_should_not_render_private_variables(self) -> None:         """"""Verify private(underscored) variables not rendered by `prompt_for_config`.          Private variables designed to be raw, same as context input.         """"""         context = {             'cookiecutter': {                 'project_name': 'Skip render',                 '_skip_jinja_template': '{{cookiecutter.project_name}}',                 '_skip_float': 123.25,                 '_skip_integer': 123,                 '_skip_boolean': True,                 '_skip_nested': True,             }         }         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == context['cookiecutter']   DEFAULT_PREFIX = '  [dim][1/1][/] '   class TestReadUserChoice:     """"""Class to unite choices prompt related tests.""""""      def test_should_invoke_read_user_choice(self, mocker) -> None:         """"""Verify correct function called for select(list) variables.""""""         prompt_choice = mocker.patch(             'cookiecutter.prompt.prompt_choice_for_config',             wraps=prompt.prompt_choice_for_config,         )          read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')         read_user_choice.return_value = 'all'          read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')          choices = ['landscape', 'portrait', 'all']         context = {'cookiecutter': {'orientation': choices}}          cookiecutter_dict = prompt.prompt_for_config(context)          assert not read_user_variable.called         assert prompt_choice.called         read_user_choice.assert_called_once_with(             'orientation', choices, {}, DEFAULT_PREFIX         )         assert cookiecutter_dict == {'orientation': 'all'}      def test_should_invoke_read_user_variable(self, mocker) -> None:         """"""Verify correct function called for string input variables.""""""         read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')         read_user_variable.return_value = 'Audrey Roy'          prompt_choice = mocker.patch('cookiecutter.prompt.prompt_choice_for_config')          read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')          context = {'cookiecutter': {'full_name': 'Your Name'}}          cookiecutter_dict = prompt.prompt_for_config(context)          assert not prompt_choice.called         assert not read_user_choice.called         read_user_variable.assert_called_once_with(             'full_name', 'Your Name', {}, DEFAULT_PREFIX         )         assert cookiecutter_dict == {'full_name': 'Audrey Roy'}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_prompt.py,test_prompt.py_chunk1,"DEFAULT_PREFIX = '  [dim][1/1][/] '   class TestReadUserChoice:     """"""Class to unite choices prompt related tests.""""""      def test_should_invoke_read_user_choice(self, mocker) -> None:         """"""Verify correct function called for select(list) variables.""""""         prompt_choice = mocker.patch(             'cookiecutter.prompt.prompt_choice_for_config',             wraps=prompt.prompt_choice_for_config,         )          read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')         read_user_choice.return_value = 'all'          read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')          choices = ['landscape', 'portrait', 'all']         context = {'cookiecutter': {'orientation': choices}}          cookiecutter_dict = prompt.prompt_for_config(context)          assert not read_user_variable.called         assert prompt_choice.called         read_user_choice.assert_called_once_with(             'orientation', choices, {}, DEFAULT_PREFIX         )         assert cookiecutter_dict == {'orientation': 'all'}      def test_should_invoke_read_user_variable(self, mocker) -> None:         """"""Verify correct function called for string input variables.""""""         read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')         read_user_variable.return_value = 'Audrey Roy'          prompt_choice = mocker.patch('cookiecutter.prompt.prompt_choice_for_config')          read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')          context = {'cookiecutter': {'full_name': 'Your Name'}}          cookiecutter_dict = prompt.prompt_for_config(context)          assert not prompt_choice.called         assert not read_user_choice.called         read_user_variable.assert_called_once_with(             'full_name', 'Your Name', {}, DEFAULT_PREFIX         )         assert cookiecutter_dict == {'full_name': 'Audrey Roy'}      def test_should_render_choices(self, mocker) -> None:         """"""Verify Jinja2 templating engine works inside choices variables.""""""         read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')         read_user_choice.return_value = 'anewproject'          read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')         read_user_variable.return_value = 'A New Project'          rendered_choices = ['foo', 'anewproject', 'bar']          context = {             'cookiecutter': OrderedDict(                 [                     ('project_name', 'A New Project'),                     (                         'pkg_name',                         [                             'foo',                             '{{ cookiecutter.project_name|lower|replace("" "", """") }}',                             'bar',                         ],                     ),                 ]             )         }          expected = {             'project_name': 'A New Project',             'pkg_name': 'anewproject',         }         cookiecutter_dict = prompt.prompt_for_config(context)          read_user_variable.assert_called_once_with(             'project_name', 'A New Project', {}, '  [dim][1/2][/] '         )         read_user_choice.assert_called_once_with(             'pkg_name', rendered_choices, {}, '  [dim][2/2][/] '         )         assert cookiecutter_dict == expected   class TestPromptChoiceForConfig:     """"""Class to unite choices prompt related tests with config test.""""""      @pytest.fixture     def choices(self):         """"""Fixture. Just populate choices variable.""""""         return ['landscape', 'portrait', 'all']      @pytest.fixture     def context(self, choices):         """"""Fixture. Just populate context variable.""""""         return {'cookiecutter': {'orientation': choices}}      def test_should_return_first_option_if_no_input(         self, mocker, choices, context     ) -> None:         """"""Verify prompt_choice_for_config return first list option on no_input=True.""""""         read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')          expected_choice = choices[0]          actual_choice = prompt.prompt_choice_for_config(             cookiecutter_dict=context,             env=environment.StrictEnvironment(),             key='orientation',             options=choices,             no_input=True,  # Suppress user input         )          assert not read_user_choice.called         assert expected_choice == actual_choice      def test_should_read_user_choice(self, mocker, choices, context) -> None:         """"""Verify prompt_choice_for_config return user selection on no_input=False.""""""         read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')         read_user_choice.return_value = 'all'          expected_choice = 'all'          actual_choice = prompt.prompt_choice_for_config(             cookiecutter_dict=context,             env=environment.StrictEnvironment(),             key='orientation',             options=choices,             no_input=False,  # Ask the user for input         )         read_user_choice.assert_called_once_with('orientation', choices, None, '')         assert expected_choice == actual_choice   class TestReadUserYesNo:     """"""Class to unite boolean prompt related tests.""""""      @pytest.mark.parametrize(         'run_as_docker',         (             True,             False,         ),     )     def test_should_invoke_read_user_yes_no(self, mocker, run_as_docker) -> None:         """"""Verify correct function called for boolean variables.""""""         read_user_yes_no = mocker.patch('cookiecutter.prompt.read_user_yes_no')         read_user_yes_no.return_value = run_as_docker          read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')          context = {'cookiecutter': {'run_as_docker': run_as_docker}}          cookiecutter_dict = prompt.prompt_for_config(context)          assert not read_user_variable.called         read_user_yes_no.assert_called_once_with(             'run_as_docker', run_as_docker, {}, DEFAULT_PREFIX         )         assert cookiecutter_dict == {'run_as_docker': run_as_docker}      def test_boolean_parameter_no_input(self) -> None:         """"""Verify boolean parameter sent to prompt for config with no input.""""""         context = {             'cookiecutter': {                 'run_as_docker': True,             }         }         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)         assert cookiecutter_dict == context['cookiecutter']   @pytest.mark.parametrize(     'context',     (         {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},         {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},         {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},         {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},     ),     ids=[         'Undefined variable in cookiecutter dict',         'Undefined variable in cookiecutter dict with choices',         'Undefined variable in cookiecutter dict with dict_key',         'Undefined variable in cookiecutter dict with key_value',     ], ) def test_undefined_variable(context) -> None:     """"""Verify `prompt.prompt_for_config` raises correct error.""""""     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:         prompt.prompt_for_config(context, no_input=True)      error = err.value     assert error.message == ""Unable to render variable 'foo'""     assert error.context == context   @pytest.mark.parametrize(     ""template_dir,expected"",     [         [""fake-nested-templates"", ""fake-project""],         [""fake-nested-templates-old-style"", ""fake-package""],     ], ) def test_cookiecutter_nested_templates(template_dir: str, expected: Path | str) -> None:     """"""Test nested_templates generation.""""""     from cookiecutter import prompt      main_dir = (Path(""tests"") / template_dir).resolve()     cookiecuter_context = json.loads((main_dir / ""cookiecutter.json"").read_text())     context = {""cookiecutter"": cookiecuter_context}     output_dir = prompt.choose_nested_template(context, main_dir, no_input=True)     expected = (Path(main_dir) / expected).resolve()     assert output_dir == f""{expected}""   @pytest.mark.skipif(sys.platform.startswith('win'), reason=""Linux / macos test"") @pytest.mark.parametrize(     ""path"",     [         """",         ""/tmp"",         ""/foo"",     ], ) def test_cookiecutter_nested_templates_invalid_paths(path: str) -> None:     """"""Test nested_templates generation.""""""     from cookiecutter import prompt      main_dir = (Path(""tests"") / ""fake-nested-templates"").resolve()     cookiecuter_context = json.loads((main_dir / ""cookiecutter.json"").read_text())     cookiecuter_context[""templates""][""fake-project""][""path""] = path     context = {""cookiecutter"": cookiecuter_context}     with pytest.raises(ValueError) as exc:         prompt.choose_nested_template(context, main_dir, no_input=True)     assert ""Illegal template path"" in str(exc)   @pytest.mark.skipif(not sys.platform.startswith('win'), reason=""Win only test"") @pytest.mark.parametrize(     ""path"",     [         """",         ""C:/tmp"",         ""D:/tmp"",     ], ) def test_cookiecutter_nested_templates_invalid_win_paths(path: str) -> None:     """"""Test nested_templates generation.""""""     from cookiecutter import prompt      main_dir = (Path(""tests"") / ""fake-nested-templates"").resolve()     cookiecuter_context = json.loads((main_dir / ""cookiecutter.json"").read_text())     cookiecuter_context[""templates""][""fake-project""][""path""] = path     context = {""cookiecutter"": cookiecuter_context}     with pytest.raises(ValueError) as exc:         prompt.choose_nested_template(context, main_dir, no_input=True)     assert ""Illegal template path"" in str(exc)   def test_prompt_should_ask_and_rm_repo_dir(mocker, tmp_path) -> None:     """"""In `prompt_and_delete()`, if the user agrees to delete/reclone the \     repo, the repo should be deleted.""""""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', return_value=True     )     repo_dir = Path(tmp_path, 'repo')     repo_dir.mkdir()      deleted = prompt.prompt_and_delete(str(repo_dir))      assert mock_read_user.called     assert not repo_dir.exists()     assert deleted   def test_prompt_should_ask_and_exit_on_user_no_answer(mocker, tmp_path) -> None:     """"""In `prompt_and_delete()`, if the user decline to delete/reclone the \     repo, cookiecutter should exit.""""""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no',         return_value=False,     )     mock_sys_exit = mocker.patch('sys.exit', return_value=True)     repo_dir = Path(tmp_path, 'repo')     repo_dir.mkdir()      deleted = prompt.prompt_and_delete(str(repo_dir))      assert mock_read_user.called     assert repo_dir.exists()     assert not deleted     assert mock_sys_exit.called   def test_prompt_should_ask_and_rm_repo_file(mocker, tmp_path) -> None:     """"""In `prompt_and_delete()`, if the user agrees to delete/reclone a \     repo file, the repo should be deleted.""""""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', return_value=True, autospec=True     )      repo_file = tmp_path.joinpath('repo.zip')     repo_file.write_text('this is zipfile content')      deleted = prompt.prompt_and_delete(str(repo_file))      assert mock_read_user.called     assert not repo_file.exists()     assert deleted   def test_prompt_should_ask_and_keep_repo_on_no_reuse(mocker, tmp_path) -> None:     """"""In `prompt_and_delete()`, if the user wants to keep their old \     cloned template repo, it should not be deleted.""""""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', return_value=False, autospec=True     )     repo_dir = Path(tmp_path, 'repo')     repo_dir.mkdir()      with pytest.raises(SystemExit):         prompt.prompt_and_delete(str(repo_dir))      assert mock_read_user.called     assert repo_dir.exists()   def test_prompt_should_ask_and_keep_repo_on_reuse(mocker, tmp_path) -> None:     """"""In `prompt_and_delete()`, if the user wants to keep their old \     cloned template repo, it should not be deleted.""""""      def answer(question, _default):         return 'okay to delete' not in question      mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', side_effect=answer, autospec=True     )     repo_dir = Path(tmp_path, 'repo')     repo_dir.mkdir()      deleted = prompt.prompt_and_delete(str(repo_dir))      assert mock_read_user.called     assert repo_dir.exists()     assert not deleted   def test_prompt_should_not_ask_if_no_input_and_rm_repo_dir(mocker, tmp_path) -> None:     """"""Prompt should not ask if no input and rm dir.      In `prompt_and_delete()`, if `no_input` is True, the call to     `prompt.read_user_yes_no()` should be suppressed.     """"""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', return_value=True, autospec=True     )     repo_dir = Path(tmp_path, 'repo')     repo_dir.mkdir()      deleted = prompt.prompt_and_delete(str(repo_dir), no_input=True)      assert not mock_read_user.called     assert not repo_dir.exists()     assert deleted   def test_prompt_should_not_ask_if_no_input_and_rm_repo_file(mocker, tmp_path) -> None:     """"""Prompt should not ask if no input and rm file.      In `prompt_and_delete()`, if `no_input` is True, the call to     `prompt.read_user_yes_no()` should be suppressed.     """"""     mock_read_user = mocker.patch(         'cookiecutter.prompt.read_user_yes_no', return_value=True, autospec=True     )      repo_file = tmp_path.joinpath('repo.zip')     repo_file.write_text('this is zipfile content')      deleted = prompt.prompt_and_delete(str(repo_file), no_input=True)      assert not mock_read_user.called     assert not repo_file.exists()     assert deleted"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_read_repo_password.py,test_read_repo_password.py_chunk0,"""""""Tests around handling repositories which require authentication.""""""  from cookiecutter.prompt import read_repo_password   def test_click_invocation(mocker) -> None:     """"""Test click function called correctly by cookiecutter.      Test for password (hidden input) type invocation.     """"""     prompt = mocker.patch('rich.prompt.Prompt.ask')     prompt.return_value = 'sekrit'      assert read_repo_password('Password') == 'sekrit'      prompt.assert_called_once_with('Password', password=True)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_read_user_choice.py,test_read_user_choice.py_chunk0,"""""""Tests around prompting for and handling of choice variables.""""""  import pytest  from cookiecutter.prompt import read_user_choice  OPTIONS = ['hello', 'world', 'foo', 'bar'] OPTIONS_INDEX = ['1', '2', '3', '4']  EXPECTED_PROMPT = """"""Select varname     [bold magenta]1[/] - [bold]hello[/]     [bold magenta]2[/] - [bold]world[/]     [bold magenta]3[/] - [bold]foo[/]     [bold magenta]4[/] - [bold]bar[/]     Choose from""""""   @pytest.mark.parametrize('user_choice, expected_value', enumerate(OPTIONS, 1)) def test_click_invocation(mocker, user_choice, expected_value) -> None:     """"""Test click function called correctly by cookiecutter.      Test for choice type invocation.     """"""     prompt = mocker.patch('rich.prompt.Prompt.ask')     prompt.return_value = f'{user_choice}'      assert read_user_choice('varname', OPTIONS) == expected_value      prompt.assert_called_once_with(EXPECTED_PROMPT, choices=OPTIONS_INDEX, default='1')   def test_raise_if_options_is_not_a_non_empty_list() -> None:     """"""Test function called by cookiecutter raise expected errors.      Test for choice type invocation.     """"""     with pytest.raises(ValueError):         read_user_choice('foo', [])"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_read_user_dict.py,test_read_user_dict.py_chunk0,"""""""Test `process_json`, `read_user_dict` functions in `cookiecutter.prompt`.""""""  import click import pytest from rich.prompt import InvalidResponse  from cookiecutter.prompt import JsonPrompt, process_json, read_user_dict   def test_process_json_invalid_json() -> None:     """"""Test `process_json` for correct error on malformed input.""""""     with pytest.raises(InvalidResponse) as exc_info:         process_json('nope]')      assert str(exc_info.value) == 'Unable to decode to JSON.'   def test_process_json_non_dict() -> None:     """"""Test `process_json` for correct error on non-JSON input.""""""     with pytest.raises(InvalidResponse) as exc_info:         process_json('[1, 2]')      assert str(exc_info.value) == 'Requires JSON dict.'   def test_process_json_valid_json() -> None:     """"""Test `process_json` for correct output on JSON input.      Test for simple dict with list.     """"""     user_value = '{""name"": ""foobar"", ""bla"": [""a"", 1, ""b"", false]}'      assert process_json(user_value) == {         'name': 'foobar',         'bla': ['a', 1, 'b', False],     }   def test_process_json_deep_dict() -> None:     """"""Test `process_json` for correct output on JSON input.      Test for dict in dict case.     """"""     user_value = """"""{         ""key"": ""value"",         ""integer_key"": 37,         ""dict_key"": {             ""deep_key"": ""deep_value"",             ""deep_integer"": 42,             ""deep_list"": [                 ""deep value 1"",                 ""deep value 2"",                 ""deep value 3""             ]         },         ""list_key"": [             ""value 1"",             ""value 2"",             ""value 3""         ]     }""""""      assert process_json(user_value) == {         ""key"": ""value"",         ""integer_key"": 37,         ""dict_key"": {             ""deep_key"": ""deep_value"",             ""deep_integer"": 42,             ""deep_list"": [""deep value 1"", ""deep value 2"", ""deep value 3""],         },         ""list_key"": [""value 1"", ""value 2"", ""value 3""],     }   def test_should_raise_type_error(mocker) -> None:     """"""Test `default_value` arg verification in `read_user_dict` function.""""""     prompt = mocker.patch('cookiecutter.prompt.JsonPrompt.ask')      with pytest.raises(TypeError):         read_user_dict('name', 'russell')     assert not prompt.called   def test_should_call_prompt_with_process_json(mocker) -> None:     """"""Test to make sure that `process_json` is actually being used.      Verifies generation of a processor for the user input.     """"""     mock_prompt = mocker.patch('cookiecutter.prompt.JsonPrompt.ask', autospec=True)      read_user_dict('name', {'project_slug': 'pytest-plugin'})     print(mock_prompt.call_args)     args, kwargs = mock_prompt.call_args      assert args == ('name [cyan bold](default)[/]',)     assert kwargs['default'] == {'project_slug': 'pytest-plugin'}   def test_should_not_load_json_from_sentinel(mocker) -> None:     """"""Make sure that `json.loads` is not called when using default value.""""""     mock_json_loads = mocker.patch(         'cookiecutter.prompt.json.loads', autospec=True, return_value={}     )      runner = click.testing.CliRunner()     with runner.isolation(input=""\n""):         read_user_dict('name', {'project_slug': 'pytest-plugin'})      mock_json_loads.assert_not_called()   @pytest.mark.parametrize(""input"", [""\n"", ""\ndefault\n""]) def test_read_user_dict_default_value(input) -> None:     """"""Make sure that `read_user_dict` returns the default value.      Verify return of a dict variable rather than the display value.     """"""     runner = click.testing.CliRunner()     with runner.isolation(input=input):         val = read_user_dict('name', {'project_slug': 'pytest-plugin'})      assert val == {'project_slug': 'pytest-plugin'}   def test_json_prompt_process_response() -> None:     """"""Test `JsonPrompt` process_response to convert str to json.""""""     jp = JsonPrompt()     assert jp.process_response('{""project_slug"": ""something""}') == {         'project_slug': 'something'     }"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_read_user_variable.py,test_read_user_variable.py_chunk0,"""""""test_read_user_variable.""""""  import pytest  from cookiecutter.prompt import read_user_variable  VARIABLE = 'project_name' DEFAULT = 'Kivy Project'   @pytest.fixture def mock_prompt(mocker):     """"""Return a mocked version of the 'Prompt.ask' function.""""""     return mocker.patch('rich.prompt.Prompt.ask')   def test_click_invocation(mock_prompt) -> None:     """"""Test click function called correctly by cookiecutter.      Test for string type invocation.     """"""     mock_prompt.return_value = DEFAULT      assert read_user_variable(VARIABLE, DEFAULT) == DEFAULT      mock_prompt.assert_called_once_with(VARIABLE, default=DEFAULT)   def test_input_loop_with_null_default_value(mock_prompt) -> None:     """"""Test `Prompt.ask` is run repeatedly until a valid answer is provided.      Test for `default_value` parameter equal to None.     """"""     # Simulate user providing None input initially and then a valid input     mock_prompt.side_effect = [None, DEFAULT]      assert read_user_variable(VARIABLE, None) == DEFAULT     assert mock_prompt.call_count == 2"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_read_user_yes_no.py,test_read_user_yes_no.py_chunk0,"""""""test_read_user_yes_no.""""""  import pytest from rich.prompt import InvalidResponse  from cookiecutter.prompt import YesNoPrompt, read_user_yes_no  QUESTION = 'Is it okay to delete and re-clone it?' DEFAULT = 'y'   def test_click_invocation(mocker) -> None:     """"""Test click function called correctly by cookiecutter.      Test for boolean type invocation.     """"""     prompt = mocker.patch('cookiecutter.prompt.YesNoPrompt.ask')     prompt.return_value = DEFAULT      assert read_user_yes_no(QUESTION, DEFAULT) == DEFAULT      prompt.assert_called_once_with(QUESTION, default=DEFAULT)   def test_yesno_prompt_process_response() -> None:     """"""Test `YesNoPrompt` process_response to convert str to bool.""""""     ynp = YesNoPrompt()     with pytest.raises(InvalidResponse):         ynp.process_response('wrong')     assert ynp.process_response('t') is True     assert ynp.process_response('f') is False"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_repo_not_found.py,test_repo_not_found.py_chunk0,"""""""Testing invalid cookiecutter template repositories.""""""  import pytest  from cookiecutter import exceptions, main   def test_should_raise_error_if_repo_does_not_exist() -> None:     """"""Cookiecutter invocation with non-exist repository should raise error.""""""     with pytest.raises(exceptions.RepositoryNotFound):         main.cookiecutter('definitely-not-a-valid-repo-dir')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_specify_output_dir.py,test_specify_output_dir.py_chunk0,"""""""Tests for cookiecutter's output directory customization feature.""""""  import pytest  from cookiecutter import main   @pytest.fixture def context():     """"""Fixture to return a valid context as known from a cookiecutter.json.""""""     return {         'cookiecutter': {             'email': 'raphael@hackebrot.de',             'full_name': 'Raphael Pierzina',             'github_username': 'hackebrot',             'version': '0.1.0',         }     }   @pytest.fixture def template(tmp_path):     """"""Fixture to prepare test template directory.""""""     template_dir = tmp_path.joinpath(""template"")     template_dir.mkdir()     template_dir.joinpath('cookiecutter.json').touch()     return str(template_dir)   @pytest.fixture(autouse=True) def mock_gen_context(mocker, context) -> None:     """"""Fixture. Automatically mock cookiecutter's function with expected output.""""""     mocker.patch('cookiecutter.main.generate_context', return_value=context)   @pytest.fixture(autouse=True) def mock_prompt(mocker) -> None:     """"""Fixture. Automatically mock cookiecutter's function with expected output.""""""     mocker.patch('cookiecutter.main.prompt_for_config')   @pytest.fixture(autouse=True) def mock_replay(mocker) -> None:     """"""Fixture. Automatically mock cookiecutter's function with expected output.""""""     mocker.patch('cookiecutter.main.dump')   def test_api_invocation(mocker, template, output_dir, context) -> None:     """"""Verify output dir location is correctly passed.""""""     mock_gen_files = mocker.patch('cookiecutter.main.generate_files')      main.cookiecutter(template, output_dir=output_dir)      mock_gen_files.assert_called_once_with(         repo_dir=template,         context=context,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir=output_dir,         accept_hooks=True,         keep_project_on_failure=False,     )   def test_default_output_dir(mocker, template, context) -> None:     """"""Verify default output dir is current working folder.""""""     mock_gen_files = mocker.patch('cookiecutter.main.generate_files')      main.cookiecutter(template)      mock_gen_files.assert_called_once_with(         repo_dir=template,         context=context,         overwrite_if_exists=False,         skip_if_file_exists=False,         output_dir='.',         accept_hooks=True,         keep_project_on_failure=False,     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_templates.py,test_templates.py_chunk0,""""""" test_custom_extension_in_hooks.  Tests to ensure custom cookiecutter extensions are properly made available to pre- and post-gen hooks. """"""  from pathlib import Path  import pytest  from cookiecutter import main   @pytest.fixture def output_dir(tmpdir):     """"""Fixture. Create and return custom temp directory for test.""""""     return str(tmpdir.mkdir('templates'))   @pytest.mark.parametrize(""template"", [""include"", ""no-templates"", ""extends"", ""super""]) def test_build_templates(template, output_dir) -> None:     """"""     Verify Templates Design keywords.      no-templates is a compatibility tests for repo without `templates` directory     """"""     project_dir = main.cookiecutter(         f'tests/test-templates/{template}',         no_input=True,         output_dir=output_dir,     )      readme = Path(project_dir, 'requirements.txt').read_text()      assert readme.split() == [         ""pip"",         ""Click"",         ""pytest"",     ]"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_time_extension.py,test_time_extension.py_chunk0,"""""""Tests for the TimeExtension Jinja2 extension.""""""  import freezegun import pytest from jinja2 import Environment, exceptions   @pytest.fixture def environment():     """"""Fixture. Add tested extension to environment.""""""     return Environment(extensions=['cookiecutter.extensions.TimeExtension'])  # noqa: S701   @pytest.fixture(autouse=True) def freeze():     """"""Fixture. Freeze time for all tests.""""""     freezer = freezegun.freeze_time(""2015-12-09 23:33:01"")     freezer.start()     yield     freezer.stop()   def test_tz_is_required(environment) -> None:     """"""Verify template parsing fails without a timezone.""""""     with pytest.raises(exceptions.TemplateSyntaxError):         environment.from_string('{% now %}')   def test_utc_default_datetime_format(environment) -> None:     """"""Verify default datetime format can be parsed.""""""     template = environment.from_string(""{% now 'utc' %}"")      assert template.render() == ""2015-12-09""   @pytest.mark.parametrize(""valid_tz"", ['utc', 'local', 'Europe/Berlin']) def test_accept_valid_timezones(environment, valid_tz) -> None:     """"""Verify that valid timezones are accepted.""""""     template = environment.from_string(f""{{% now '{valid_tz}', '%Y-%m' %}}"")      assert template.render() == '2015-12'   def test_environment_datetime_format(environment) -> None:     """"""Verify datetime format can be parsed from environment.""""""     environment.datetime_format = '%a, %d %b %Y %H:%M:%S'      template = environment.from_string(""{% now 'utc' %}"")      assert template.render() == ""Wed, 09 Dec 2015 23:33:01""   def test_add_time(environment) -> None:     """"""Verify that added time offset can be parsed.""""""     environment.datetime_format = '%a, %d %b %Y %H:%M:%S'      template = environment.from_string(""{% now 'utc' + 'hours=2,seconds=30' %}"")      assert template.render() == ""Thu, 10 Dec 2015 01:33:31""   def test_substract_time(environment) -> None:     """"""Verify that substracted time offset can be parsed.""""""     environment.datetime_format = '%a, %d %b %Y %H:%M:%S'      template = environment.from_string(""{% now 'utc' - 'minutes=11' %}"")      assert template.render() == ""Wed, 09 Dec 2015 23:22:01""   def test_offset_with_format(environment) -> None:     """"""Verify that offset works together with datetime format.""""""     environment.datetime_format = '%d %b %Y %H:%M:%S'      template = environment.from_string(         ""{% now 'utc' - 'days=2,minutes=33,seconds=1', '%d %b %Y %H:%M:%S' %}""     )      assert template.render() == ""07 Dec 2015 23:00:00"""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test_utils.py,test_utils.py_chunk0,"""""""Tests for `cookiecutter.utils` module.""""""  import stat import sys from pathlib import Path  import pytest  from cookiecutter import utils   def make_readonly(path) -> None:     """"""Change the access permissions to readonly for a given file.""""""     mode = Path.stat(path).st_mode     Path.chmod(path, mode & ~stat.S_IWRITE)   def test_force_delete(mocker, tmp_path) -> None:     """"""Verify `utils.force_delete` makes files writable.""""""     ro_file = Path(tmp_path, 'bar')     ro_file.write_text(""Test data"")     make_readonly(ro_file)      rmtree = mocker.Mock()     utils.force_delete(rmtree, ro_file, sys.exc_info())      assert (ro_file.stat().st_mode & stat.S_IWRITE) == stat.S_IWRITE     rmtree.assert_called_once_with(ro_file)      utils.rmtree(tmp_path)   def test_rmtree(tmp_path) -> None:     """"""Verify `utils.rmtree` remove files marked as read-only.""""""     file_path = Path(tmp_path, ""bar"")     file_path.write_text(""Test data"")     make_readonly(file_path)      utils.rmtree(tmp_path)      assert not Path(tmp_path).exists()   def test_make_sure_path_exists(tmp_path) -> None:     """"""Verify correct True/False response from `utils.make_sure_path_exists`.      Should return True if directory exist or created.     Should return False if impossible to create directory (for example protected)     """"""     existing_directory = tmp_path     directory_to_create = Path(tmp_path, ""not_yet_created"")      utils.make_sure_path_exists(existing_directory)     utils.make_sure_path_exists(directory_to_create)      # Ensure by base system methods.     assert existing_directory.is_dir()     assert existing_directory.exists()     assert directory_to_create.is_dir()     assert directory_to_create.exists()   def test_make_sure_path_exists_correctly_handle_os_error(mocker) -> None:     """"""Verify correct True/False response from `utils.make_sure_path_exists`.      Should return True if directory exist or created.     Should return False if impossible to create directory (for example protected)     """"""     mocker.patch(""pathlib.Path.mkdir"", side_effect=OSError)     with pytest.raises(OSError) as err:         utils.make_sure_path_exists(Path('protected_path'))     assert str(err.value) == ""Unable to create directory at protected_path""   def test_work_in(tmp_path) -> None:     """"""Verify returning to original folder after `utils.work_in` use.""""""     cwd = Path.cwd()     ch_to = tmp_path      assert ch_to != Path.cwd()      # Under context manager we should work in tmp_path.     with utils.work_in(ch_to):         assert ch_to == Path.cwd()      # Make sure we return to the correct folder     assert cwd == Path.cwd()   def test_work_in_without_path() -> None:     """"""Folder is not changed if no path provided.""""""     cwd = Path.cwd()      with utils.work_in():         assert cwd == Path.cwd()      assert cwd == Path.cwd()   def test_create_tmp_repo_dir(tmp_path) -> None:     """"""Verify `utils.create_tmp_repo_dir` creates a copy.""""""     repo_dir = Path(tmp_path) / 'bar'     repo_dir.mkdir()     subdirs = ('foo', 'bar', 'foobar')     for name in subdirs:         (repo_dir / name).mkdir()      new_repo_dir = utils.create_tmp_repo_dir(repo_dir)      assert new_repo_dir.exists()     assert new_repo_dir.glob('*')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\__init__.py,__init__.py_chunk0,"""""""Cookiecutter integration tests."""""""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo\fake-project\README.rst,README.rst_chunk0,Fake Project  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-bad-json\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  Project name: {{ cookiecutter.project_name }}  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-dict\{{cookiecutter.project_slug}}\README.md,README.md_chunk0,"README  {% for extension, details in cookiecutter.file_types|dictsort %}  {{ details.name }}  {{ extension }}  {% for app in details.apps -%}           {{ app }}       {% endfor -%}  {% endfor %}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-dir\my-dir\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  Project name: {{ cookiecutter.project_name }}  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-pre\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  Project name: {{ cookiecutter.project_name }}  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-pre2\{%{cookiecutter.repo_name}%}\README.rst,README.rst_chunk0,Fake Project  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-replay\{{cookiecutter.repo_name}}\README.md,README.md_chunk0,{{cookiecutter.description}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-tmpl\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\fake-repo-tmpl-_cookiecutter\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  Blah!!!!
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\hooks-abort-render\hooks\post_gen_project.py,post_gen_project.py_chunk0,"# flake8: noqa  """"""Simple post-gen hook for testing the handling of different exit codes.""""""  import sys  {% if cookiecutter.abort_post_gen == ""yes"" %} sys.exit(5) {% else %} sys.exit(0) {% endif %}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\hooks-abort-render\hooks\pre_gen_project.py,pre_gen_project.py_chunk0,"# flake8: noqa  """"""Simple pre-gen hook for testing the handling of different exit codes.""""""  import sys  {% if cookiecutter.abort_pre_gen == ""yes"" %} sys.exit(5) {% else %} sys.exit(0) {% endif %}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\hooks-abort-render\{{cookiecutter.repo_dir}}\README.rst,README.rst_chunk0,{{cookiecutter.repo_dir}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\replay\conftest.py,conftest.py_chunk0,"""""""pytest fixtures for testing cookiecutter's replay feature.""""""  import pytest   @pytest.fixture def context():     """"""Fixture to return a valid context as known from a cookiecutter.json.""""""     return {         'cookiecutter': {             'email': 'raphael@hackebrot.de',             'full_name': 'Raphael Pierzina',             'github_username': 'hackebrot',             'version': '0.1.0',         }     }   @pytest.fixture def replay_test_dir() -> str:     """"""Fixture to test directory.""""""     return 'tests/test-replay/'   @pytest.fixture def mock_user_config(mocker):     """"""Fixture to mock user config.""""""     return mocker.patch('cookiecutter.main.get_user_config')"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\replay\test_dump.py,test_dump.py_chunk0,"""""""test_dump.""""""  import json import os  import pytest  from cookiecutter import replay   @pytest.fixture def template_name() -> str:     """"""Fixture to return a valid template_name.""""""     return 'cookiedozer'   @pytest.fixture def replay_file(replay_test_dir, template_name):     """"""Fixture to return a actual file name of the dump.""""""     file_name = f'{template_name}.json'     return os.path.join(replay_test_dir, file_name)   @pytest.fixture(autouse=True) def remove_replay_dump(request, replay_file) -> None:     """"""Remove the replay file created by tests.""""""      def fin_remove_replay_file() -> None:         if os.path.exists(replay_file):             os.remove(replay_file)      request.addfinalizer(fin_remove_replay_file)   def test_value_error_if_key_missing_in_context(replay_test_dir, template_name) -> None:     """"""Test that replay.dump raises if the context does not contain a key \     named 'cookiecutter'.""""""     with pytest.raises(ValueError):         replay.dump(replay_test_dir, template_name, {'foo': 'bar'})   @pytest.fixture def mock_ensure_failure(mocker):     """"""Replace cookiecutter.replay.make_sure_path_exists function.      Used to mock internal function and limit test scope.     Always return expected value: False     """"""     return mocker.patch(         'cookiecutter.replay.make_sure_path_exists', side_effect=OSError     )   @pytest.fixture def mock_ensure_success(mocker):     """"""Replace cookiecutter.replay.make_sure_path_exists function.      Used to mock internal function and limit test scope.     Always return expected value: True     """"""     return mocker.patch('cookiecutter.replay.make_sure_path_exists', return_value=True)   def test_ioerror_if_replay_dir_creation_fails(     mock_ensure_failure, replay_test_dir ) -> None:     """"""Test that replay.dump raises when the replay_dir cannot be created.""""""     with pytest.raises(OSError):         replay.dump(replay_test_dir, 'foo', {'cookiecutter': {'hello': 'world'}})      mock_ensure_failure.assert_called_once_with(replay_test_dir)   def test_run_json_dump(     mocker,     mock_ensure_success,     mock_user_config,     template_name,     context,     replay_test_dir,     replay_file, ) -> None:     """"""Test that replay.dump runs json.dump under the hood and that the context \     is correctly written to the expected file in the replay_dir.""""""     spy_get_replay_file = mocker.spy(replay, 'get_file_name')      mock_json_dump = mocker.patch('json.dump', side_effect=json.dump)      replay.dump(replay_test_dir, template_name, context)      assert not mock_user_config.called     mock_ensure_success.assert_called_once_with(replay_test_dir)     spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)      assert mock_json_dump.call_count == 1     (dumped_context, outfile_handler), _kwargs = mock_json_dump.call_args     assert outfile_handler.name == replay_file     assert dumped_context == context"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\replay\test_load.py,test_load.py_chunk0,"""""""test_load.""""""  import json import os  import pytest  from cookiecutter import replay   @pytest.fixture def template_name() -> str:     """"""Fixture to return a valid template_name.""""""     return 'cookiedozer_load'   @pytest.fixture def replay_file(replay_test_dir, template_name):     """"""Fixture to return a actual file name of the dump.""""""     file_name = f'{template_name}.json'     return os.path.join(replay_test_dir, file_name)   def test_value_error_if_key_missing_in_context(replay_test_dir) -> None:     """"""Test that replay.load raises if the loaded context does not contain \     'cookiecutter'.""""""     with pytest.raises(ValueError):         replay.load(replay_test_dir, 'invalid_replay')   def test_io_error_if_no_replay_file(replay_test_dir) -> None:     """"""Test that replay.load raises if it cannot find a replay file.""""""     with pytest.raises(IOError):         replay.load(replay_test_dir, 'no_replay')   def test_run_json_load(     mocker, mock_user_config, template_name, context, replay_test_dir, replay_file ) -> None:     """"""Test that replay.load runs json.load under the hood and that the context \     is correctly loaded from the file in replay_dir.""""""     spy_get_replay_file = mocker.spy(replay, 'get_file_name')      mock_json_load = mocker.patch('json.load', side_effect=json.load)      loaded_context = replay.load(replay_test_dir, template_name)      assert not mock_user_config.called     spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)      assert mock_json_load.call_count == 1     (infile_handler,), _kwargs = mock_json_load.call_args     assert infile_handler.name == replay_file     assert loaded_context == context"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\replay\test_replay.py,test_replay.py_chunk0,"""""""test_replay.""""""  import os  import pytest  from cookiecutter import exceptions, main, replay   @pytest.mark.parametrize(""replay_file_name"", ['bar', 'bar.json']) def test_get_replay_file_name(replay_file_name) -> None:     """"""Make sure that replay.get_file_name generates a valid json file path.""""""     exp_replay_file_path = os.path.join('foo', 'bar.json')     replay_file_path = replay.get_file_name('foo', replay_file_name)     assert replay_file_path == exp_replay_file_path   @pytest.mark.parametrize(     'invalid_kwargs',     (         {'no_input': True},         {'extra_context': {}},         {'no_input': True, 'extra_context': {}},     ), ) def test_raise_on_invalid_mode(invalid_kwargs) -> None:     """"""Test `cookiecutter` raise exception on unacceptable `replay` request.""""""     with pytest.raises(exceptions.InvalidModeException):         main.cookiecutter('foo', replay=True, **invalid_kwargs)   def test_main_does_not_invoke_dump_but_load(mocker) -> None:     """"""Test `cookiecutter` calling correct functions on `replay`.""""""     mock_prompt = mocker.patch('cookiecutter.main.prompt_for_config')     mock_gen_context = mocker.patch('cookiecutter.main.generate_context')     mock_gen_files = mocker.patch('cookiecutter.main.generate_files')     mock_replay_dump = mocker.patch('cookiecutter.main.dump')     mock_replay_load = mocker.patch('cookiecutter.main.load')      main.cookiecutter('tests/fake-repo-tmpl/', replay=True)      assert not mock_prompt.called     assert mock_gen_context.called     assert mock_replay_dump.called     assert mock_replay_load.called     assert mock_gen_files.called   def test_main_does_not_invoke_load_but_dump(mocker) -> None:     """"""Test `cookiecutter` calling correct functions on non-replay launch.""""""     mock_prompt = mocker.patch('cookiecutter.main.prompt_for_config')     mock_gen_context = mocker.patch('cookiecutter.main.generate_context')     mock_gen_files = mocker.patch('cookiecutter.main.generate_files')     mock_replay_dump = mocker.patch('cookiecutter.main.dump')     mock_replay_load = mocker.patch('cookiecutter.main.load')      main.cookiecutter('tests/fake-repo-tmpl/', replay=False)      assert mock_prompt.called     assert mock_gen_context.called     assert mock_replay_dump.called     assert not mock_replay_load.called     assert mock_gen_files.called"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_abbreviation_expansion.py,test_abbreviation_expansion.py_chunk0,"""""""Collection of tests around common path and url shorthands.""""""  import pytest  from cookiecutter.config import BUILTIN_ABBREVIATIONS from cookiecutter.repository import expand_abbreviations   @pytest.mark.parametrize(     ('template', 'abbreviations', 'expected_result'),     [         ('foo', {'foo': 'bar'}, 'bar'),         ('baz', {'foo': 'bar'}, 'baz'),         ('xx:a', {'xx': '<{0}>'}, '<a>'),         ('gh:a', {'gh': '<{0}>'}, '<a>'),         ('xx:a', {'xx': '<>'}, '<>'),         (             'gh:pydanny/cookiecutter-django',             BUILTIN_ABBREVIATIONS,             'https://github.com/pydanny/cookiecutter-django.git',         ),         (             'gl:pydanny/cookiecutter-django',             BUILTIN_ABBREVIATIONS,             'https://gitlab.com/pydanny/cookiecutter-django.git',         ),         (             'bb:pydanny/cookiecutter-django',             BUILTIN_ABBREVIATIONS,             'https://bitbucket.org/pydanny/cookiecutter-django',         ),     ],     ids=(         'Simple expansion',         'Skip expansion (expansion not an abbreviation)',         'Expansion prefix',         'expansion_override_builtin',         'expansion_prefix_ignores_suffix',         'Correct expansion for builtin abbreviations (github)',         'Correct expansion for builtin abbreviations (gitlab)',         'Correct expansion for builtin abbreviations (bitbucket)',     ), ) def test_abbreviation_expansion(template, abbreviations, expected_result) -> None:     """"""Verify abbreviation unpacking.""""""     expanded = expand_abbreviations(template, abbreviations)     assert expanded == expected_result   def test_abbreviation_expansion_prefix_not_0_in_braces() -> None:     """"""Verify abbreviation unpacking raises error on incorrect index.""""""     with pytest.raises(IndexError):         expand_abbreviations('xx:a', {'xx': '{1}'})"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_determine_repository_should_use_local_repo.py,test_determine_repository_should_use_local_repo.py_chunk0,"""""""Tests around using locally cached cookiecutter template repositories.""""""  from pathlib import Path  import pytest  from cookiecutter import exceptions, repository   def test_finds_local_repo(tmp_path) -> None:     """"""A valid local repository should be returned.""""""     project_dir, cleanup = repository.determine_repo_dir(         'tests/fake-repo',         abbreviations={},         clone_to_dir=str(tmp_path),         checkout=None,         no_input=True,     )      assert project_dir == 'tests/fake-repo'     assert not cleanup   def test_local_repo_with_no_context_raises(tmp_path) -> None:     """"""A local repository without a cookiecutter.json should raise a \     `RepositoryNotFound` exception.""""""     template_path = str(Path('tests', 'fake-repo-bad'))     with pytest.raises(exceptions.RepositoryNotFound) as err:         repository.determine_repo_dir(             template_path,             abbreviations={},             clone_to_dir=str(tmp_path),             checkout=None,             no_input=True,         )      assert str(err.value) == (         'A valid repository for ""{}"" could not be found in the following '         'locations:\n{}'.format(             template_path,             '\n'.join(                 [                     template_path,                     str(tmp_path.joinpath('tests', 'fake-repo-bad')),                 ]             ),         )     )   def test_local_repo_typo(tmp_path) -> None:     """"""An unknown local repository should raise a `RepositoryNotFound` \     exception.""""""     template_path = str(Path('tests', 'unknown-repo'))     with pytest.raises(exceptions.RepositoryNotFound) as err:         repository.determine_repo_dir(             template_path,             abbreviations={},             clone_to_dir=str(tmp_path),             checkout=None,             no_input=True,         )      assert str(err.value) == (         'A valid repository for ""{}"" could not be found in the following '         'locations:\n{}'.format(             template_path,             '\n'.join([template_path, str(tmp_path.joinpath('tests', 'unknown-repo'))]),         )     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_determine_repo_dir_clones_repo.py,test_determine_repo_dir_clones_repo.py_chunk0,"""""""Collection of tests around cloning cookiecutter template repositories.""""""  import os  import pytest  from cookiecutter import exceptions, repository   @pytest.mark.parametrize(     'template, is_url',     [         ('/path/to/zipfile.zip', False),         ('https://example.com/path/to/zipfile.zip', True),         ('http://example.com/path/to/zipfile.zip', True),     ], ) def test_zipfile_unzip(mocker, template, is_url, user_config_data) -> None:     """"""Verify zip files correctly handled for different source locations.      `unzip()` should be called with correct args when `determine_repo_dir()`     is passed a zipfile, or a URL to a zipfile.     """"""     mock_clone = mocker.patch(         'cookiecutter.repository.unzip',         return_value='tests/fake-repo-tmpl',         autospec=True,     )      project_dir, cleanup = repository.determine_repo_dir(         template,         abbreviations={},         clone_to_dir=user_config_data['cookiecutters_dir'],         checkout=None,         no_input=True,         password=None,     )      mock_clone.assert_called_once_with(         zip_uri=template,         is_url=is_url,         clone_to_dir=user_config_data['cookiecutters_dir'],         no_input=True,         password=None,     )      assert os.path.isdir(project_dir)     assert cleanup     assert project_dir == 'tests/fake-repo-tmpl'   @pytest.fixture def template_url() -> str:     """"""URL to example Cookiecutter template on GitHub.      Note: when used, git clone is mocked.     """"""     return 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'   def test_repository_url_should_clone(mocker, template_url, user_config_data) -> None:     """"""Verify repository url triggers clone function.      `clone()` should be called with correct args when `determine_repo_dir()` is     passed a repository template url.     """"""     mock_clone = mocker.patch(         'cookiecutter.repository.clone',         return_value='tests/fake-repo-tmpl',         autospec=True,     )      project_dir, cleanup = repository.determine_repo_dir(         template_url,         abbreviations={},         clone_to_dir=user_config_data['cookiecutters_dir'],         checkout=None,         no_input=True,     )      mock_clone.assert_called_once_with(         repo_url=template_url,         checkout=None,         clone_to_dir=user_config_data['cookiecutters_dir'],         no_input=True,     )      assert os.path.isdir(project_dir)     assert not cleanup     assert project_dir == 'tests/fake-repo-tmpl'   def test_repository_url_with_no_context_file(mocker, template_url) -> None:     """"""Verify cloned repository without `cookiecutter.json` file raises error.""""""     mocker.patch(         'cookiecutter.repository.clone',         return_value='tests/fake-repo-bad',         autospec=True,     )      with pytest.raises(exceptions.RepositoryNotFound) as err:         repository.determine_repo_dir(             template_url,             abbreviations={},             clone_to_dir=""."",             checkout=None,             no_input=True,         )      assert str(err.value) == (         'A valid repository for ""{}"" could not be found in the following '         'locations:\n{}'.format(template_url, 'tests/fake-repo-bad')     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_determine_repo_dir_finds_existing_cookiecutter.py,test_determine_repo_dir_finds_existing_cookiecutter.py_chunk0,"""""""Tests around detection whether cookiecutter templates are cached locally.""""""  import os from pathlib import Path  import pytest  from cookiecutter import repository   @pytest.fixture def template() -> str:     """"""Fixture. Return simple string as template name.""""""     return 'cookiecutter-pytest-plugin'   @pytest.fixture def cloned_cookiecutter_path(user_config_data, template):     """"""Fixture. Create fake project directory in special user folder.""""""     cookiecutters_dir = user_config_data['cookiecutters_dir']      cloned_template_path = os.path.join(cookiecutters_dir, template)     os.mkdir(cloned_template_path)      Path(cloned_template_path, ""cookiecutter.json"").touch()  # creates file      return cloned_template_path   def test_should_find_existing_cookiecutter(     template, user_config_data, cloned_cookiecutter_path ) -> None:     """"""     Should find folder created by `cloned_cookiecutter_path` and return it.      This folder is considered like previously cloned project directory.     """"""     project_dir, cleanup = repository.determine_repo_dir(         template=template,         abbreviations={},         clone_to_dir=user_config_data['cookiecutters_dir'],         checkout=None,         no_input=True,     )      assert cloned_cookiecutter_path == project_dir     assert not cleanup"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_determine_repo_dir_finds_subdirectories.py,test_determine_repo_dir_finds_subdirectories.py_chunk0,"""""""Tests around locally cached cookiecutter template repositories.""""""  import os from pathlib import Path  import pytest  from cookiecutter import exceptions, repository   @pytest.fixture def template() -> str:     """"""Fixture. Return simple string as template name.""""""     return 'cookiecutter-pytest-plugin'   @pytest.fixture def cloned_cookiecutter_path(user_config_data, template):     """"""Fixture. Prepare folder structure for tests in this file.""""""     cookiecutters_dir = user_config_data['cookiecutters_dir']      cloned_template_path = os.path.join(cookiecutters_dir, template)     if not os.path.exists(cloned_template_path):         os.mkdir(cloned_template_path)  # might exist from other tests.      subdir_template_path = os.path.join(cloned_template_path, 'my-dir')     if not os.path.exists(subdir_template_path):         os.mkdir(subdir_template_path)     Path(subdir_template_path, 'cookiecutter.json').touch()  # creates file      return subdir_template_path   def test_should_find_existing_cookiecutter(     template, user_config_data, cloned_cookiecutter_path ) -> None:     """"""Find `cookiecutter.json` in sub folder created by `cloned_cookiecutter_path`.""""""     project_dir, cleanup = repository.determine_repo_dir(         template=template,         abbreviations={},         clone_to_dir=user_config_data['cookiecutters_dir'],         checkout=None,         no_input=True,         directory='my-dir',     )      assert cloned_cookiecutter_path == project_dir     assert not cleanup   def test_local_repo_typo(template, user_config_data, cloned_cookiecutter_path) -> None:     """"""Wrong pointing to `cookiecutter.json` sub-directory should raise.""""""     with pytest.raises(exceptions.RepositoryNotFound) as err:         repository.determine_repo_dir(             template=template,             abbreviations={},             clone_to_dir=user_config_data['cookiecutters_dir'],             checkout=None,             no_input=True,             directory='wrong-dir',         )      wrong_full_cookiecutter_path = os.path.join(         os.path.dirname(cloned_cookiecutter_path), 'wrong-dir'     )     assert str(err.value) == (         'A valid repository for ""{}"" could not be found in the following '         'locations:\n{}'.format(             template,             '\n'.join(                 [                     os.path.join(template, 'wrong-dir'),                     wrong_full_cookiecutter_path,                 ]             ),         )     )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_is_repo_url.py,test_is_repo_url.py_chunk0,"""""""Tests for all supported cookiecutter template repository locations.""""""  import pytest  from cookiecutter.config import BUILTIN_ABBREVIATIONS from cookiecutter.repository import expand_abbreviations, is_repo_url, is_zip_file   @pytest.fixture(     params=[         '/path/to/zipfile.zip',         'https://example.com/path/to/zipfile.zip',         'http://example.com/path/to/zipfile.zip',     ] ) def zipfile(request):     """"""Fixture. Represent possible paths to zip file.""""""     return request.param   def test_is_zip_file(zipfile) -> None:     """"""Verify is_repo_url works.""""""     assert is_zip_file(zipfile) is True   @pytest.fixture(     params=[         'gitolite@server:team/repo',         'git@github.com:audreyfeldroy/cookiecutter.git',         'https://github.com/cookiecutter/cookiecutter.git',         'git+https://private.com/gitrepo',         'hg+https://private.com/mercurialrepo',         'https://bitbucket.org/pokoli/cookiecutter.hg',         'file://server/path/to/repo.git',     ] ) def remote_repo_url(request):     """"""Fixture. Represent possible URI to different repositories types.""""""     return request.param   def test_is_repo_url_for_remote_urls(remote_repo_url) -> None:     """"""Verify is_repo_url works.""""""     assert is_repo_url(remote_repo_url) is True   @pytest.fixture(     params=[         '/audreyr/cookiecutter.git',         '/home/audreyr/cookiecutter',         (             'c:\\users\\foo\\appdata\\local\\temp\\1\\pytest-0\\'             'test_default_output_dir0\\template'         ),     ] ) def local_repo_url(request):     """"""Fixture. Represent possible paths to local resources.""""""     return request.param   def test_is_repo_url_for_local_urls(local_repo_url) -> None:     """"""Verify is_repo_url works.""""""     assert is_repo_url(local_repo_url) is False   def test_expand_abbreviations() -> None:     """"""Validate `repository.expand_abbreviations` correctly translate url.""""""     template = 'gh:audreyfeldroy/cookiecutter-pypackage'      # This is not a valid repo url just yet!     # First `repository.expand_abbreviations` needs to translate it     assert is_repo_url(template) is False      expanded_template = expand_abbreviations(template, BUILTIN_ABBREVIATIONS)     assert is_repo_url(expanded_template) is True"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\repository\test_repository_has_cookiecutter_json.py,test_repository_has_cookiecutter_json.py_chunk0,"""""""Tests for `repository_has_cookiecutter_json` function.""""""  import pytest  from cookiecutter.repository import repository_has_cookiecutter_json   def test_valid_repository() -> None:     """"""Validate correct response if `cookiecutter.json` file exist.""""""     assert repository_has_cookiecutter_json('tests/fake-repo')   @pytest.mark.parametrize(     'invalid_repository', (['tests/fake-repo-bad', 'tests/unknown-repo']) ) def test_invalid_repository(invalid_repository) -> None:     """"""Validate correct response if `cookiecutter.json` file not exist.""""""     assert not repository_has_cookiecutter_json(invalid_repository)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\custom-extension-post\hooks\post_gen_project.py,post_gen_project.py_chunk0,"""""""Test post-gen hook in extensions are available and exposed methods are callable.""""""  import sys  if '{% hello cookiecutter.name %}' == 'Hello Cookiemonster!':     sys.exit(0) else:     sys.exit(1)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\custom-extension-post\{{cookiecutter.project_slug}}\README.rst,README.rst_chunk0,{% hello cookiecutter.name %}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\custom-extension-pre\hooks\pre_gen_project.py,pre_gen_project.py_chunk0,"""""""Test pre-gen hook in extensions are available and exposed methods are callable.""""""  import sys  if '{% hello cookiecutter.name %}' == 'Hello Cookiemonster!':     sys.exit(0) else:     sys.exit(1)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\custom-extension-pre\{{cookiecutter.project_slug}}\README.rst,README.rst_chunk0,{% hello cookiecutter.name %}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\default\{{cookiecutter.project_slug}}\HISTORY.rst,HISTORY.rst_chunk0,"History  0.1.0 ({% now 'utc', '%Y-%m-%d' %}) {{ ""-"" * 18 }}  First release on PyPI."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\hello_extension\hello_extension.py,hello_extension.py_chunk0,"""""""Provides custom extension, exposing a ``hello`` command.""""""  from jinja2 import Environment, nodes from jinja2.ext import Extension from jinja2.parser import Parser   class HelloExtension(Extension):     """"""Simple jinja2 extension for cookiecutter test purposes.""""""      tags = {'hello'}      def __init__(self, environment: Environment) -> None:         """"""Hello Extension Constructor.""""""         super().__init__(environment)      def _hello(self, name: str) -> str:         """"""Do actual tag replace when invoked by parser.""""""         return f'Hello {name}!'      def parse(self, parser: Parser) -> nodes.Output:         """"""Work when something match `tags` variable.""""""         lineno = next(parser.stream).lineno         node = parser.parse_expression()         call_method = self.call_method('_hello', [node], lineno=lineno)         return nodes.Output([call_method], lineno=lineno)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\hello_extension\__init__.py,__init__.py_chunk0,"""""""Hello Extension."""""""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\local_extension\local_extensions\main.py,main.py_chunk0,"""""""Provides custom extension, exposing a ``foobar`` filter.""""""  from jinja2 import Environment from jinja2.ext import Extension  from cookiecutter.utils import simple_filter   class FoobarExtension(Extension):     """"""Simple jinja2 extension for cookiecutter test purposes.""""""      def __init__(self, environment: Environment) -> None:         """"""Foobar Extension Constructor.""""""         super().__init__(environment)         environment.filters['foobar'] = lambda v: v * 2   @simple_filter def simplefilterextension(v: str) -> str:     """"""Provide a simple function-based filter extension.""""""     return v.upper()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\local_extension\local_extensions\__init__.py,__init__.py_chunk0,"from .main import FoobarExtension, simplefilterextension  # noqa: F401"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\local_extension\{{cookiecutter.project_slug}}\HISTORY.rst,HISTORY.rst_chunk0,"History  0.1.0  First release of {{cookiecutter.test_value_class_based}} on PyPI. {{cookiecutter.test_value_function_based}}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-extensions\unknown\{{cookiecutter.project_slug}}\HISTORY.rst,HISTORY.rst_chunk0,"History  0.1.0 ({{cookiecutter.nope | foobar}})  First release on PyPI."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-not-rendered\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-rendered\README.md,README.md_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-rendered\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render-override\{{cookiecutter.repo_name}}\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render-override\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-not-rendered\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render-override\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-rendered\README.md,README.md_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-copy-without-render-override\{{cookiecutter.repo_name}}\{{cookiecutter.repo_name}}-rendered\README.rst,README.rst_chunk0,Fake Project  {{cookiecutter.render_test}}
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-generate-files-line-end\{{cookiecutter.test_name}}\{{cookiecutter.folder_name}}\{{cookiecutter.filename}}.py,{{cookiecutter.filename}}.py_chunk0,"""""""Sample file to be created through a cookiecutter run.""""""  print(""This is the contents of {{ cookiecutter.filename }}.py."")"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-output-folder\{{cookiecutter.test_name}}\{{cookiecutter.folder_name}}\{{cookiecutter.filename}}.py,{{cookiecutter.filename}}.py_chunk0,"""""""Sample file to be created through a cookiecutter run.""""""  print(""These are the contents of {{ cookiecutter.filename }}.py."")"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyhooks\hooks\post_gen_project.py,post_gen_project.py_chunk0,"""""""Simple post-gen hook for testing project folder and custom file creation.""""""  print('pre generation hook') f = open('python_post.txt', 'w') f.close()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyhooks\hooks\pre_gen_project.py,pre_gen_project.py_chunk0,"""""""Simple pre-gen hook for testing project folder and custom file creation.""""""  print('pre generation hook') f = open('python_pre.txt', 'w') f.close()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyhooks\hooks\pre_prompt.py,pre_prompt.py_chunk0,"""""""Simple pre-prompt hook that will fail if a specific env var is set.""""""  import os import sys from pathlib import Path   def backup_configuration(cwd: Path) -> Path:     """"""Create a backup of cookiecutter.json.""""""     src_data = (cwd / 'cookiecutter.json').read_text()     dst = cwd / '_cookiecutter.json'     with open(dst, 'w') as fh:         fh.write(src_data)     return dst   def main():     """"""Check if we can run the  cookiecutter.""""""     if os.environ.get(""COOKIECUTTER_FAIL_PRE_PROMPT"", False):         sys.exit(1)     cwd = Path('.').resolve()     bkp = backup_configuration(cwd)     print(f""All good here, created {bkp}"")   if __name__ == ""__main__"":     main()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyhooks\input{{cookiecutter.pyhooks}}\README.rst,README.rst_chunk0,foo  bar
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyshellhooks\hooks\post_gen_project.py,post_gen_project.py_chunk0,"""""""Simple post-gen hook for testing project folder and custom file creation.""""""  print('pre generation hook') f = open('python_post.txt', 'w') f.close()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyshellhooks\hooks\pre_gen_project.py,pre_gen_project.py_chunk0,"""""""Simple pre-gen hook for testing project folder and custom file creation.""""""  print('pre generation hook') f = open('python_pre.txt', 'w') f.close()"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-pyshellhooks\input{{pyshellhooks}}\README.rst,README.rst_chunk0,foo  bar
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-shellhooks\input{{cookiecutter.shellhooks}}\README.rst,README.rst_chunk0,foo  bar
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-shellhooks-empty\input{{cookiecutter.shellhooks}}\README.rst,README.rst_chunk0,"Empty, just like the hooks we are testing."
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\test-shellhooks-win\input{{cookiecutter.shellhooks}}\README.rst,README.rst_chunk0,foo  bar
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\undefined-variable\dir-name\{{cookiecutter.project_slug}}\README.rst,README.rst_chunk0,"{{cookiecutter.project_slug}} {% for _ in cookiecutter.project_slug %}={% endfor %}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\undefined-variable\dir-name\{{cookiecutter.project_slug}}\{{cookiecutter.foobar}}\helloworld.py,helloworld.py_chunk0,""""""" Sample Python file.  Expected not to be created in a test due to the undefined variable ``cookiecutter.foobar``. """""""
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\undefined-variable\file-content\{{cookiecutter.project_slug}}\README.rst,README.rst_chunk0,"{{cookiecutter.project_slug}} {% for _ in cookiecutter.project_slug %}={% endfor %}  {{cookiecutter.foobar}}  https://github.com/{{cookiecutter.github_username}}/{{cookiecutter.project_slug}}"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\vcs\test_clone.py,test_clone.py_chunk0,"""""""Tests around cloning repositories and detection of errors at it.""""""  import os import subprocess  import pytest  from cookiecutter import exceptions, vcs   def test_clone_should_raise_if_vcs_not_installed(mocker, clone_dir) -> None:     """"""In `clone()`, a `VCSNotInstalled` exception should be raised if no VCS \     is installed.""""""     mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=False)      repo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'      with pytest.raises(exceptions.VCSNotInstalled):         vcs.clone(repo_url, clone_to_dir=str(clone_dir))   def test_clone_should_rstrip_trailing_slash_in_repo_url(mocker, clone_dir) -> None:     """"""In `clone()`, repo URL's trailing slash should be stripped if one is \     present.""""""     mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)      mock_subprocess = mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,     )      vcs.clone('https://github.com/foo/bar/', clone_to_dir=clone_dir, no_input=True)      mock_subprocess.assert_called_once_with(         ['git', 'clone', 'https://github.com/foo/bar'],         cwd=clone_dir,         stderr=subprocess.STDOUT,     )   def test_clone_should_abort_if_user_does_not_want_to_reclone(mocker, clone_dir) -> None:     """"""In `clone()`, if user doesn't want to reclone, Cookiecutter should exit \     without cloning anything.""""""     mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)     mocker.patch(         'cookiecutter.vcs.prompt_and_delete', side_effect=SystemExit, autospec=True     )     mock_subprocess = mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,     )      # Create repo_dir to trigger prompt_and_delete     repo_dir = clone_dir.joinpath('cookiecutter-pytest-plugin')     repo_dir.mkdir()      repo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'      with pytest.raises(SystemExit):         vcs.clone(repo_url, clone_to_dir=str(clone_dir))     assert not mock_subprocess.called   def test_clone_should_silent_exit_if_ok_to_reuse(mocker, tmpdir) -> None:     """"""In `clone()`, if user doesn't want to reclone, Cookiecutter should exit \     without cloning anything.""""""     mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)     mocker.patch(         'cookiecutter.vcs.prompt_and_delete', return_value=False, autospec=True     )     mock_subprocess = mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,     )      clone_to_dir = tmpdir.mkdir('clone')      # Create repo_dir to trigger prompt_and_delete     clone_to_dir.mkdir('cookiecutter-pytest-plugin')      repo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'      vcs.clone(repo_url, clone_to_dir=str(clone_to_dir))     assert not mock_subprocess.called   @pytest.mark.parametrize(     'repo_type, repo_url, repo_name',     [         ('git', 'https://github.com/hello/world.git', 'world'),         ('hg', 'https://bitbucket.org/foo/bar', 'bar'),         ('git', 'git@host:gitoliterepo', 'gitoliterepo'),         ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),         ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),     ], ) def test_clone_should_invoke_vcs_command(     mocker, clone_dir, repo_type, repo_url, repo_name ) -> None:     """"""When `clone()` is called with a git/hg repo, the corresponding VCS \     command should be run via `subprocess.check_output()`.      This should take place:     * In the correct dir     * With the correct args.     """"""     mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)      mock_subprocess = mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,     )     expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))      branch = 'foobar'      repo_dir = vcs.clone(         repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True     )      assert repo_dir == expected_repo_dir      mock_subprocess.assert_any_call(         [repo_type, 'clone', repo_url], cwd=clone_dir, stderr=subprocess.STDOUT     )      branch_info = [branch]     # We sanitize branch information for Mercurial     if repo_type == ""hg"":         branch_info.insert(0, ""--"")      mock_subprocess.assert_any_call(         [repo_type, 'checkout', *branch_info],         cwd=expected_repo_dir,         stderr=subprocess.STDOUT,     )   @pytest.mark.parametrize(     'error_message',     [         (b""fatal: repository 'https://github.com/hackebro/cookiedozer' not found""),         b'hg: abort: HTTP Error 404: Not Found',     ], ) def test_clone_handles_repo_typo(mocker, clone_dir, error_message) -> None:     """"""In `clone()`, repository not found errors should raise an \     appropriate exception.""""""     # side_effect is set to an iterable here (and below),     # because of a Python 3.4 unittest.mock regression     # http://bugs.python.org/issue23661     mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,         side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],     )      repository_url = 'https://github.com/hackebro/cookiedozer'     with pytest.raises(exceptions.RepositoryNotFound) as err:         vcs.clone(repository_url, clone_to_dir=str(clone_dir), no_input=True)      assert str(err.value) == (         f'The repository {repository_url} could not be found, have you made a typo?'     )   @pytest.mark.parametrize(     'error_message',     [         b""error: pathspec 'unknown_branch' did not match any file(s) known to git"",         b""hg: abort: unknown revision 'unknown_branch'!"",     ], ) def test_clone_handles_branch_typo(mocker, clone_dir, error_message) -> None:     """"""In `clone()`, branch not found errors should raise an \     appropriate exception.""""""     mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,         side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],     )      repository_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin'     with pytest.raises(exceptions.RepositoryCloneFailed) as err:         vcs.clone(             repository_url,             clone_to_dir=str(clone_dir),             checkout='unknown_branch',             no_input=True,         )      assert str(err.value) == (         'The unknown_branch branch of repository '         f'{repository_url} could not found, have you made a typo?'     )   def test_clone_unknown_subprocess_error(mocker, clone_dir) -> None:     """"""In `clone()`, unknown subprocess errors should be raised.""""""     mocker.patch(         'cookiecutter.vcs.subprocess.check_output',         autospec=True,         side_effect=[             subprocess.CalledProcessError(-1, 'cmd', output=b'Something went wrong')         ],     )      with pytest.raises(subprocess.CalledProcessError):         vcs.clone(             'https://github.com/pytest-dev/cookiecutter-pytest-plugin',             clone_to_dir=str(clone_dir),             no_input=True,         )"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\vcs\test_identify_repo.py,test_identify_repo.py_chunk0,"""""""Collection of tests around repository type identification.""""""  import pytest  from cookiecutter import exceptions, vcs   @pytest.mark.parametrize(     'repo_url, exp_repo_type, exp_repo_url',     [         (             'git+https://github.com/pytest-dev/cookiecutter-pytest-plugin.git',             'git',             'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git',         ),         (             'hg+https://bitbucket.org/foo/bar.hg',             'hg',             'https://bitbucket.org/foo/bar.hg',         ),         (             'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git',             'git',             'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git',         ),         ('https://bitbucket.org/foo/bar.hg', 'hg', 'https://bitbucket.org/foo/bar.hg'),         (             'https://github.com/audreyfeldroy/cookiecutter-pypackage.git',             'git',             'https://github.com/audreyfeldroy/cookiecutter-pypackage.git',         ),         (             'https://github.com/audreyfeldroy/cookiecutter-pypackage',             'git',             'https://github.com/audreyfeldroy/cookiecutter-pypackage',         ),         (             'git@gitorious.org:cookiecutter-gitorious/cookiecutter-gitorious.git',             'git',             'git@gitorious.org:cookiecutter-gitorious/cookiecutter-gitorious.git',         ),         (             'https://audreyr@bitbucket.org/audreyr/cookiecutter-bitbucket',             'hg',             'https://audreyr@bitbucket.org/audreyr/cookiecutter-bitbucket',         ),     ], ) def test_identify_known_repo(repo_url, exp_repo_type, exp_repo_url) -> None:     """"""Verify different correct repositories url syntax is correctly transformed.""""""     assert vcs.identify_repo(repo_url) == (exp_repo_type, exp_repo_url)   @pytest.fixture(     params=[         'foo+git',  # uses explicit identifier with 'git' in the wrong place         'foo+hg',  # uses explicit identifier with 'hg' in the wrong place         'foo+bar',  # uses explicit identifier with neither 'git' nor 'hg'         'foobar',  # no identifier but neither 'git' nor 'bitbucket' in url         'http://norepotypespecified.com',     ] ) def unknown_repo_type_url(request):     """"""Fixture. Return wrong formatted repository url.""""""     return request.param   def test_identify_raise_on_unknown_repo(unknown_repo_type_url) -> None:     """"""Verify different incorrect repositories url syntax trigger error raising.""""""     with pytest.raises(exceptions.UnknownRepoType):         vcs.identify_repo(unknown_repo_type_url)"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\vcs\test_is_vcs_installed.py,test_is_vcs_installed.py_chunk0,"""""""Collection of tests around VCS detection.""""""  import pytest  from cookiecutter import vcs   @pytest.mark.parametrize(     'which_return, result',     [('', False), (None, False), (False, False), ('/usr/local/bin/git', True)], ) def test_is_vcs_installed(mocker, which_return, result) -> None:     """"""Verify `is_vcs_installed` function correctly handles `which` answer.""""""     mocker.patch('cookiecutter.vcs.which', autospec=True, return_value=which_return)     assert vcs.is_vcs_installed('git') == result"
C:\Users\t.kubera\dev\workshop\chat-with-your-sw-project\resources\cookiecutter\tests\zipfile\test_unzip.py,test_unzip.py_chunk0,"""""""Tests for function unzip() from zipfile module.""""""  from __future__ import annotations  import shutil import tempfile from pathlib import Path from typing import Iterator  import pytest  from cookiecutter import zipfile from cookiecutter.exceptions import InvalidZipRepository   def mock_download() -> Iterator[bytes]:     """"""Fake download function.""""""     with Path('tests/files/fake-repo-tmpl.zip').open('rb') as zf:         chunk = zf.read(1024)         while chunk:             yield chunk             chunk = zf.read(1024)   def mock_download_with_empty_chunks() -> Iterator[None | bytes]:     """"""Fake download function.""""""     yield None     with Path('tests/files/fake-repo-tmpl.zip').open('rb') as zf:         chunk = zf.read(1024)         while chunk:             yield chunk             chunk = zf.read(1024)   def test_unzip_local_file(mocker, clone_dir) -> None:     """"""Local file reference can be unzipped.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      output_dir = zipfile.unzip(         'tests/files/fake-repo-tmpl.zip', is_url=False, clone_to_dir=str(clone_dir)     )      assert output_dir.startswith(tempfile.gettempdir())     assert not mock_prompt_and_delete.called   def test_unzip_protected_local_file_environment_password(mocker, clone_dir) -> None:     """"""In `unzip()`, the environment can be used to provide a repo password.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      output_dir = zipfile.unzip(         'tests/files/protected-fake-repo-tmpl.zip',         is_url=False,         clone_to_dir=str(clone_dir),         password='sekrit',     )      assert output_dir.startswith(tempfile.gettempdir())     assert not mock_prompt_and_delete.called   def test_unzip_protected_local_file_bad_environment_password(mocker, clone_dir) -> None:     """"""In `unzip()`, an error occurs if the environment has a bad password.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/protected-fake-repo-tmpl.zip',             is_url=False,             clone_to_dir=str(clone_dir),             password='not-the-right-password',         )   def test_unzip_protected_local_file_user_password_with_noinput(     mocker, clone_dir ) -> None:     """"""Can't unpack a password-protected repo in no_input mode.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/protected-fake-repo-tmpl.zip',             is_url=False,             clone_to_dir=str(clone_dir),             no_input=True,         )   def test_unzip_protected_local_file_user_password(mocker, clone_dir) -> None:     """"""A password-protected local file reference can be unzipped.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )     mocker.patch('cookiecutter.zipfile.read_repo_password', return_value='sekrit')      output_dir = zipfile.unzip(         'tests/files/protected-fake-repo-tmpl.zip',         is_url=False,         clone_to_dir=str(clone_dir),     )      assert output_dir.startswith(tempfile.gettempdir())     assert not mock_prompt_and_delete.called   def test_unzip_protected_local_file_user_bad_password(mocker, clone_dir) -> None:     """"""Error in `unzip()`, if user can't provide a valid password.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )     mocker.patch(         'cookiecutter.zipfile.read_repo_password', return_value='not-the-right-password'     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/protected-fake-repo-tmpl.zip',             is_url=False,             clone_to_dir=str(clone_dir),         )   def test_empty_zip_file(mocker, clone_dir) -> None:     """"""In `unzip()`, an empty file raises an error.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/empty.zip', is_url=False, clone_to_dir=str(clone_dir)         )   def test_non_repo_zip_file(mocker, clone_dir) -> None:     """"""In `unzip()`, a repository must have a top level directory.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/not-a-repo.zip', is_url=False, clone_to_dir=str(clone_dir)         )   def test_bad_zip_file(mocker, clone_dir) -> None:     """"""In `unzip()`, a corrupted zip file raises an error.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      with pytest.raises(InvalidZipRepository):         zipfile.unzip(             'tests/files/bad-zip-file.zip', is_url=False, clone_to_dir=str(clone_dir)         )   def test_unzip_url(mocker, clone_dir) -> None:     """"""In `unzip()`, a url will be downloaded and unzipped.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      request = mocker.MagicMock()     request.iter_content.return_value = mock_download()      mocker.patch(         'cookiecutter.zipfile.requests.get',         return_value=request,         autospec=True,     )      output_dir = zipfile.unzip(         'https://example.com/path/to/fake-repo-tmpl.zip',         is_url=True,         clone_to_dir=str(clone_dir),     )      assert output_dir.startswith(tempfile.gettempdir())     assert not mock_prompt_and_delete.called   def test_unzip_url_with_empty_chunks(mocker, clone_dir) -> None:     """"""In `unzip()` empty chunk must be ignored.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      request = mocker.MagicMock()     request.iter_content.return_value = mock_download_with_empty_chunks()      mocker.patch(         'cookiecutter.zipfile.requests.get',         return_value=request,         autospec=True,     )      output_dir = zipfile.unzip(         'https://example.com/path/to/fake-repo-tmpl.zip',         is_url=True,         clone_to_dir=str(clone_dir),     )      assert output_dir.startswith(tempfile.gettempdir())     assert not mock_prompt_and_delete.called   def test_unzip_url_existing_cache(mocker, clone_dir) -> None:     """"""Url should be downloaded and unzipped, old zip file will be removed.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True     )      request = mocker.MagicMock()     request.iter_content.return_value = mock_download()      mocker.patch(         'cookiecutter.zipfile.requests.get',         return_value=request,         autospec=True,     )      # Create an existing cache of the zipfile     existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')     existing_zip.write_text('This is an existing zipfile')      output_dir = zipfile.unzip(         'https://example.com/path/to/fake-repo-tmpl.zip',         is_url=True,         clone_to_dir=str(clone_dir),     )      assert output_dir.startswith(tempfile.gettempdir())     assert mock_prompt_and_delete.call_count == 1   def test_unzip_url_existing_cache_no_input(mocker, clone_dir) -> None:     """"""If no_input is provided, the existing file should be removed.""""""     request = mocker.MagicMock()     request.iter_content.return_value = mock_download()      mocker.patch(         'cookiecutter.zipfile.requests.get',         return_value=request,         autospec=True,     )      # Create an existing cache of the zipfile     existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')     existing_zip.write_text('This is an existing zipfile')      output_dir = zipfile.unzip(         'https://example.com/path/to/fake-repo-tmpl.zip',         is_url=True,         clone_to_dir=str(clone_dir),         no_input=True,     )      assert output_dir.startswith(tempfile.gettempdir())   def test_unzip_should_abort_if_no_redownload(mocker, clone_dir) -> None:     """"""Should exit without cloning anything If no redownload.""""""     mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', side_effect=SystemExit, autospec=True     )      mock_requests_get = mocker.patch(         'cookiecutter.zipfile.requests.get',         autospec=True,     )      # Create an existing cache of the zipfile     existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')     existing_zip.write_text('This is an existing zipfile')      zipfile_url = 'https://example.com/path/to/fake-repo-tmpl.zip'      with pytest.raises(SystemExit):         zipfile.unzip(zipfile_url, is_url=True, clone_to_dir=str(clone_dir))      assert not mock_requests_get.called   def test_unzip_is_ok_to_reuse(mocker, clone_dir) -> None:     """"""Already downloaded zip should not be downloaded again.""""""     mock_prompt_and_delete = mocker.patch(         'cookiecutter.zipfile.prompt_and_delete', return_value=False, autospec=True     )      request = mocker.MagicMock()      existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')     shutil.copy('tests/files/fake-repo-tmpl.zip', existing_zip)      output_dir = zipfile.unzip(         'https://example.com/path/to/fake-repo-tmpl.zip',         is_url=True,         clone_to_dir=str(clone_dir),     )      assert output_dir.startswith(tempfile.gettempdir())     assert mock_prompt_and_delete.call_count == 1     assert request.iter_content.call_count == 0"
