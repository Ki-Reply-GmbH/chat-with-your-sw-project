{
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\setup.py": [
        {
            "global": {
                "_get_version": "\"\"\"Read cookiecutter/VERSION.txt and return its contents.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\__main__.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "\"DONE\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\cli.py": [
        {
            "global": {
                "version_msg": "\"\"\"Return the Cookiecutter version, location and Python powering it.\"\"\"",
                "validate_extra_context": "\"\"\"Validate extra context.\n\nThis function checks if each string in the provided iterable follows the \n'key=value' format. If any string does not match this format, a \n`click.BadParameter` exception is raised. The function then converts the \niterable of strings into an `OrderedDict` where each key-value pair is \nderived from the strings in the format 'key=value'.\n\nArgs:\n    _ctx (Context): The Click context object (not used in this function).\n    _param (Parameter): The Click parameter object (not used in this function).\n    value (Iterable[str]): An iterable of strings, each expected to be in the \n        'key=value' format.\n\nReturns:\n    OrderedDict[str, str] | None: An ordered dictionary containing the key-value \n    pairs derived from the input strings, or None if the input is empty.\n\nRaises:\n    click.BadParameter: If any string in the input iterable does not contain \n    an '=' character.\n\"\"\"",
                "list_installed_templates": "\"\"\"\nList installed (locally cloned) templates.\n\nThis function retrieves the user configuration, checks the directory where\ncookiecutter templates are stored, and lists all templates that contain a\n'cookiecutter.json' file.\n\nArgs:\n    default_config (bool | dict[str, Any]): The default configuration or a boolean\n        indicating whether to use the default configuration.\n    passed_config_file (str | None): The path to a user-specified configuration file,\n        or None to use the default configuration file.\n\nReturns:\n    None\n\"\"\"",
                "main": "\"\"\"\nCreate a project from a Cookiecutter project template (TEMPLATE).\n\nCookiecutter is free and open source software, developed and managed by\nvolunteers. If you would like to help out or fund the project, please get\nin touch at https://github.com/cookiecutter/cookiecutter.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\config.py": [
        {
            "global": {
                "_expand_path": "\"\"\"Expand both environment variables and user home in the given path.\"\"\"",
                "merge_configs": "\"\"\"\nRecursively update a dict with the key/value pair of another.\n\nDict values that are dictionaries themselves will be updated, whilst\npreserving existing keys.\n\nArgs:\n    default (dict[str, Any]): The original dictionary to be updated.\n    overwrite (dict[str, Any]): The dictionary with values to overwrite or add to the original.\n\nReturns:\n    dict[str, Any]: A new dictionary with merged values from both input dictionaries.\n\"\"\"",
                "get_config": "\"\"\"Retrieve the config from the specified path, returning a config dict.\n\nArgs:\n    config_path (Path | str): The path to the configuration file.\n\nReturns:\n    dict[str, Any]: The configuration dictionary.\n\nRaises:\n    ConfigDoesNotExistException: If the configuration file does not exist.\n    InvalidConfiguration: If the YAML file cannot be parsed or the top-level element is not a dictionary.\n\"\"\"",
                "get_user_config": "\"\"\"Return the user config as a dict.\n\nIf ``default_config`` is True, ignore ``config_file`` and return default\nvalues for the config parameters.\n\nIf ``default_config`` is a dict, merge values with default values and return them\nfor the config parameters.\n\nIf a path to a ``config_file`` is given, that is different from the default\nlocation, load the user config from that.\n\nOtherwise look up the config file path in the ``COOKIECUTTER_CONFIG``\nenvironment variable. If set, load the config from this path. This will\nraise an error if the specified path is not valid.\n\nIf the environment variable is not set, try the default config file path\nbefore falling back to the default config values.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\environment.py": [
        {
            "ExtensionLoaderMixin": {
                "__init__": "\"\"\"Initialize the Jinja2 Environment object while loading extensions.\n\nDoes the following:\n\n1. Establishes default_extensions (currently just a Time feature)\n2. Reads extensions set in the cookiecutter.json _extensions key.\n3. Attempts to load the extensions. Provides useful error if fails.\n\nArgs:\n    context (dict[str, Any] | None): The context from which to read extensions.\n    **kwargs (Any): Additional keyword arguments to pass to the parent class initializer.\n\"\"\"",
                "_read_extensions": "\"\"\"\nReturn list of extensions as str to be passed on to the Jinja2 env.\n\nIf context does not contain the relevant info, return an empty\nlist instead.\n\nArgs:\n    context (dict[str, Any]): The context dictionary containing extension information.\n\nReturns:\n    list[str]: A list of extension names as strings.\n\"\"\"",
                "ExtensionLoaderMixin": "\"\"\"\nA mixin class for loading and managing Jinja2 extensions.\n\nThis class provides functionality to initialize a Jinja2 Environment object with specified extensions. It reads the extensions from a given context and attempts to load them, providing useful error messages if the loading fails.\n\nAttributes:\n    default_extensions (list[str]): A list of default extensions to be used, currently including a Time feature.\n\nMethods:\n    __init__(context: dict[str, Any] | None, **kwargs: Any):\n        Initialize the Jinja2 Environment object while loading extensions.\n    \n    _read_extensions(context: dict[str, Any]) -> list[str]:\n        Return a list of extensions as strings to be passed on to the Jinja2 environment.\n\"\"\""
            }
        },
        {
            "StrictEnvironment": {
                "__init__": "\"\"\"Initialize the Jinja2 Environment object while loading extensions.\n\nDoes the following:\n\n1. Establishes default_extensions (currently just a Time feature)\n2. Reads extensions set in the cookiecutter.json _extensions key.\n3. Attempts to load the extensions. Provides useful error if fails.\n\nArgs:\n    context (dict[str, Any] | None): The context from which to read extensions.\n    **kwargs (Any): Additional keyword arguments to pass to the parent class initializer.\n\"\"\"",
                "StrictEnvironment": "\"\"\"\nA class that initializes and manages a Jinja2 Environment with specific extensions.\n\nThe StrictEnvironment class is responsible for setting up a Jinja2 Environment object with a set of predefined and user-specified extensions. It performs the following tasks:\n\n1. Establishes default extensions, such as a Time feature.\n2. Reads additional extensions specified in the `cookiecutter.json` file under the `_extensions` key.\n3. Attempts to load these extensions and provides useful error messages if the loading process fails.\n\nAttributes:\n    context (dict[str, Any] | None): The context from which to read extensions.\n    **kwargs (Any): Additional keyword arguments to pass to the parent class initializer.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\exceptions.py": [
        {
            "CookiecutterException": {
                "__init__": "\"\"\"\nInitialize the UndefinedVariableInTemplate exception.\n\nArgs:\n    message (str): The error message describing the exception.\n    error (TemplateError): The underlying template error that caused this exception.\n    context (dict[str, Any]): The context in which the error occurred, typically containing variable names and values.\n\"\"\"",
                "__str__": "\"\"\"\nReturn a string representation of the UndefinedVariableInTemplate exception.\n\nReturns:\n    str: A string that includes the message, error message, and context.\n\"\"\"",
                "CookiecutterException": "\"\"\"\nException raised for errors in the cookiecutter template rendering process.\n\nThis class serves as a custom exception for handling cases where a variable \nis undefined within a template. It provides detailed information about the \nerror, including the error message, the underlying template error, and the \ncontext in which the error occurred.\n\"\"\""
            }
        },
        {
            "NonTemplatedInputDirException": {
                "```AI:\n[]\n```": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "NonTemplatedInputDirException": "\"\"\"\nException raised for errors related to non-templated input directories.\n\nThis exception is used to indicate that a template has attempted to use a variable that is not defined within the given context.\n\nAttributes:\n    message (str): The error message.\n    error (TemplateError): The specific template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "UnknownTemplateDirException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "UnknownTemplateDirException": "\"\"\"\nException raised for using undefined variables in a template.\n\nThe UnknownTemplateDirException is raised when a template attempts to use a variable that is not defined in the provided context. This helps in identifying and debugging issues related to missing variables in template rendering.\n\nAttributes:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "MissingProjectDir": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "MissingProjectDir": "\"\"\"\nException raised for missing project directory.\n\nThis exception is raised when a required project directory is not found in the expected location.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "ConfigDoesNotExistException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"\n",
                "ConfigDoesNotExistException": "\"\"\"\nException raised for out-of-scope variables in a template.\n\nThe ConfigDoesNotExistException is raised when a template attempts to use a variable that is not defined in the provided context. This exception helps in identifying and debugging issues related to missing configuration variables in templates.\n\nAttributes:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "InvalidConfiguration": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "InvalidConfiguration": "\"\"\"\nException class for handling invalid configurations.\n\nThis class is used to raise exceptions when a template uses a variable that is not defined in the context. It provides detailed information about the error, including the error message, the specific template error that was raised, and the context in which the error occurred.\n\"\"\""
            }
        },
        {
            "UnknownRepoType": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"\n",
                "UnknownRepoType": "\"\"\"\nClass representing an exception for out-of-scope variables in a template.\n\nThis exception is raised when a template attempts to use a variable that is not defined in the provided context. It helps in identifying and debugging issues related to missing or undefined variables in template processing.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "VCSNotInstalled": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "VCSNotInstalled": "\"\"\"\nException raised when a required version control system (VCS) is not installed.\n\nThis exception is used to indicate that a necessary VCS, such as Git or SVN, is not available in the environment where the code is being executed.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "ContextDecodingException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "ContextDecodingException": "\"\"\"\nException raised for out-of-scope variables in a template context.\n\nThis exception is triggered when a template attempts to use a variable that is not defined within the provided context.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "OutputDirExistsException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "OutputDirExistsException": "\"\"\"\nException raised when an output directory already exists.\n\nThis exception is used to signal that an operation cannot proceed because the specified output directory already exists.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "EmptyDirNameException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "EmptyDirNameException": "\"\"\"\nException raised for errors related to empty directory names.\n\nThis exception is used to signal that a directory name is empty or invalid in the given context.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "InvalidModeException": {
                "```[]\n```": "\"\"\"\nInitialize the UndefinedVariableInTemplate exception.\n\nArgs:\n    message (str): The error message describing the exception.\n    error (TemplateError): The underlying Jinja2 template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "InvalidModeException": "\"\"\"\nException raised for errors in the mode of operation.\n\nThis exception is used to indicate that an invalid mode has been encountered. It is initialized with a message describing the error, the underlying template error, and the context in which the error occurred.\n\"\"\""
            }
        },
        {
            "FailedHookException": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "FailedHookException": "\"\"\"\nException raised for errors in the hook execution process.\n\nThis exception is used to indicate that a hook has failed during the execution of a CI/CD pipeline. It provides details about the error, including a description, the underlying error, and the context in which the error occurred.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "UndefinedVariableInTemplate": {
                "__init__": "\"\"\"\nInitialize the UndefinedVariableInTemplate exception.\n\nArgs:\n    message (str): The error message describing the exception.\n    error (TemplateError): The underlying template error that caused this exception.\n    context (dict[str, Any]): The context in which the error occurred, typically containing variable names and values.\n\"\"\"",
                "__str__": "\"\"\"\nReturn a string representation of the UndefinedVariableInTemplate exception.\n\nReturns:\n    str: A formatted string containing the message, error message, and context.\n\"\"\"",
                "UndefinedVariableInTemplate": "\"\"\"\nException raised for undefined variables in a template.\n\nThis class is used to handle exceptions that occur when a variable is not defined in a template. It provides detailed information about the error, including the error message, the underlying template error, and the context in which the error occurred.\n\"\"\""
            }
        },
        {
            "UnknownExtension": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "UnknownExtension": "\"\"\"\nException class for handling out-of-scope variables in templates.\n\nThe UnknownExtension class is designed to manage exceptions that occur when a template attempts to use a variable that is not defined within the given context. This helps in identifying and debugging issues related to undefined variables in template rendering.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "RepositoryNotFound": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "RepositoryNotFound": "\"\"\"\nException raised when a specified repository is not found.\n\nThis exception is used to indicate that a repository, which is expected to be present, is missing. It provides details about the error, including a description, the underlying template error, and the context in which the error occurred.\n\nAttributes:\n    message (str): Description of the exception.\n    error (TemplateError): The underlying template error.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "RepositoryCloneFailed": {
                "```[]```": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "RepositoryCloneFailed": "\"\"\"\nException raised when a repository clone operation fails.\n\nThis exception is used to indicate that an attempt to clone a repository has failed. It provides details about the error message, the specific template error that was raised, and the context in which the error occurred.\n\"\"\""
            }
        },
        {
            "InvalidZipRepository": {
                "[]": "\"\"\"\nException for out-of-scope variables.\n\nRaised when a template uses a variable which is not defined in the\ncontext.\n\nArgs:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\"",
                "InvalidZipRepository": "\"\"\"\nException class for handling invalid ZIP repository errors.\n\nThis class is used to raise exceptions when a template uses a variable that is not defined in the context. It provides detailed information about the error, including the error message, the template error that was raised, and the context in which the error occurred.\n\nAttributes:\n    message (str): The error message.\n    error (TemplateError): The template error that was raised.\n    context (dict[str, Any]): The context in which the error occurred.\n\"\"\""
            }
        },
        {
            "global": {
                "__init__": "\"\"\"\nInitialize the UndefinedVariableInTemplate exception.\n\nArgs:\n    message (str): The error message describing the exception.\n    error (TemplateError): The underlying template error that caused this exception.\n    context (dict[str, Any]): The context in which the template error occurred.\n\"\"\"\n",
                " __str__": "\"\"\"Text representation of UndefinedVariableInTemplate.\n\nReturns:\n    str: A string representation of the exception, including the message,\n    error message, and context.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\extensions.py": [
        {
            "JsonifyExtension": {
                "jsonify": "\"\"\"\nConvert a Python object to a JSON string.\n\nArgs:\n    obj (Any): The Python object to be converted to JSON.\n    indent (int, optional): The number of spaces to use for indentation in the JSON string. Defaults to 4.\n\nReturns:\n    str: The JSON string representation of the Python object.\n\"\"\"",
                "JsonifyExtension": "\"\"\"\nThe JsonifyExtension class provides functionality to convert Python objects into JSON strings.\n\nThis class includes methods to handle the conversion process, allowing for optional customization of the JSON string format, such as indentation.\n\nMethods:\n    jsonify: Convert a Python object to a JSON string with optional indentation.\n\"\"\""
            }
        },
        {
            "RandomStringExtension": {
                "random_ascii_string": "\"\"\"\nGenerate a random ASCII string of a specified length.\n\nArgs:\n    length (int): The length of the generated string.\n    punctuation (bool, optional): If True, include punctuation characters in the string. Defaults to False.\n\nReturns:\n    str: A random ASCII string of the specified length.\n\"\"\"",
                "RandomStringExtension": "\"\"\"\nA class for generating random strings with various customizable options.\n\nThis class provides methods to generate random ASCII strings with specified lengths and optional inclusion of punctuation characters.\n\"\"\""
            }
        },
        {
            "SlugifyExtension": {
                "slugify": "\"\"\"\nSlugifies the given string value.\n\nArgs:\n    value (str): The string to be slugified.\n    entities (bool, optional): Whether to convert HTML entities. Defaults to True.\n    decimal (bool, optional): Whether to convert decimal numbers. Defaults to True.\n    hexadecimal (bool, optional): Whether to convert hexadecimal numbers. Defaults to True.\n    max_length (int, optional): Maximum length of the slug. Defaults to 0 (no limit).\n    word_boundary (bool, optional): Whether to truncate at word boundaries. Defaults to False.\n    separator (str, optional): Separator to use for word boundaries. Defaults to DEFAULT_SEPARATOR.\n    save_order (bool, optional): Whether to save the order of words. Defaults to False.\n    stopwords (Iterable[str], optional): Words to exclude from the slug. Defaults to ().\n    regex_pattern (re.Pattern[str] | str | None, optional): Regex pattern to use for slugification. Defaults to None.\n    lowercase (bool, optional): Whether to convert the slug to lowercase. Defaults to True.\n    replacements (Iterable[Iterable[str]], optional): Custom replacements to apply. Defaults to ().\n    allow_unicode (bool, optional): Whether to allow unicode characters. Defaults to False.\n\nReturns:\n    str: The slugified string.\n\"\"\"",
                "SlugifyExtension": "\"\"\"\nSlugifyExtension is a class designed to provide functionality for converting strings into slugs. \n\nA slug is a URL-friendly version of a string, typically used in web development to create readable and SEO-friendly URLs. The class offers a method to slugify a given string with various customizable options, such as converting HTML entities, handling decimal and hexadecimal numbers, setting a maximum length, truncating at word boundaries, specifying a separator, preserving word order, excluding stopwords, applying regex patterns, converting to lowercase, making custom replacements, and allowing unicode characters.\n\nThis class is useful for developers who need to generate slugs for URLs, filenames, or other identifiers in a consistent and flexible manner.\n\"\"\""
            }
        },
        {
            "UUIDExtension": {
                "uuid4": "\"\"\"Generate UUID4.\"\"\"",
                "UUIDExtension": "\"\"\"\nUUIDExtension class provides functionality to generate UUIDs.\n\nThis class includes methods to generate UUIDs using different versions, \nspecifically UUID4, which is a randomly generated UUID.\n\"\"\""
            }
        },
        {
            "TimeExtension": {
                "_datetime": "\"\"\"\nGenerate a formatted datetime string based on the given timezone, operator, offset, and format.\n\nArgs:\n    timezone (str): The timezone to use for the datetime.\n    operator (str): The operator to apply to the offset (e.g., '+' or '-').\n    offset (str): The offset to apply to the current datetime, in the format 'interval=value'.\n    datetime_format (str | None): The format to use for the datetime string. If None, the default format is used.\n\nReturns:\n    str: The formatted datetime string.\n\"\"\"",
                "_now": "\"\"\"\nGet the current date and time in the specified timezone and format.\n\nArgs:\n    timezone (str): The timezone to use for the current time.\n    datetime_format (str | None): The format to use for the datetime string. If None, the default format is used.\n\nReturns:\n    str: The current date and time as a formatted string.\n\"\"\"",
                "parse": "\"\"\"Parse datetime template and add datetime value.\n\nArgs:\n    parser (Parser): The Jinja2 parser instance.\n\nReturns:\n    nodes.Output: The parsed output node with the datetime value.\n\"\"\"",
                "TimeExtension": "\"\"\"\nTimeExtension class provides utilities for generating and formatting datetime strings based on specified timezones, offsets, and formats. It also includes functionality to parse datetime templates and inject datetime values.\n\nThis class includes the following methods:\n- _datetime: Generates a formatted datetime string based on the given timezone, operator, offset, and format.\n- _now: Retrieves the current date and time in the specified timezone and format.\n- parse: Parses a datetime template and adds the datetime value using a Jinja2 parser instance.\n\"\"\""
            }
        },
        {
            "global": {}
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\find.py": [
        {
            "global": {
                "find_template": "\"\"\"\nDetermine which child directory of ``repo_dir`` is the project template.\n\n:param repo_dir: Local directory of newly cloned repo.\n:param env: Jinja2 Environment object used to identify template variables.\n:return: Relative path to project template.\n:raises NonTemplatedInputDirException: If no templated directory is found.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\generate.py": [
        {
            "global": {
                "is_copy_only_path": "\"\"\"Check whether the given `path` should only be copied and not rendered.\n\nReturns True if `path` matches a pattern in the given `context` dict,\notherwise False.\n\n:param path: A file-system path referring to a file or dir that\n    should be rendered or just copied.\n:param context: cookiecutter context.\n\"\"\"",
                "apply_overwrites_to_context": "\"\"\"\nModify the given context in place based on the overwrite_context.\n\nThis function updates the `context` dictionary with values from the \n`overwrite_context` dictionary. It handles different types of variables \nincluding lists, dictionaries, booleans, and simple values. The function \nalso ensures that multi-choice and choice variables are validated against \nthe context.\n\n:param context: The original context dictionary to be modified.\n:param overwrite_context: The dictionary containing values to overwrite \n    in the original context.\n:param in_dictionary_variable: A boolean flag indicating if the function \n    is currently processing a nested dictionary variable. Defaults to False.\n\"\"\"",
                "generate_context": "\"\"\"\nGenerate the context for a Cookiecutter project template.\n\nLoads the JSON file as a Python object, with the key being the JSON filename.\n\n:param context_file: JSON file containing key/value pairs for populating\n    the cookiecutter's variables.\n:param default_context: Dictionary containing config to take into account.\n:param extra_context: Dictionary containing configuration overrides.\n:return: A dictionary representing the context for the project template.\n:raises ContextDecodingException: If there is an error decoding the JSON file.\n\"\"\"",
                "generate_file": "\"\"\"\nRender filename of infile as name of outfile, handle infile correctly.\n\nDealing with infile appropriately:\n\n    a. If infile is a binary file, copy it over without rendering.\n    b. If infile is a text file, render its contents and write the\n       rendered infile to outfile.\n\nPrecondition:\n\n    When calling `generate_file()`, the root template dir must be the\n    current working directory. Using `utils.work_in()` is the recommended\n    way to perform this directory change.\n\n:param project_dir: Absolute path to the resulting generated project.\n:param infile: Input file to generate the file from. Relative to the root\n    template dir.\n:param context: Dict for populating the cookiecutter's variables.\n:param env: Jinja2 template execution environment.\n:param skip_if_file_exists: If True, skip the file generation if the file\n    already exists.\n\"\"\"",
                "render_and_create_dir": "\"\"\"\nRender the name of a directory, create the directory, and return its path.\n\nThis function takes a directory name template, renders it using the provided context, \nand creates the directory in the specified output directory. It also handles cases \nwhere the directory already exists and whether it should be overwritten.\n\n:param dirname: The template name of the directory to be rendered and created.\n:param context: A dictionary containing the context for rendering the directory name.\n:param output_dir: The base directory where the rendered directory will be created.\n:param environment: The Jinja2 environment used for rendering the directory name.\n:param overwrite_if_exists: Boolean flag indicating whether to overwrite the directory \n    if it already exists.\n:returns: A tuple containing the path to the created directory and a boolean indicating \n    whether the directory was newly created.\n:raises EmptyDirNameException: If the rendered directory name is empty.\n:raises OutputDirExistsException: If the directory already exists and overwrite_if_exists \n    is False.\n\"\"\"",
                "_run_hook_from_repo_dir": "\"\"\"\nRun a specified hook from the repository directory and handle failures by optionally cleaning up the project directory.\n\n:param repo_dir: The directory of the project template.\n:param hook_name: The name of the hook to run.\n:param project_dir: The directory where the project is being generated.\n:param context: The context for the Cookiecutter project.\n:param delete_project_on_failure: If True, delete the project directory if the hook fails.\n\"\"\"",
                "generate_files": "\"\"\"\nRender the templates and saves them to files.\n\n:param repo_dir: Project template input directory.\n:param context: Dict for populating the template's variables.\n:param output_dir: Where to output the generated project dir into.\n:param overwrite_if_exists: Overwrite the contents of the output directory\n    if it exists.\n:param skip_if_file_exists: Skip the files in the corresponding directories\n    if they already exist\n:param accept_hooks: Accept pre and post hooks if set to `True`.\n:param keep_project_on_failure: If `True` keep generated project directory even when\n    generation fails\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\hooks.py": [
        {
            "global": {
                "valid_hook": "\"\"\"Determine if a hook file is valid.\n\n:param hook_file: The hook file to consider for validity\n:param hook_name: The hook to find\n:return: The hook file validity\n\"\"\"",
                "find_hook": "\"\"\"\nReturn a list of all hook scripts provided.\n\nMust be called with the project template as the current working directory.\nThe list will contain the absolute paths to the scripts. Missing scripts will\nnot be included in the returned list.\n\n:param hook_name: The hook to find.\n:param hooks_dir: The hook directory in the template.\n:return: A list of absolute paths to the hook scripts or None.\n\"\"\"",
                "run_script": "\"\"\"\nExecute a script from a working directory.\n\n:param script_path: Absolute path to the script to run.\n:param cwd: The directory to run the script from.\n\"\"\"",
                "run_script_with_context": "\"\"\"\nExecute a script after rendering it with Jinja.\n\n:param script_path: Absolute path to the script to run.\n:param cwd: The directory to run the script from.\n:param context: Cookiecutter project template context.\n\"\"\"",
                "run_hook": "\"\"\"\nTry to find and execute a hook from the specified project directory.\n\n:param hook_name: The hook to execute.\n:param project_dir: The directory to execute the script from.\n:param context: Cookiecutter project context.\n\"\"\"",
                "run_hook_from_repo_dir": "\"\"\"\nRun a specified hook from the repository directory and clean the project directory if the hook fails.\n\nThis function changes the working directory to the repository directory, attempts to run the specified hook, and if the hook fails, it optionally deletes the project directory.\n\n:param repo_dir: Project template input directory.\n:param hook_name: The hook to execute.\n:param project_dir: The directory to execute the script from.\n:param context: Cookiecutter project context.\n:param delete_project_on_failure: Delete the project directory on hook failure?\n\"\"\"",
                "run_pre_prompt_hook": "\"\"\"\nRun the pre_prompt hook from the repository directory.\n\nThis function checks for the existence of a valid pre_prompt script in the \nrepository directory. If found, it creates a temporary directory and executes \nthe pre_prompt script(s) from there.\n\n:param repo_dir: Project template input directory.\n:return: The repository directory, potentially modified by the pre_prompt hook.\n:raises FailedHookException: If the pre_prompt hook script fails.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\log.py": [
        {
            "global": {
                "configure_logger": "\"\"\"Configure logging for cookiecutter.\n\nSet up logging to stdout with given level. If ``debug_file`` is given set\nup logging to file with DEBUG level.\n\nArgs:\n    stream_level (str): The logging level for the stream handler. Defaults to 'DEBUG'.\n    debug_file (str | None): The file path for the debug log file. If provided, a file handler is set up with DEBUG level. Defaults to None.\n\nReturns:\n    logging.Logger: Configured logger for cookiecutter.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\main.py": [
        {
            "_patch_import_path_for_repo": {
                "__enter__": "\"\"\"\nAdd the repository directory to the system path.\n\nThis method is called when entering the context manager and ensures that the\nrepository directory is included in the system path, allowing for the import\nof modules from the repository.\n\n:return: None\n\"\"\"",
                "__exit__": "\"\"\"\nRestore the original import path when exiting the context.\n\n:param type: The exception type, if an exception was raised.\n:param value: The exception instance, if an exception was raised.\n:param traceback: The traceback object, if an exception was raised.\n\"\"\"",
                "_patch_import_path_for_repo": "\"\"\"\nA context manager class to temporarily modify the system path for importing modules from a repository.\n\nThis class is designed to facilitate the import of modules from a specific repository by temporarily adding the repository directory to the system path when entering the context and restoring the original system path upon exiting the context.\n\"\"\""
            }
        },
        {
            "global": {
                "cookiecutter": "    \"\"\"\n    Run Cookiecutter just as if using it from the command line.\n\n    :param template: A directory containing a project template directory,\n        or a URL to a git repository.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param no_input: Do not prompt for user input.\n        Use default values for template parameters taken from `cookiecutter.json`, user\n        config and `extra_dict`. Force a refresh of cached resources.\n    :param extra_context: A dictionary of context that overrides default\n        and user configuration.\n    :param replay: Do not prompt for input, instead read from saved json. If\n        ``True`` read from the ``replay_dir``.\n        if it exists\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param output_dir: Where to output the generated project dir into.\n    :param config_file: User configuration file path.\n    :param default_config: Use default values rather than a config file.\n    :param password: The password to use when extracting the repository.\n    :param directory: Relative path to a cookiecutter template in a repository.\n    :param skip_if_file_exists: Skip the files in the corresponding directories\n        if they already exist.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    :param keep_project_on_failure: If `True` keep generated project directory even when\n        generation fails\n    :return: The path to the generated project.\n    :raises InvalidModeException: If both replay and no_input or extra_context are used\n        at the same time.\n    \"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\prompt.py": [
        {
            "YesNoPrompt": {
                "process_response": "\"\"\"Convert choices to a bool.\n\n:param value: The string value to be processed.\n:return: True if the value is in the list of yes choices, False if in the list of no choices.\n:raises InvalidResponse: If the value is not recognized as a valid response.\n\"\"\"",
                "YesNoPrompt": "\"\"\"\nA class to handle yes/no prompts and convert user responses to boolean values.\n\nThis class provides functionality to process user input and determine if the response is affirmative or negative. It includes methods to validate and convert string responses to boolean values, raising an exception for invalid responses.\n\"\"\""
            }
        },
        {
            "JsonPrompt": {
                "process_response": "\"\"\"Convert choices to a bool.\n\n:param value: The user input value to be processed.\n:raises InvalidResponse: If the input value is not recognized as a valid choice.\n:return: True if the input value is a recognized 'yes' choice, False if it is a recognized 'no' choice.\n\"\"\"",
                "JsonPrompt": "\"\"\"\nJsonPrompt class is designed to handle and process user input responses, specifically converting them into boolean values. It ensures that the input is valid and recognized as either a 'yes' or 'no' choice, raising an error if the input is invalid.\n\"\"\""
            }
        },
        {
            "global": {
                "read_user_variable": "\"\"\"Prompt user for variable and return the entered value or given default.\n\n:param str var_name: Variable of the context to query the user\n:param default_value: Value that will be returned if no input happens\n:param dict prompts: Optional dictionary of prompts for user input\n:param str prefix: Optional prefix to add before the prompt\n:return: The value entered by the user or the default value\n\"\"\"",
                "read_user_yes_no": "\"\"\"Prompt the user to reply with 'yes' or 'no' (or equivalent values).\n\n- These input values will be converted to ``True``:\n  \"1\", \"true\", \"t\", \"yes\", \"y\", \"on\"\n- These input values will be converted to ``False``:\n  \"0\", \"false\", \"f\", \"no\", \"n\", \"off\"\n\nActual parsing done by :func:`prompt`; Check this function codebase change in\ncase of unexpected behaviour.\n\n:param str var_name: Variable of the context to query the user\n:param default_value: Value that will be returned if no input happens\n\"\"\"",
                "read_repo_password": "\"\"\"Prompt the user to enter a password.\n\n:param question: Question to the user\n:return: The entered password as a string\n\"\"\"",
                "read_user_choice": "\"\"\"\nPrompt the user to choose from several options for the given variable.\n\nThe first item will be returned if no input happens.\n\n:param var_name: Variable as specified in the context\n:param list options: Sequence of options that are available to select from\n:return: Exactly one item of ``options`` that has been chosen by the user\n\"\"\"",
                "process_json": "\"\"\"\nLoad user-supplied value as a JSON dict.\n\n:param user_value: User-supplied value to load as a JSON dict\n\"\"\"",
                "read_user_dict": "\"\"\"\nPrompt the user to provide a dictionary of data.\n\n:param var_name: Variable as specified in the context\n:param default_value: Value that will be returned if no input is provided\n:return: A Python dictionary to use in the context.\n\"\"\"",
                "render_variable": "\"\"\"\nRender the next variable to be displayed in the user prompt.\n\nInside the prompting taken from the cookiecutter.json file, this renders\nthe next variable. For example, if a project_name is \"Peanut Butter\nCookie\", the repo_name could be be rendered with:\n\n    `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\nThis is then presented to the user as the default.\n\n:param Environment env: A Jinja2 Environment object.\n:param raw: The next value to be prompted for by the user.\n:param dict cookiecutter_dict: The current context as it's gradually\n    being populated with variables.\n:return: The rendered value for the default variable.\n\"\"\"",
                "_prompts_from_options": "\"\"\"\nProcess template options and return friendly prompt information.\n\nThis function takes a dictionary of options and processes them to create a \nuser-friendly prompt dictionary. Each option is transformed into a label \nthat includes its title and description.\n\n:param options: A dictionary where keys are option identifiers and values \n    are dictionaries containing 'title' and 'description' for each option.\n:return: A dictionary with processed prompt information.\n\"\"\"",
                "prompt_choice_for_template": "\"\"\"\nPrompt user with a set of options to choose from.\n\n:param key: The key associated with the options to be presented.\n:param options: A dictionary of options to choose from.\n:param no_input: If True, do not prompt for user input and return the first available option.\n:return: The chosen option as an OrderedDict.\n\"\"\"",
                "prompt_choice_for_config": "\"\"\"\nPrompt user with a set of options to choose from for a specific configuration key.\n\nThis function renders the options using the provided Jinja2 environment and the current\ncookiecutter context, then prompts the user to select one of the options. If `no_input`\nis True, the first option is returned without prompting the user.\n\n:param cookiecutter_dict: The current context as it's gradually being populated with variables.\n:param env: A Jinja2 Environment object.\n:param key: The configuration key for which the user is prompted to choose an option.\n:param options: A list of options to choose from.\n:param no_input: If True, do not prompt for user input and return the first available option.\n:param prompts: Optional dictionary of custom prompts for each variable.\n:param prefix: Optional prefix to add to the prompt message.\n:return: The selected option, either as a string or an OrderedDict.\n\"\"\"",
                "prompt_for_config": "\"\"\"\nPrompt user to enter a new config.\n\n:param dict context: Source for field names and sample values.\n:param no_input: Do not prompt for user input and use only values from context.\n\"\"\"",
                "choose_nested_template": "\"\"\"Prompt user to select the nested template to use.\n\n:param context: Source for field names and sample values.\n:param repo_dir: Repository directory.\n:param no_input: Do not prompt for user input and use only values from context.\n:returns: Path to the selected template.\n\"\"\"",
                "prompt_and_delete": "\"\"\"\nAsk user if it's okay to delete the previously-downloaded file/directory.\n\nIf yes, delete it. If no, checks to see if the old version should be\nreused. If yes, it's reused; otherwise, Cookiecutter exits.\n\n:param path: Previously downloaded zipfile.\n:param no_input: Suppress prompt to delete repo and just delete it.\n:return: True if the content was deleted\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\replay.py": [
        {
            "global": {
                "get_file_name": "\"\"\"\nGet the full file name for the replay file, appending a '.json' suffix if not already present.\n\nArgs:\n    replay_dir (Path | str): The directory where the replay file is located.\n    template_name (str): The base name of the template file.\n\nReturns:\n    str: The full path to the replay file with the appropriate suffix.\n\"\"\"",
                "dump": "\"\"\"\nWrite json data to a file.\n\nArgs:\n    replay_dir (Path | str): The directory where the replay file will be saved.\n    template_name (str): The name of the template.\n    context (dict[str, Any]): The context data to be written to the file.\n\nRaises:\n    ValueError: If the context does not contain a 'cookiecutter' key.\n\"\"\"",
                "load": "\"\"\"\nRead json data from file.\n\nArgs:\n    replay_dir (Path | str): The directory where the replay file is located.\n    template_name (str): The name of the template file.\n\nReturns:\n    dict[str, Any]: The context data loaded from the json file.\n\nRaises:\n    ValueError: If the context does not contain a 'cookiecutter' key.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\repository.py": [
        {
            "global": {
                "is_repo_url": "\"\"\"Return True if value is a repository URL.\n\n    :param value: The string to check if it is a repository URL.\n    :return: True if the value matches the repository URL pattern, else False.\n    \"\"\"",
                "is_zip_file": "\"\"\"Return True if value is a zip file.\n\n:param value: The file path or URL to check.\n:return: True if the value ends with '.zip' (case insensitive), else False.\n\"\"\"",
                "expand_abbreviations": "\"\"\"\nExpand abbreviations in a template name.\n\n:param template: The project template name.\n:param abbreviations: Abbreviation definitions.\n:return: The expanded template name if an abbreviation is found, otherwise the original template name.\n\"\"\"",
                "repository_has_cookiecutter_json": "\"\"\"Determine if `repo_directory` contains a `cookiecutter.json` file.\n\n:param repo_directory: The candidate repository directory.\n:return: True if the `repo_directory` is valid, else False.\n\"\"\"",
                "determine_repo_dir": "\"\"\"\nLocate the repository directory from a template reference.\n\nApplies repository abbreviations to the template reference.\nIf the template refers to a repository URL, clone it.\nIf the template is a path to a local repository, use it.\n\n:param template: A directory containing a project template directory,\n    or a URL to a git repository.\n:param abbreviations: A dictionary of repository abbreviation\n    definitions.\n:param clone_to_dir: The directory to clone the repository into.\n:param checkout: The branch, tag or commit ID to checkout after clone.\n:param no_input: Do not prompt for user input and eventually force a refresh of\n    cached resources.\n:param password: The password to use when extracting the repository.\n:param directory: Directory within repo where cookiecutter.json lives.\n:return: A tuple containing the cookiecutter template directory, and\n    a boolean describing whether that directory should be cleaned up\n    after the template has been instantiated.\n:raises: `RepositoryNotFound` if a repository directory could not be found.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\utils.py": [
        {
            "SimpleFilterExtension": {
                "SimpleFilterExtension": "\"\"\"\nThe SimpleFilterExtension class is designed to integrate a custom filter function into a Jinja2 environment. \n\nThis class allows users to extend the functionality of Jinja2 templates by adding their own filter functions, which can then be used within the templates to manipulate data.\n\nAttributes:\n    environment (jinja2.Environment): The Jinja2 environment to which the custom filter function will be added.\n\"\"\""
            }
        },
        {
            "global": {
                "force_delete": "\"\"\"Error handler for `shutil.rmtree()` equivalent to `rm -rf`.\n\nUsage: `shutil.rmtree(path, onerror=force_delete)`\n\nThis function changes the file permissions to writable and then attempts to delete the file or directory.\n\n:param func: The function to call, typically `os.remove` or `os.rmdir`.\n:param path: The path to the file or directory to be removed.\n:param _exc_info: The exception information returned by `sys.exc_info()`.\n\"\"\"",
                " rmtree": "\"\"\"\nRemove a directory and all its contents. Like rm -rf on Unix.\n\n:param path: A directory path.\n\"\"\"",
                " make_sure_path_exists": "\"\"\"Ensure that a directory exists.\n\n:param path: A directory tree path for creation.\n\"\"\"",
                " work_in": "\"\"\"\nContext manager version of os.chdir.\n\nWhen exited, returns to the working directory prior to entering.\n\n:param dirname: The directory to change to. If None, remains in the current directory.\n:yield: None\n\"\"\"",
                " make_executable": "\"\"\"\nMake the specified `script_path` executable by modifying its file permissions.\n\n:param script_path: The path to the script file to be made executable.\n\"\"\"",
                " simple_filter": "\"\"\"\nDecorate a function to wrap it in a simplified jinja2 extension.\n\n:param filter_function: The function to be wrapped as a jinja2 filter.\n:return: A jinja2 Extension class that registers the filter function.\n\"\"\"",
                " create_tmp_repo_dir": "\"\"\"Create a temporary directory with a copy of the contents of `repo_dir`.\n\n:param repo_dir: The directory whose contents are to be copied.\n:return: The path to the newly created temporary directory.\n\"\"\"",
                " create_env_with_context": "\"\"\"\nCreate a jinja environment using the provided context.\n\n:param context: A dictionary containing the context for the jinja environment.\n:return: A StrictEnvironment instance configured with the provided context.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\vcs.py": [
        {
            "global": {
                "identify_repo": "\"\"\"\nDetermine if `repo_url` should be treated as a URL to a git or hg repo.\n\nRepos can be identified by prepending \"hg+\" or \"git+\" to the repo URL.\n\n:param repo_url: Repo URL of unknown type.\n:returns: ('git', repo_url), ('hg', repo_url), or None.\n\"\"\"",
                "is_vcs_installed": "\"\"\"\nCheck if the version control system for a repo type is installed.\n\n:param repo_type: The type of the version control system (e.g., 'git', 'hg').\n:returns: True if the specified version control system is installed, False otherwise.\n\"\"\"",
                "clone": "\"\"\"\nClone a repository to the specified directory.\n\n:param repo_url: URL of the repository to clone.\n:param checkout: The branch, tag, or commit ID to checkout after cloning. Defaults to None.\n:param clone_to_dir: The directory to clone the repository into. Defaults to the current directory.\n:param no_input: If True, do not prompt for user input and force a refresh of cached resources. Defaults to False.\n:returns: The path to the newly cloned repository directory.\n:raises RepositoryNotFound: If the repository could not be found.\n:raises RepositoryCloneFailed: If the specified branch, tag, or commit could not be found.\n:raises VCSNotInstalled: If the required version control system is not installed.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\zipfile.py": [
        {
            "global": {
                "unzip": "    \"\"\"Download and unpack a zipfile at a given URI.\n\n    This will download the zipfile to the cookiecutter repository,\n    and unpack into a temporary directory.\n\n    :param zip_uri: The URI for the zipfile.\n    :param is_url: Is the zip URI a URL or a file?\n    :param clone_to_dir: The cookiecutter repository directory\n        to put the archive into.\n    :param no_input: Do not prompt for user input and eventually force a refresh of\n        cached resources.\n    :param password: The password to use when unpacking the repository.\n    :return: The path to the unpacked repository.\n    :raises InvalidZipRepository: If the zipfile is invalid or cannot be unpacked.\n    \"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\__init__.py": [
        {
            "global": {
                "_get_version": "\"\"\"\nRead VERSION.txt and return its contents.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\cookiecutter\\__main__.py": [
        {
            "global": {
                "main": "\"\"\"\nExecute the Cookiecutter command-line interface.\n\nThis function serves as the entry point when the module is run with `python -m cookiecutter`.\nIt initializes and runs the Cookiecutter CLI with the specified program name.\n\nParameters:\n    prog_name (str): The name of the program to be used in the CLI. Defaults to \"cookiecutter\".\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\docs\\conf.py": [
        {
            "global": {
                "```python\n[]\n```": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\docs\\__init__.py": [
        {
            "global": {
                "It looks like you have provided a comment or a docstring, but no actual source code. Please provide the source code from which you want to extract the method or function names.": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\conftest.py": [
        {
            "UserConfigData": {
                "```[]```": "\"\"\"\nRestore the default contents of the original directory from the backup directory.\n\n:param original_dir: The path to the original directory.\n:param backup_dir: The path to the backup directory.\n:param original_dir_found: Boolean indicating if the original directory was found.\n\"\"\"",
                "UserConfigData": "\"\"\"\nUserConfigData class is responsible for managing user configuration data, including restoring default contents of directories from backup directories. It provides functionality to ensure that the original directory can be restored from a backup, maintaining the integrity and availability of user configuration data.\n\nAttributes:\n    None\n\nMethods:\n    restore_default_contents(original_dir, backup_dir, original_dir_found):\n        Restore the default contents of the original directory from the backup directory.\n\"\"\""
            }
        },
        {
            "global": {
                "isolated_filesystem": "\"\"\"Ensure filesystem isolation, set the user home to a tmp_path.\n\nThis fixture automatically isolates the filesystem for each test by creating a \ntemporary home directory. It modifies the default configuration paths for \ncookiecutters and replay directories to point to this temporary location. \nAdditionally, it sets the environment variables `HOME` and `USERPROFILE` to \nthe temporary home directory.\n\nArgs:\n    monkeypatch: A pytest fixture used to safely set/delete an attribute, \n                 dictionary item or environment variable.\n    tmp_path: A pytest fixture that provides a temporary directory unique to \n              the test invocation.\n\"\"\"",
                "backup_dir": "\"\"\"\nCreate a backup of the specified directory.\n\nThis function checks if the original directory exists. If it does, it removes any existing backup directory and then copies the contents of the original directory to the backup directory.\n\nArgs:\n    original_dir (str): The path to the original directory to be backed up.\n    backup_dir (str): The path to the backup directory where the contents will be copied.\n\nReturns:\n    bool: True if the backup was successful, False if the original directory does not exist.\n\"\"\"",
                "restore_backup_dir": "\"\"\"Restore the original directory from a backup, handling various conditions.\n\nThis function handles the restoration of the original directory from a backup\ndirectory. It ensures that the original directory is properly restored based\non whether it was found initially and whether a backup exists.\n\nArgs:\n    original_dir (str): The path to the original directory to be restored.\n    backup_dir (str): The path to the backup directory from which to restore.\n    original_dir_found (bool): A flag indicating whether the original directory\n        was found initially.\n\nReturns:\n    None\n\"\"\"",
                "clean_system": "\"\"\"Fixture. Simulates a clean system with no configured or cloned cookiecutters.\n\nIt runs code which can be regarded as setup code as known from a unittest\nTestCase. Additionally it defines a local function referring to values\nwhich have been stored to local variables in the setup such as the location\nof the cookiecutters on disk. This function is registered as a teardown\nhook with `request.addfinalizer` at the very end of the fixture. Pytest\nruns the named hook as soon as the fixture is out of scope, when the test\nfinished to put it another way.\n\nDuring setup:\n\n* Back up the `~/.cookiecutterrc` config file to `~/.cookiecutterrc.backup`\n* Back up the `~/.cookiecutters/` dir to `~/.cookiecutters.backup/`\n* Back up the `~/.cookiecutter_replay/` dir to\n  `~/.cookiecutter_replay.backup/`\n* Starts off a test case with no pre-existing `~/.cookiecutterrc` or\n  `~/.cookiecutters/` or `~/.cookiecutter_replay/`\n\nDuring teardown:\n\n* Delete `~/.cookiecutters/` only if a backup is present at\n  `~/.cookiecutters.backup/`\n* Delete `~/.cookiecutter_replay/` only if a backup is present at\n  `~/.cookiecutter_replay.backup/`\n* Restore the `~/.cookiecutterrc` config file from\n  `~/.cookiecutterrc.backup`\n* Restore the `~/.cookiecutters/` dir from `~/.cookiecutters.backup/`\n* Restore the `~/.cookiecutter_replay/` dir from\n  `~/.cookiecutter_replay.backup/`\n\n\"\"\"",
                "restore_backup": "\"\"\"\nRestore the backup of the original directory.\n\nThis function restores the contents of the original directory from a backup\ndirectory. It handles cases where the original directory either existed or \nwas created during the process, ensuring that the original state is properly \nrestored.\n\n:param original_dir: The path to the original directory.\n:param backup_dir: The path to the backup directory.\n:param original_dir_found: A boolean indicating whether the original directory \n    was found before the backup process.\n\"\"\"",
                "user_dir": "\"\"\"Fixture that simulates the user's home directory.\n\nThis fixture creates a temporary directory that acts as the user's home directory\nfor the duration of the test session. It uses the `tmp_path_factory` to generate\na unique temporary directory.\n\n:param tmp_path_factory: Factory for temporary directories\n:returns: Path to the simulated user's home directory\n\"\"\"",
                "user_config_data": "\"\"\"\nFixture that creates 2 Cookiecutter user config dirs.\n\nIt will create it in the user's home directory.\n\n* `cookiecutters_dir`\n* `cookiecutter_replay`\n\n:returns: Dict with name of both user config dirs\n\"\"\"",
                "user_config_file": "\"\"\"\nFixture that creates a config file called `config`.\n\nIt will create it in the user's home directory, with YAML from\n`user_config_data`.\n\n:param user_dir: Simulated user's home directory\n:param user_config_data: Dict of config values\n:returns: String of path to config file\n\"\"\"",
                "output_dir": "\"\"\"Fixture to prepare test output directory.\n\nThis fixture creates a directory named 'output' inside the provided temporary path.\nIt ensures that the directory exists and returns the path to this directory as a string.\n\n:param tmp_path: Temporary path provided by pytest.\n:returns: String path to the created 'output' directory.\n\"\"\"",
                "clone_dir": "\"\"\"Simulate creation of a directory called `clone_dir` inside of `tmp_path`. Returns a Path to said directory.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_abort_generate_on_hook_error.py": [
        {
            "global": {
                "test_hooks_raises_errors": "\"\"\"\nVerify pre- and pos-gen errors raises correct error code from script.\n\nThis allows developers to make different error codes in their code,\nfor different errors.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_cli.py": [
        {
            "global": {
                "test_cli_version": "\"\"\"Verify Cookiecutter version output by `cookiecutter` on cli invocation.\n\nArgs:\n    cli_runner (function): A fixture that provides a helper function to run the cookiecutter CLI.\n    version_cli_flag (str): A fixture that provides the version flag for the CLI invocation.\n\nAsserts:\n    The exit code of the CLI invocation is 0.\n    The output of the CLI invocation starts with 'Cookiecutter'.\n\"\"\"",
                "test_cli_error_on_existing_output_directory": "\"\"\"\nTest cli invocation without `overwrite-if-exists` fail if dir exist.\n\nThis test ensures that when the `cookiecutter` CLI is invoked without the \n`overwrite-if-exists` flag, it fails if the output directory already exists.\n\nArgs:\n    cli_runner: A fixture that provides a helper function to run the cookiecutter CLI.\n\nAsserts:\n    The CLI invocation should return a non-zero exit code.\n    The output should contain an error message indicating that the directory already exists.\n\"\"\"\n",
                "test_cli": "\"\"\"\nTest cli invocation work without flags if directory not exist.\n\nThis test verifies that the Cookiecutter CLI can be invoked without any flags \nand successfully create a project directory if it does not already exist. \nIt checks that the exit code is 0, indicating success, and that the expected \nproject directory and its contents are created correctly.\n\"\"\"",
                "test_cli_verbose": "\"\"\"Test cli invocation display log if called with `verbose` flag.\n\nThis test ensures that when the Cookiecutter CLI is invoked with the `--verbose` flag,\nit correctly displays the log output. It verifies that the command completes successfully,\nthe expected project directory is created, and the content of the generated README file\ncontains the expected project name.\n\"\"\"",
                "test_cli_replay": "\"\"\"Test cli invocation display log with `verbose` and `replay` flags.\n\nThis test ensures that the Cookiecutter CLI correctly handles the `--replay` and `-v` (verbose) flags. It verifies that the `cookiecutter` function is called with the appropriate arguments and that the command exits successfully.\n\nArgs:\n    mocker: A pytest fixture for mocking.\n    cli_runner: A pytest fixture that provides a helper function to run the Cookiecutter CLI.\n\nAsserts:\n    The CLI command exits with a status code of 0.\n    The `cookiecutter` function is called once with the expected arguments.\n\"\"\"",
                "test_cli_replay_file": "\"\"\"Test cli invocation correctly pass --replay-file option.\n\n    This test verifies that the `cookiecutter` CLI correctly handles the\n    `--replay-file` option by passing it to the `cookiecutter` function.\n    \n    Args:\n        mocker: A pytest fixture for mocking.\n        cli_runner: A pytest fixture for running the CLI commands.\n    \"\"\"",
                "test_cli_replay_generated": "\"\"\"Test cli invocation correctly generates a project with replay.\n\nThis test verifies that the Cookiecutter CLI can correctly generate a project\nusing a replay file. It ensures that the replay file is properly utilized to\nrecreate a project with the same parameters as a previous run.\n\nArgs:\n    cli_runner: A fixture that provides a helper function to run the Cookiecutter CLI.\n\nAsserts:\n    The CLI exits with a status code of 0, indicating success.\n    The generated project's README.md file contains the expected content.\n\"\"\"",
                "test_cli_exit_on_noinput_and_replay": "\"\"\"\nTest cli invocation fails if both `no-input` and `replay` flags are passed.\n\nThis test ensures that the Cookiecutter CLI correctly handles the case where\nboth `--no-input` and `--replay` flags are provided simultaneously, which is\nan invalid combination. The test verifies that the CLI exits with an error\ncode and outputs the appropriate error message.\n\nArgs:\n    mocker: A pytest fixture for mocking objects.\n    cli_runner: A pytest fixture for running the Cookiecutter CLI.\n\nAssertions:\n    - The CLI exits with a non-zero exit code.\n    - The error message indicates that `replay` and `no_input` cannot be used together.\n    - The `cookiecutter` function is called with the expected arguments.\n\"\"\"\n",
                "test_run_cookiecutter_on_overwrite_if_exists_and_replay": "\"\"\"\nTest cli invocation with `overwrite-if-exists` and `replay` flags.\n\nThis test ensures that the Cookiecutter CLI correctly handles the scenario where both the `overwrite-if-exists` and `replay` flags are passed. It verifies that the CLI can overwrite existing directories and replay the previous context without errors.\n\nArgs:\n    mocker: A pytest fixture for mocking objects.\n    cli_runner: A pytest fixture that provides a helper function to run the Cookiecutter CLI.\n    overwrite_cli_flag: A pytest fixture that returns all `overwrite-if-exists` invocation options.\n\nAsserts:\n    The CLI exits with a status code of 0.\n    The `cookiecutter` function is called with the correct arguments, including `overwrite_if_exists=True` and `replay=True`.\n\"\"\"\n",
                "test_cli_overwrite_if_exists_when_output_dir_does_not_exist": "\"\"\"\nTest cli invocation with `overwrite-if-exists` and `no-input` flags.\n\nCase when output dir not exist.\n\"\"\"",
                "test_cli_overwrite_if_exists_when_output_dir_exists": "\"\"\"\nTest cli invocation with `overwrite-if-exists` and `no-input` flags.\n\nCase when output dir already exist.\n\"\"\"",
                "test_cli_output_dir": "\"\"\"\nTest cli invocation with `output-dir` flag changes output directory.\n\nArgs:\n    mocker: Mock object to replace parts of the system under test.\n    cli_runner: Fixture to run the cookiecutter CLI.\n    output_dir_flag: The flag used to specify the output directory.\n    output_dir: The directory where the output should be generated.\n\"\"\"",
                "test_cli_help": "\"\"\"Test cli invocation display help message with `help` flag.\n\n    Args:\n        cli_runner: A fixture that provides a helper function to run the cookiecutter CLI.\n        help_cli_flag: A fixture that provides different help flag options for the CLI.\n\n    Asserts:\n        The CLI exits with a code of 0.\n        The output starts with 'Usage'.\n    \"\"\"",
                "test_user_config": "\"\"\"Test cli invocation works with `config-file` option.\n\nThis test ensures that the Cookiecutter CLI can be invoked with a specified \nconfiguration file. It mocks the `cookiecutter` function to verify that it \nis called with the correct parameters, including the `config-file` option.\n\nArgs:\n    mocker: A pytest fixture that allows mocking.\n    cli_runner: A pytest fixture that provides a helper function to run the CLI.\n    user_config_path: A pytest fixture that provides the path to the user configuration file.\n\"\"\"",
                "test_default_user_config_overwrite": "\"\"\"Test cli invocation ignores `config-file` if `default-config` passed.\n\nThis test ensures that when both `--config-file` and `--default-config` options are passed to the CLI, the `--default-config` option takes precedence, and the `config-file` is ignored.\n\nArgs:\n    mocker: A pytest fixture for mocking objects.\n    cli_runner: A pytest fixture for running the CLI commands.\n    user_config_path: The path to the user configuration file.\n\nAsserts:\n    The CLI command exits with a status code of 0.\n    The `cookiecutter` function is called with the `default_config` set to True and the `config_file` set to the provided user configuration path.\n\"\"\"",
                "test_default_user_config": "\"\"\"\nTest the `default-config` flag in the Cookiecutter CLI.\n\nThis test ensures that the `default-config` flag is correctly accepted by the\nCookiecutter CLI and that it overrides any provided `config-file` option.\n\nArgs:\n    mocker: A mocker object to patch the `cookiecutter` function.\n    cli_runner: A fixture that provides a helper function to run the Cookiecutter CLI.\n\nAsserts:\n    The CLI invocation exits with a status code of 0.\n    The `cookiecutter` function is called with the correct arguments, including\n    `default_config=True` and `config_file=None`.\n\"\"\"",
                "test_echo_undefined_variable_error": "\"\"\"\nCli invocation return error if variable undefined in template.\n\nArgs:\n    output_dir (str): The directory where the output will be generated.\n    cli_runner (function): A function to run the cookiecutter CLI.\n\nAsserts:\n    The function asserts that the CLI invocation returns an error if a variable is undefined in the template.\n    It checks for specific error messages in the output to ensure the correct error handling.\n\"\"\"",
                "test_echo_unknown_extension_error": "\"\"\"\nCli return error if extension incorrectly defined in template.\n\nArgs:\n    output_dir (str): The directory where the output should be stored.\n    cli_runner (function): A function to run the cookiecutter CLI.\n\nAsserts:\n    The CLI returns an exit code of 1.\n    The error message 'Unable to load extension: ' is present in the output.\n\"\"\"",
                "test_local_extension": "\"\"\"\nTest to verify correct work of extension, included in template.\n\nThis test ensures that a local extension included in the template works correctly.\nIt runs the cookiecutter CLI with the specified template and checks the generated\ncontent for expected values.\n\nArgs:\n    tmpdir: Temporary directory provided by pytest.\n    cli_runner: Fixture to run the cookiecutter CLI.\n\nAsserts:\n    The CLI command exits with a status code of 0.\n    The generated content contains the expected values.\n\"\"\"",
                "test_local_extension_not_available": "\"\"\"\nTest handling of included but unavailable local extension.\n\nThis test verifies that the `StrictEnvironment` raises an `UnknownExtension` \nexception when a local extension specified in the context is not available.\n\"\"\"",
                "test_cli_extra_context": "\"\"\"\nTest CLI invocation replaces content if called with replacement pairs.\n\nThis test verifies that the Cookiecutter CLI correctly replaces content in the generated project\nwhen called with extra context arguments in the form of key-value pairs.\n\nArgs:\n    cli_runner (function): A fixture that provides a helper function to run the Cookiecutter CLI.\n\nAssertions:\n    - The CLI invocation should exit with a status code of 0, indicating success.\n    - The generated project directory should exist.\n    - The content of the README.rst file in the generated project should contain the replaced project name.\n\"\"\"\n",
                "test_cli_extra_context_invalid_format": "\"\"\"Cli invocation raise error if called with unknown argument.\n\nThis test ensures that the CLI raises an appropriate error when an invalid \nextra context argument is passed, i.e., an argument that does not follow \nthe key=value format.\n\"\"\"",
                "test_debug_file_non_verbose": "\"\"\"Test cli invocation writes log to `debug-file` if flag enabled.\n\nCase for normal log output.\n\"\"\"",
                "test_debug_file_verbose": "\"\"\"Test cli invocation writes log to `debug-file` if flag enabled.\n\n    Case for verbose log output.\n    \"\"\"",
                "test_debug_list_installed_templates": "\"\"\"Verify --list-installed command correct invocation.\n\nThis test checks if the `--list-installed` command correctly lists the installed templates.\nIt sets up a fake project directory and a user configuration file, then runs the CLI with the `--list-installed` flag.\nThe test asserts that the output contains the expected message indicating the number of installed templates.\n\"\"\"\n",
                "test_debug_list_installed_templates_failure": "\"\"\"Verify --list-installed command error on invocation.\n\nThis test checks that the `--list-installed` command returns an error when invoked with an invalid configuration file path.\n\"\"\"",
                "test_directory_repo": "\"\"\"Test cli invocation works with `directory` option.\n\nThis test ensures that the Cookiecutter CLI can correctly handle the `--directory` option, which specifies a subdirectory within the template repository to use as the template root. The test verifies that the command completes successfully, creates the expected output directory, and generates the correct project files.\n\"\"\"",
                "test_cli_accept_hooks": "\"\"\"\nTest cli invocation works with `accept-hooks` option.\n\nParameters:\n    mocker: pytest fixture for mocking.\n    cli_runner: pytest fixture for running CLI commands.\n    output_dir_flag: pytest fixture for output directory flag.\n    output_dir: Directory where the output will be stored.\n    accept_hooks_arg: Argument for the `accept-hooks` option.\n    user_input: User input for the `accept-hooks` prompt.\n    expected: Expected value for the `accept-hooks` option.\n\nThis test verifies that the `accept-hooks` option is correctly passed to the \ncookiecutter function when invoking the CLI. It checks various scenarios \nincluding accepting hooks, rejecting hooks, and prompting the user for input.\n\"\"\"",
                "test_cli_with_json_decoding_error": "\"\"\"Test cli invocation with a malformed JSON file.\n\nThis test ensures that the CLI correctly handles and reports errors when \nencountering a malformed JSON file in the template. It verifies that the \nappropriate error message is displayed, including details about the JSON \nparsing error and the file name where the error occurred.\n\nArgs:\n    cli_runner: A fixture that provides a helper function to run the \n                cookiecutter CLI.\n\"\"\"",
                "test_cli_with_pre_prompt_hook": "\"\"\"\nTest cli invocation in a template with pre_prompt hook.\n\nThis test ensures that the CLI can correctly handle a template that includes a pre_prompt hook.\nIt verifies that the hook is executed and the expected project directory is created with the correct content.\n\nArgs:\n    cli_runner: A fixture that provides a helper function to run the cookiecutter CLI.\n\nAsserts:\n    The CLI invocation exits with a status code of 0.\n    The expected project directory is created.\n    The content of the README.rst file in the project directory contains the expected text.\n\"\"\"",
                "test_cli_with_pre_prompt_hook_fail": "\"\"\"Test cli invocation will fail when a given env var is present.\n\nThis test ensures that the CLI correctly handles the scenario where a \npre_prompt hook is designed to fail based on the presence of a specific \nenvironment variable. The test sets the environment variable \n'COOKIECUTTER_FAIL_PRE_PROMPT' to '1' and verifies that the CLI invocation \nfails and the expected directory is not created.\n\nArgs:\n    cli_runner: A fixture that provides a helper function to run the \n                cookiecutter CLI.\n    monkeypatch: A fixture that allows temporary modification of the \n                 environment variables.\n\nAssertions:\n    The test asserts that the CLI invocation exits with a non-zero status \n    code and that the expected directory is not created.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_cookiecutter_invocation.py": [
        {
            "global": {
                "test_should_invoke_main": "\"\"\"\nShould create a project and exit with 0 code on cli invocation.\n\nThis test ensures that the Cookiecutter CLI can be invoked directly to create a project \nfrom a template repository without any user input, and that it exits with a status code of 0.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_cookiecutter_local_no_input.py": [
        {
            "global": {
                "test_cookiecutter_no_input_return_project_dir": "\"\"\"\nVerify `cookiecutter` creates project directory on input with or without trailing slash.\n\nArgs:\n    path (str): The path to the cookiecutter template directory.\n\nAsserts:\n    bool: Checks if the project directory is created correctly.\n    bool: Ensures the project directory does not exist in the wrong location.\n    bool: Verifies the existence of the project directory.\n    bool: Confirms the presence of the README file in the project directory.\n    bool: Ensures the 'json' directory does not exist in the project directory.\n\"\"\"\n",
                "test_cookiecutter_no_input_extra_context": "\"\"\"Verify `cookiecutter` accepts the `extra_context` argument and uses it to create the project directory with the specified context.\n\nThis test ensures that when the `extra_context` argument is provided to the `cookiecutter` function, it correctly uses the context to create a project directory with the specified name.\n\nAssertions:\n- The project directory specified in `extra_context` is created.\n\"\"\"",
                "test_cookiecutter_templated_context": "\"\"\"Verify Jinja2 templating correctly works in `cookiecutter.json` file by creating a project with templated context.\"\"\"\n",
                "test_cookiecutter_no_input_return_rendered_file": "\"\"\"\nVerify Jinja2 templating correctly works in `cookiecutter.json` file and the rendered file is returned.\n\nThis test ensures that the `cookiecutter` function correctly processes the template specified in \n`cookiecutter.json` and returns the path to the rendered project directory. It also verifies that \nthe content of the rendered `README.rst` file contains the expected text.\n\nAssertions:\n- The returned project directory path matches the expected absolute path.\n- The content of the `README.rst` file in the project directory contains the string \"Project name: **Fake Project**\".\n\"\"\"",
                "test_cookiecutter_dict_values_in_context": "\"\"\"\nVerify configured dictionary from `cookiecutter.json` is correctly unpacked.\n\nThis test ensures that when `cookiecutter` is executed with a template containing\na dictionary in `cookiecutter.json`, the dictionary values are correctly rendered\nin the generated project files.\n\nAssertions:\n- The project directory is created at the expected path.\n- The content of the `README.md` file in the generated project matches the expected\n  structure and values, including nested lists and dictionary entries.\n\"\"\"",
                "test_cookiecutter_template_cleanup": "\"\"\"Verify temporary folder for zip unpacking is removed after use.\n\nThis test ensures that the temporary directory created for unpacking the zip file\nis cleaned up properly after the `cookiecutter` function is executed.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_cookiecutter_local_with_input.py": [
        {
            "global": {
                "test_cookiecutter_local_with_input": "\"\"\"Verify simple cookiecutter run results, without extra_context provided.\"\"\"",
                "test_cookiecutter_input_extra_context": "\"\"\"\nVerify cookiecutter run results with extra_context provided.\n\nThis test ensures that the cookiecutter template is correctly processed when \nadditional context is provided, and the resulting project structure is as expected.\n\nArgs:\n    monkeypatch: pytest fixture for safely patching and restoring attributes.\n\"\"\"\n"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_cookiecutter_nested_templates.py": [
        {
            "global": {
                "test_cookiecutter_nested_templates": "\"\"\"Verify cookiecutter nested configuration files mechanism.\n\nArgs:\n    mocker: A pytest fixture for mocking.\n    template_dir (str): The directory containing the template.\n    output_dir (str): The expected output directory.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_custom_extensions_in_hooks.py": [
        {
            "global": {
                "test_hook_with_extension": "\"\"\"Verify custom Jinja2 extension correctly work in hooks and file rendering.\n\nEach file in hooks has simple tests inside and will raise error if not\ncorrectly rendered.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_default_extensions.py": [
        {
            "global": {
                "freeze": "\"\"\"\nFixture. Make time static during all tests in this file.\n\"\"\"",
                "test_jinja2_time_extension": "\"\"\"Verify Jinja2 time extension work correctly.\n\nThis test ensures that the Jinja2 time extension is functioning as expected by \ngenerating a project using Cookiecutter and checking the contents of the \ngenerated 'HISTORY.rst' file for the correct date and release information.\n\nArgs:\n    tmp_path (pathlib.Path): A temporary directory path provided by pytest.\n\nRaises:\n    AssertionError: If the 'HISTORY.rst' file does not exist or its contents do \n    not match the expected lines.\n\"\"\"",
                "test_jinja2_slugify_extension": "\"\"\"Verify Jinja2 slugify extension work correctly.\"\"\"",
                "test_jinja2_uuid_extension": "\"\"\"Verify Jinja2 uuid extension work correctly.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_environment.py": [
        {
            "StrictEnvironment": {
                "[]": "DONE",
                "StrictEnvironment": "\"\"\"\nStrictEnvironment class.\n\nThis class is designed to provide a strict and controlled environment for executing specific tasks or operations. The functions within this class are tailored to ensure that the operations are performed with precision and adherence to predefined rules and constraints.\n\nAttributes and methods within this class are documented individually to provide detailed information on their specific roles and functionalities.\n\"\"\""
            }
        },
        {
            "UnknownExtension": {
                "[]": "DONE",
                "UnknownExtension": "\"\"\"\nUnknownExtension class serves as a placeholder or a base class for extensions whose functionality is not yet defined or implemented. This class may be used as a template or a starting point for future extensions, ensuring that the structure and necessary components are in place for further development.\n\"\"\""
            }
        },
        {
            "global": {
                "test_env_should_raise_for_unknown_extension": "\"\"\"Test should raise if extension not installed in system.\"\"\"",
                "test_env_should_come_with_default_extensions": "\"\"\"Verify default extensions loaded with StrictEnvironment.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_exceptions.py": [
        {
            "global": {
                "test_undefined_variable_to_str": "\"\"\"Verify string representation of errors formatted in expected form.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_find.py": [
        {
            "global": {
                "test_find_template": "\"\"\"Verify correctness of `find.find_template` path detection.\n\nArgs:\n    repo_name (str): The name of the repository to test.\n    env (dict): The environment context for the template.\n    error_expectation (context manager): The expected error context.\n    expected (str): The expected template path.\n\nRaises:\n    NonTemplatedInputDirException: If the input directory is not templated as expected.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_context.py": [
        {
            "global": {
                "context_data": "\"\"\"Generate pytest parametrization variables for test.\n\nReturn ('input_params, expected_context') tuples.\n\"\"\"",
                "test_generate_context": "\"\"\"Verify input contexts combinations result in expected content on output.\"\"\"",
                "test_generate_context_with_json_decoding_error": "\"\"\"Verify malformed JSON file generates expected error output.\n\nThis test ensures that when a JSON file with invalid syntax is provided to the \n`generate_context` function, a `ContextDecodingException` is raised. The test \nalso checks that the error message contains the expected details, including the \nspecific JSON syntax error and the file name.\n\"\"\"",
                "test_default_context_replacement_in_generate_context": "\"\"\"\nVerify default content settings are correctly replaced by template settings.\n\nMake sure that the default for list variables of `orientation` is based on\nthe user config (`choices_template.json`) and not changed to a single value\nfrom `default_context`.\n\"\"\"",
                "test_generate_context_decodes_non_ascii_chars": "\"\"\"Test that `generate_context` correctly decodes non-ASCII characters from the context file.\"\"\"",
                "test_apply_overwrites_does_include_unused_variables": "\"\"\"Verify `apply_overwrites_to_context` skips variables that are not in context.\n\nArgs:\n    template_context (OrderedDict): The context dictionary to apply overwrites to.\n\nAsserts:\n    The variable 'not in template' is not added to the template context.\n\"\"\"",
                "test_apply_overwrites_sets_non_list_value": "\"\"\"Verify `apply_overwrites_to_context` works with string variables.\n\nEnsure that when a non-list value (e.g., a string) is provided in the overwrite context, \nit correctly replaces the existing value in the template context.\n\"\"\"",
                "test_apply_overwrites_does_not_modify_choices_for_invalid_overwrite": "\"\"\"Verify variables overwrite for list if variable not in list ignored.\n\nEnsure that when attempting to overwrite a list variable with a value that is not in the list of valid choices, the original list remains unchanged.\n\"\"\"",
                "test_apply_overwrites_invalid_overwrite": "\"\"\"Verify that applying an invalid overwrite to a list variable raises a ValueError.\n\nThis test ensures that when an invalid value is provided for a list variable in the \ncontext, the `apply_overwrites_to_context` function raises a ValueError, indicating \nthat the overwrite was not accepted.\n\"\"\"",
                "test_apply_overwrites_sets_multichoice_values": "\"\"\"Verify variable overwrite for list given multiple valid values.\n\nThis test ensures that the `apply_overwrites_to_context` function correctly \noverwrites the values of a list variable in the context when provided with \nmultiple valid values.\n\"\"\"",
                "test_apply_overwrites_invalid_multichoice_values": "\"\"\"Verify variable overwrite for list given invalid list entries not ignored.\n\nThis test ensures that when attempting to overwrite a list variable with invalid entries,\nthe operation raises a ValueError, indicating that the invalid entries are not accepted.\n\"\"\"",
                "test_apply_overwrites_error_additional_values": "\"\"\"Verify variable overwrite for list given additional entries not ignored.\n\nEnsure that when attempting to overwrite a list variable with additional \nentries that are not part of the original list, a ValueError is raised.\n\"\"\"",
                "test_apply_overwrites_in_dictionaries": "\"\"\"Verify variable overwrite for lists nested in dictionary variables.\n\nThis test ensures that the `apply_overwrites_to_context` function correctly \noverwrites list values that are nested within dictionary variables in the \ncontext. It checks that the specified nested list values are updated as \nexpected.\n\"\"\"",
                "test_apply_overwrites_sets_default_for_choice_variable": "\"\"\"Verify overwritten list member became a default value.\n\nEnsure that when a list member is overwritten in the context, it becomes the default value \nwhile preserving the original order of the list.\n\"\"\"",
                "test_apply_overwrites_in_nested_dict": "\"\"\"\nVerify nested dictionary values in the default content settings are correctly replaced by the provided extra context.\n\nThis test ensures that when a nested dictionary is provided in the default context settings, it is correctly overwritten by the values in the extra context. The function `generate.generate_context` is used to generate the context, and the resulting context is compared to the expected context to verify correctness.\n\"\"\"",
                "test_apply_overwrite_context_as_in_nested_dict_with_additional_values": "\"\"\"Verify nested dict in default content settings are correctly added.\n\nThe `apply_overwrites_to_context` function should add the extra values to the dict.\n\"\"\"",
                "test_apply_overwrites_in_nested_dict_additional_values": "\"\"\"Verify nested dict in default content settings are correctly added.\n\nEnsure that additional values in nested dictionaries are properly incorporated \ninto the context when generating the final context.\n\"\"\"",
                "test_apply_overwrites_overwrite_value_as_boolean_string": "\"\"\"\nVerify boolean conversion for valid overwrite values.\n\nParameters:\n    overwrite_value (str): The string representation of a boolean value to overwrite.\n    expected (dict): The expected context after applying the overwrite.\n\nAsserts:\n    The context is correctly updated with the boolean value derived from the string.\n\"\"\"",
                "test_apply_overwrites_error_overwrite_value_as_boolean_string": "\"\"\"Verify boolean conversion for invalid overwrite values.\n\nEnsure that when an invalid string is provided for a boolean overwrite, \nthe function raises a ValueError.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_copy_without_render.py": [
        {
            "global": {
                "test_generate_copy_without_render_extensions": "\"\"\"Test the `_copy_without_render` context option in the `generate_files` function.\n\nThis test ensures that certain files and directories are copied without rendering,\nwhile others are rendered as expected during the invocation of the `generate_files` function.\n\nThe test verifies:\n- Files and directories specified in `_copy_without_render` are copied without modification.\n- Other files and directories are rendered correctly based on the provided context.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_copy_without_render_override.py": [
        {
            "global": {
                "test_generate_copy_without_render_extensions": "\"\"\"\nTest the `_copy_without_render` context option in the `generate_files` function.\n\nThis test ensures that certain files and directories are either rendered or copied \nwithout modification based on the `_copy_without_render` context option. It performs \ntwo runs of the `generate_files` function, one with default settings and another \nwith the `overwrite_if_exists` flag set to True. The test then verifies the contents \nof the generated files to ensure they meet the expected rendering or copying behavior.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_file.py": [
        {
            "global": {
                "test_generate_file": "\"\"\"Verify simple file is generated with rendered context data.\"\"\"",
                "test_generate_file_jsonify_filter": "\"\"\"Verify jsonify filter works during files generation process.\n\nThis test ensures that the `jsonify` filter correctly converts the context data \ninto a JSON string during the file generation process. It checks that the \ngenerated file contains the expected JSON data.\n\"\"\"",
                "test_generate_file_random_ascii_string": "\"\"\"\nVerify the correct functionality of the random_ascii_string extension during file generation.\n\nParameters:\nenv (StrictEnvironment): The Jinja2 environment used for rendering templates.\nlength (int): The length of the random ASCII string to be generated.\npunctuation (bool): Whether to include punctuation in the random ASCII string.\n\"\"\"",
                "test_generate_file_with_true_condition": "\"\"\"Verify correct work of boolean condition in file name on file generation.\n\nThis test has positive answer, so file should be rendered.\n\"\"\"",
                "test_generate_file_with_false_condition": "\"\"\"Verify correct work of boolean condition in file name on file generation.\n\nThis test has negative answer, so file should not be rendered.\n\"\"\"",
                "test_generate_file_verbose_template_syntax_error": "\"\"\"\nVerify correct exception raised on syntax error in file before generation.\n\nThis test ensures that a TemplateSyntaxError is raised when there is a syntax error\nin the template file being processed. It checks that the exception message matches\nthe expected regular expression pattern.\n\"\"\"",
                "test_generate_file_does_not_translate_lf_newlines_to_crlf": "\"\"\"Verify that file generation uses the same LF line endings as in the source file.\"\"\"",
                "test_generate_file_does_not_translate_crlf_newlines_to_lf": "\"\"\"\nVerify that file generation uses the same line ending as in the source file.\n\nThis test ensures that files with CRLF line endings in the source are generated\nwith CRLF line endings in the output.\n\"\"\"",
                "test_generate_file_handles_mixed_line_endings": "\"\"\"Verify that file generation gracefully handles mixed line endings.\n\nThis test ensures that the `generate_file` function can handle files with mixed\nline endings (both CRLF and LF) without causing errors or inconsistencies in the\ngenerated file.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_files.py": [
        {
            "global": {
                "test_generate_files_nontemplated_exception": "\"\"\"\nVerify `generate_files` raises when no directories to render exist.\n\nNote: Check `tests/test-generate-files-nontemplated` location to understand.\n\"\"\"",
                "test_generate_files": "\"\"\"\nVerify directory name correctly rendered with unicode containing context.\n\nThis test ensures that the `generate_files` function correctly renders directory names\nthat include unicode characters from the provided context. It checks that the generated\nfile exists and contains the expected content.\n\"\"\"",
                "test_generate_files_with_linux_newline": "\"\"\"\nVerify new line not removed by templating engine after folder generation.\n\"\"\"",
                "test_generate_files_with_jinja2_environment": "\"\"\"\nExtend StrictEnvironment with _jinja2_env_vars cookiecutter template option.\n\nThis test verifies that the `generate_files` function correctly extends the \nJinja2 environment with the options specified in the `_jinja2_env_vars` key \nof the context dictionary. It ensures that the generated files reflect the \nJinja2 environment settings provided.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path provided by pytest.\n\nRaises:\n    AssertionError: If the generated file does not exist or its content does \n    not match the expected output.\n\"\"\"",
                "test_generate_files_with_trailing_newline_forced_to_linux_by_context": "\"\"\"\nVerify new line not removed by templating engine after folder generation when \ncontext forces trailing newlines to Linux format.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path for test output.\n\"\"\"",
                "test_generate_files_with_windows_newline": "\"\"\"Verify windows source line end not changed during files generation.\"\"\"",
                "test_generate_files_with_windows_newline_forced_to_linux_by_context": "\"\"\"Verify windows line end changed to linux during files generation.\n\nThis test ensures that when the context specifies a Linux newline character (`\\n`),\nthe generated files will have their Windows newline characters (`\\r\\n`) converted\nto Linux newline characters (`\\n`).\n\nArgs:\n    tmp_path: A temporary directory path provided by pytest for file generation.\n\nRaises:\n    AssertionError: If the generated file does not exist or the newline characters\n                    are not converted as expected.\n\"\"\"",
                "test_generate_files_binaries": "\"\"\"\nVerify binary files created during directory generation.\n\nThis test ensures that the `generate_files` function correctly handles the creation\nof binary files within the generated directory structure. It checks that specific\nbinary files (e.g., images, fonts) are identified as binary and that text files\nare not mistakenly identified as binary.\n\"\"\"",
                "test_generate_files_absolute_path": "\"\"\"\nVerify usage of absolute path does not change files generation behaviour.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path for test output.\n\"\"\"",
                "test_generate_files_output_dir": "\"\"\"\nVerify `output_dir` option for `generate_files` changing location correctly.\n\nThis test ensures that the `generate_files` function correctly uses the \n`output_dir` parameter to change the location where files are generated. \nIt verifies that the files are created in the specified custom output directory.\n\"\"\"",
                "test_generate_files_permissions": "\"\"\"\nVerify generates files respect source files permissions.\n\nsimple.txt and script.sh should retain their respective 0o644 and 0o755\npermissions.\n\"\"\"",
                "test_generate_files_with_overwrite_if_exists_with_skip_if_file_exists": "\"\"\"\nVerify `skip_if_file_exist` has priority over `overwrite_if_exists`.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path provided by pytest.\n\nThis test ensures that when both `skip_if_file_exists` and `overwrite_if_exists` \noptions are set to True, the `skip_if_file_exists` option takes precedence, \nmeaning existing files will not be overwritten.\n\"\"\"",
                "test_generate_files_with_skip_if_file_exists": "\"\"\"\nVerify existed files are not removed if an error is raised with `skip_if_file_exists`.\n\nThis test ensures that when the `skip_if_file_exists` option is enabled, existing files are not deleted if an error occurs during the file generation process.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path provided by pytest.\n\nRaises:\n    exceptions.OutputDirExistsException: If the output directory already exists.\n\"\"\"",
                "test_generate_files_with_overwrite_if_exists": "\"\"\"\nVerify `generate_files` correctly overwrites existing files when `overwrite_if_exists` is set to True.\n\"\"\"",
                "test_raise_undefined_variable_file_name": "\"\"\"\nVerify correct error raised when file name cannot be rendered.\n\nArgs:\n    output_dir (Path): The directory where the output files should be generated.\n    undefined_context (dict): The context containing variables for rendering templates.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If a variable in the template is undefined.\n\"\"\"\n",
                "test_raise_undefined_variable_file_name_existing_project": "\"\"\"\nVerify correct error raised when file name cannot be rendered in an existing project.\n\nArgs:\n    output_dir (Path): The directory where the output files should be generated.\n    undefined_context (dict): The context containing variables for rendering templates.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If a variable in the template is undefined.\n\"\"\"\n",
                "test_raise_undefined_variable_file_content": "\"\"\"\nVerify correct error raised when file content cannot be rendered.\n\nArgs:\n    output_dir (Path): The directory where the files should be generated.\n    undefined_context (dict): The context containing variables for rendering templates.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If a variable in the file content is undefined.\n\"\"\"\n",
                "test_raise_undefined_variable_dir_name": "\"\"\"\nVerify correct error raised when directory name cannot be rendered.\n\nThis test ensures that the `generate_files` function raises an \n`UndefinedVariableInTemplate` exception when it encounters an undefined \nvariable in the directory name template. It checks that the error message \nand context are correctly set and that the directory is not created.\n\nArgs:\n    output_dir (Path): The output directory where files are generated.\n    undefined_context (dict): The context containing template variables.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If a variable in the directory \n    name template is undefined.\n\"\"\"\n",
                "test_keep_project_dir_on_failure": "\"\"\"\nVerify correct error raised when directory name cannot be rendered and project directory is kept on failure.\n\nArgs:\n    output_dir (Path): The output directory where the project should be generated.\n    undefined_context (dict): The context containing variables for rendering the template.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If a variable in the template is undefined.\n\"\"\"\n",
                "test_raise_undefined_variable_dir_name_existing_project": "\"\"\"\nVerify correct error raised when directory name cannot be rendered.\n\nThis test ensures that the `generate_files` function raises an \n`UndefinedVariableInTemplate` exception when it encounters an undefined \nvariable in the directory name, even if the project directory already exists.\n\nArgs:\n    output_dir (Path): The output directory where files are generated.\n    undefined_context (dict): The context containing variables for rendering.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If the directory name cannot be rendered.\n\"\"\"\n",
                "test_raise_undefined_variable_project_dir": "\"\"\"\nVerify correct error raised when project directory name cannot be rendered.\n\"\"\"",
                "test_raise_empty_dir_name": "\"\"\"Verify correct error raised when directory name is empty.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_generate_hooks.py": [
        {
            "global": {
                "test_ignore_hooks_dirs": "\"\"\"Verify hooks directory not created in target location on files generation.\"\"\"",
                "test_run_python_hooks": "\"\"\"\nVerify pre and post generation python hooks executed and result in output_dir.\n\nEach hook should create in target directory. Test verifies that these files\ncreated.\n\"\"\"",
                "test_run_python_hooks_cwd": "\"\"\"Verify pre and post generation python hooks executed and result in current dir.\n\nEach hook should create in target directory. Test verifies that these files\ncreated.\n\"\"\"",
                "test_empty_hooks": "\"\"\"Verify error is raised on empty hook script. Ignored on windows.\n\nOSError.errno=8 is not thrown on Windows when the script is empty\nbecause it always runs through shell instead of needing a shebang.\n\"\"\"",
                "test_oserror_hooks": "\"\"\"Verify script error is passed correctly to cookiecutter error.\n\nThis test mocks the subprocess.Popen function to simulate an OSError with \nerrno set to ENOMEM (Out of memory). It ensures that the error is correctly \npropagated as a FailedHookException by the cookiecutter generate_files function.\n\"\"\"",
                "test_run_failing_hook_removes_output_directory": "\"\"\"Verify that the output directory is not created or is removed if a hook fails.\n\nThis test sets up a repository with a failing pre-generation hook and ensures that\nthe output directory is either not created or is removed if the hook fails during\nthe project generation process.\n\"\"\"",
                "test_run_failing_hook_preserves_existing_output_directory": "\"\"\"Verify project directory is not removed if it existed before the hook failed.\n\nThis test ensures that if a hook script fails, the existing output directory \nis preserved and not deleted. It sets up a repository with a failing pre-generation \nhook and checks that the pre-existing output directory remains intact after the \nhook failure.\n\"\"\"",
                "test_run_shell_hooks": "\"\"\"Verify pre and post generate project shell hooks executed.\n\nThis test for .sh files.\n\"\"\"",
                "test_run_shell_hooks_win": "\"\"\"Verify pre and post generate project shell hooks executed.\n\nThis test for .bat files.\n\"\"\"",
                "test_ignore_shell_hooks": "\"\"\"Verify *.txt files not created, when accept_hooks=False.\n\nThis test ensures that when the `accept_hooks` parameter is set to False,\nthe shell hook scripts do not generate their respective output files.\n\"\"\"",
                "test_deprecate_run_hook_from_repo_dir": "\"\"\"Test deprecation warning in generate._run_hook_from_repo_dir.\n\nThis test ensures that a deprecation warning is issued when the \ngenerate._run_hook_from_repo_dir function is called. It sets up a \nrepository directory and a project directory, then calls the function \nwithin a pytest.deprecated_call context to check for the warning.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_get_config.py": [
        {
            "global": {
                "test_merge_configs": "\"\"\"Verify default and user config merged in expected way.\"\"\"",
                "test_get_config": "\"\"\"Verify valid config opened and rendered correctly.\"\"\"",
                "test_get_config_does_not_exist": "\"\"\"Check that `exceptions.ConfigDoesNotExistException` is raised when attempting to get a non-existent config file.\"\"\"",
                "test_invalid_config": "\"\"\"An invalid config file should raise an `InvalidConfiguration` exception.\"\"\"",
                "test_get_config_with_defaults": "\"\"\"Test loading a config file that overrides one of the three default settings.\"\"\"",
                "test_get_config_empty_config_file": "\"\"\"An empty config file results in the default config.\"\"\"",
                "test_get_config_invalid_file_with_array_as_top_level_element": "\"\"\"An exception should be raised if top-level element is array.\n\nThis test verifies that attempting to load a configuration file where the \ntop-level element is an array raises an `InvalidConfiguration` exception.\n\"\"\"",
                "test_get_config_invalid_file_with_multiple_docs": "\"\"\"An exception should be raised if the config file contains multiple documents.\"\"\"\n"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_get_user_config.py": [
        {
            "global": {
                "test_get_user_config_valid": "\"\"\"Validate user config is correctly parsed if it exists and is correctly formatted.\"\"\"",
                "test_get_user_config_invalid": "\"\"\"Validate `InvalidConfiguration` raised when provided user config malformed.\"\"\"",
                "test_get_user_config_nonexistent": "\"\"\"Validate default app config returned, if user does not have own config.\"\"\"",
                "test_specify_config_path": "\"\"\"Validate provided custom config path should be respected and parsed.\n\nThis test ensures that when a custom configuration path is specified, the \nconfiguration is correctly read and parsed from that path. It uses a mock \nspy to verify that the `get_config` function is called with the correct \ncustom configuration path and asserts that the returned user configuration \nmatches the expected custom configuration.\n\nArgs:\n    mocker: A pytest fixture for mocking.\n    custom_config_path: The path to the custom user configuration file.\n    custom_config: The expected custom configuration dictionary.\n\"\"\"",
                "test_default_config_path": "\"\"\"Validate app configuration. User config path should match default path.\"\"\"",
                "test_default_config_from_env_variable": "\"\"\"\nValidate app configuration. User config path should be parsed from sys env.\n\nThis test sets the 'COOKIECUTTER_CONFIG' environment variable to a custom config path\nand verifies that the user configuration is correctly parsed from this path.\n\nArgs:\n    monkeypatch: pytest fixture for safely patching and restoring attributes.\n    custom_config_path: Path to the custom user config for tests.\n    custom_config: Expected custom configuration for validation.\n\"\"\"\n",
                "test_force_default_config": "\"\"\"Validate `default_config=True` should ignore provided custom user config.\n\nThis test ensures that when the `default_config` parameter is set to True,\nthe function `get_user_config` will return the default configuration, \nignoring any custom user configuration provided via the `custom_config_path`.\n\nArgs:\n    mocker: A fixture for mocking objects.\n    custom_config_path: Path to the custom user configuration file.\n\nAsserts:\n    The returned user configuration is the default configuration.\n    The `get_config` function is not called.\n\"\"\"",
                "test_expand_user_for_directories_in_config": "\"\"\"\nValidate user pointers expanded in user configs.\n\nThis test ensures that the `~` symbol in user configuration paths is correctly\nexpanded to the user's home directory. It uses the `monkeypatch` fixture to\ntemporarily replace the `os.path.expanduser` function with a custom implementation\nthat simulates the expansion of the `~` symbol to a specific directory.\n\"\"\"",
                "test_expand_vars_for_directories_in_config": "\"\"\"Validate environment variables expanded in user configs.\"\"\"",
                "test_specify_config_values": "\"\"\"\nValidate provided custom config values should be respected.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_hooks.py": [
        {
            "TestFindHooks": {
                "setup_method": "\"\"\"Set up the test environment for each test method in the class.\"\"\"\n",
                "teardown_method": "\"\"\"\nTear down the test environment by removing the test repository and any generated files.\n\nParameters:\n_method (Any): The method that was run before this teardown.\n\"\"\"",
                "test_find_hook": "\"\"\"\nFinds the specified hook and verifies its path.\n\nThis test checks if the `find_hook` function correctly locates the specified\nhook script within the repository. It asserts that the paths of the pre-generation\nand post-generation hooks match the expected paths.\n\nAssertions:\n    - The path of the pre-generation hook should match the expected path.\n    - The path of the post-generation hook should match the expected path.\n\"\"\"",
                "test_no_hooks": "\"\"\"`find_hooks` should return None if the hook could not be found.\"\"\"",
                "test_unknown_hooks_dir": "\"\"\"\n`find_hooks` should return None if hook directory not found.\n\"\"\"",
                "test_hook_not_found": "\"\"\"`find_hooks` should return None if the hook could not be found.\"\"\"\n",
                "TestFindHooks": "\"\"\"\nTestFindHooks class is designed to test the functionality of the `find_hooks` function within a repository.\n\nThis class includes methods to set up and tear down the test environment for each test case, as well as multiple test methods to verify the behavior of the `find_hooks` function under different scenarios:\n\n- `setup_method`: Prepares the test environment before each test method is executed.\n- `teardown_method`: Cleans up the test environment after each test method is executed.\n- `test_find_hook`: Verifies that the `find_hooks` function correctly locates the specified hook script and checks that the paths of the pre-generation and post-generation hooks match the expected paths.\n- `test_no_hooks`: Ensures that `find_hooks` returns None if the specified hook cannot be found.\n- `test_unknown_hooks_dir`: Ensures that `find_hooks` returns None if the hook directory is not found.\n- `test_hook_not_found`: Ensures that `find_hooks` returns None if the specified hook cannot be found.\n\"\"\""
            }
        },
        {
            "TestExternalHooks": {
                "setup_method": "\"\"\"Set up the test environment for find hooks related tests.\n\nThis method is called before each test method to create a test repository\nwith the necessary hooks for testing. It initializes the `post_hook` attribute\nwith the name of the post-generation hook script.\n\"\"\"",
                "teardown_method": "\"\"\"External hooks related tests teardown fixture.\n\nThis method is called after each test method to clean up the test environment.\nIt removes the test repository and any files created during the tests.\n\"\"\"",
                "test_run_script": "\"\"\"\nExecute a hook script, independently of project generation.\n\"\"\"",
                "test_run_failing_script": "\"\"\"Test correct exception raise if run_script fails.\n\nThis test verifies that the `run_script` function raises the appropriate\n`FailedHookException` when the script execution fails due to an `OSError`.\nIt uses the `mocker` fixture to simulate the failure scenario.\n\"\"\"",
                "test_run_failing_script_enoexec": "\"\"\"\nTest correct exception raise if run_script fails with ENOEXEC error.\n\nThis test simulates a scenario where the `run_script` function fails due to an \nOSError with the errno set to ENOEXEC, which typically indicates that the script \nis either an empty file or missing a shebang. It verifies that the appropriate \nexception (`FailedHookException`) is raised with the correct error message.\n\nArgs:\n    mocker: A pytest fixture used to mock the `subprocess.Popen` call to \n            simulate the OSError with ENOEXEC.\n\"\"\"",
                "test_run_script_cwd": "\"\"\"\nChange directory before running hook.\n\nThis function changes the current working directory to the specified path before executing the hook script. \nIt ensures that the script runs in the correct context and verifies the creation of the expected file.\n\nRaises:\n    exceptions.FailedHookException: If the hook script fails to execute.\n\"\"\"",
                "test_run_script_with_context": "\"\"\"\nExecute a hook script, passing a context.\n\nThis function runs a specified hook script within a given directory and \npasses a context dictionary to it. The context can be used within the \nscript to customize its behavior.\n\nRaises:\n    exceptions.FailedHookException: If the hook script fails to execute.\n\nArgs:\n    None\n\"\"\"\n",
                "test_run_hook": "\"\"\"\nExecute hook from specified template in specified output directory.\n\nThis function runs a specified hook script (e.g., 'pre_gen_project' or \n'post_gen_project') from a given template directory and in a specified \noutput directory. It ensures that the hook script is executed in the \ncorrect context and verifies the creation of expected output files.\n\nArgs:\n    hook_name (str): The name of the hook to run (e.g., 'pre_gen_project').\n    template_dir (str): The directory containing the template and hook scripts.\n    context (dict): A dictionary containing context variables to pass to the hook.\n\nRaises:\n    exceptions.FailedHookException: If the hook script fails to execute \n    successfully.\n\"\"\"\n",
                "test_run_failing_hook": "\"\"\"Test correct exception raise if hook exit code is not zero.\"\"\"",
                "TestExternalHooks": "\"\"\"\nTest suite for validating the execution and handling of external hooks.\n\nThe `TestExternalHooks` class contains a series of tests designed to verify the correct execution and error handling of external hook scripts within a test repository environment. These tests ensure that hook scripts are executed properly, handle various failure scenarios, and operate within the correct context.\n\nThe class includes setup and teardown methods to prepare and clean up the test environment before and after each test. It also contains multiple test methods to validate different aspects of hook script execution, such as running scripts independently, handling specific errors, and executing hooks with context.\n\nAttributes:\n    post_hook (str): The name of the post-generation hook script, initialized during setup.\n\nMethods:\n    setup_method: Set up the test environment for find hooks related tests.\n    teardown_method: Clean up the test environment after each test.\n    test_run_script: Execute a hook script independently of project generation.\n    test_run_failing_script: Verify exception handling when a script execution fails.\n    test_run_failing_script_enoexec: Verify exception handling for ENOEXEC errors.\n    test_run_script_cwd: Change directory before running a hook script.\n    test_run_script_with_context: Execute a hook script with a provided context.\n    test_run_hook: Execute a specified hook from a template in a specified output directory.\n    test_run_failing_hook: Verify exception handling when a hook script exits with a non-zero code.\n\"\"\""
            }
        },
        {
            "global": {
                "make_test_repo": "\"\"\"\nCreate a test repository for setting up test environments.\n\nThis function creates a directory structure for a test repository, including\nhook scripts for pre and post generation steps. It can optionally create\nmultiple hooks.\n\nArgs:\n    name (str): The name of the test repository to create.\n    multiple_hooks (bool, optional): If True, additional pre-generation hook\n        scripts will be created. Defaults to False.\n\nReturns:\n    str: The filename of the post-generation hook script.\n\"\"\"",
                "test_ignore_hook_backup_files": "\"\"\"Test `find_hook` correctly ignores backup files when verifying hooks.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_log.py": [
        {
            "global": {
                "create_log_records": "\"\"\"\nTest function, create log entries in expected stage of test.\n\nThis function sets up loggers for different components and generates log \nmessages at various levels (info, debug, error). It is used to create log \nrecords that can be tested for correct logging behavior in different \nscenarios.\n\"\"\"",
                "test_info_stdout_logging": "\"\"\"Test that stdout logs use info format and level.\"\"\"",
                "test_debug_stdout_logging": "\"\"\"\nTest that stdout logs use debug format and level.\n\"\"\"",
                "test_debug_file_logging": "\"\"\"Test that logging to stdout uses a different format and level than the file handler.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_main.py": [
        {
            "global": {
                "test_original_cookiecutter_options_preserved_in__cookiecutter": "\"\"\"Test that original cookiecutter options are preserved in the context.\n\nThis test ensures that the original context options can be accessed via\n`context['_cookiecutter']` after running the cookiecutter command.\n\nArgs:\n    monkeypatch: pytest fixture for safely patching and undoing modifications.\n    mocker: pytest fixture for mocking objects.\n    user_config_file: Path to the user configuration file.\n\nAsserts:\n    The test checks that the `test_list` and `test_dict` options in the\n    `_cookiecutter` context are preserved correctly.\n\"\"\"",
                "test_replay_dump_template_name": "\"\"\"Check that replay_dump is called with a valid template_name.\n\nTemplate name must not be a relative path.\n\nOtherwise files such as ``..json`` are created, which are not just cryptic\nbut also later mistaken for replay files of other templates if invoked with\n'.' and '--replay'.\n\nChange the current working directory temporarily to 'tests/fake-repo-tmpl'\nfor this test and call cookiecutter with '.' for the target template.\n\"\"\"",
                "test_replay_load_template_name": "\"\"\"Check that replay_load is called correctly.\n\nCalls require valid template_name that is not a relative path.\n\nChange the current working directory temporarily to 'tests/fake-repo-tmpl'\nfor this test and call cookiecutter with '.' for the target template.\n\"\"\"",
                "test_custom_replay_file": "\"\"\"Check that reply.load is called with the custom replay_file.\n\nThis test ensures that the `replay.load` function is invoked with the specified custom replay file.\nIt temporarily changes the current working directory to 'tests/fake-repo-tmpl' and calls the \n`cookiecutter` function with a custom replay file path.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_output_folder.py": [
        {
            "global": {
                "test_output_folder": "\"\"\"\nTests should correctly create content, as output_folder does not yet exist.\n\"\"\"",
                "test_exception_when_output_folder_exists": "\"\"\"\nTests should raise an error when the output folder already exists before `generate_files` is called.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_preferred_encoding.py": [
        {
            "global": {
                "test_not_ascii": "\"\"\"Make sure that the system's preferred encoding is not `ascii`.\n\nOtherwise, `click` raises a RuntimeError for Python3. For a detailed\ndescription of this problem, please consult the following gist:\nhttps://gist.github.com/hackebrot/937245251887197ef542\n\nThis test also checks that `tox.ini` explicitly copies the relevant\nsystem environment variables to the test environments.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_pre_prompt_hooks.py": [
        {
            "global": {
                "test_run_pre_prompt_python_hook": "\"\"\"Verify pre_prompt.py runs and creates a copy of cookiecutter.json.\"\"\"",
                "test_run_pre_prompt_python_hook_fail": "\"\"\"Verify pre_prompt.py will fail when a given env var is present.\"\"\"",
                "test_run_pre_prompt_shell_hook": "\"\"\"Verify pre_prompt.sh runs and creates a copy of cookiecutter.json.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_prompt.py": [
        {
            "TestRenderVariable": {
                "test_convert_to_str": "\"\"\"Verify simple items correctly rendered to strings.\n\nArgs:\n    mocker: A mocker object to patch functions.\n    raw_var: The raw variable to be rendered.\n    rendered_var: The expected rendered variable.\n\nAsserts:\n    The result of rendering the variable matches the expected rendered variable.\n    Non-None, non-string variables are converted to strings before rendering.\n\"\"\"",
                "test_convert_to_str_complex_variables": "\"\"\"\nVerify complex data structures (like dictionaries and lists) are correctly rendered to strings.\n\nArgs:\n    raw_var: The raw variable to be rendered, which can be a dictionary, list, or other complex data structure.\n    rendered_var: The expected rendered variable after processing.\n\nAsserts:\n    The rendered variable matches the expected output.\n\"\"\"",
                "TestRenderVariable": "\"\"\"\nTestRenderVariable class is designed to verify the correct rendering of various types of variables into strings.\n\nThis class contains methods to:\n1. Test the rendering of simple items into strings.\n2. Test the rendering of complex data structures, such as dictionaries and lists, into strings.\n\nThe tests ensure that the rendered output matches the expected results, and that non-string variables are appropriately converted to strings before rendering.\n\"\"\""
            }
        },
        {
            "TestPrompt": {
                "test_prompt_for_config": "\"\"\"Verify `prompt_for_config` calls `read_user_variable` on text request.\n\nThis test ensures that the `prompt_for_config` function correctly invokes the \n`read_user_variable` function when a text request is made. It uses the `monkeypatch` \nfixture to replace the `read_user_variable` function with a lambda that returns the \ndefault value. The test then asserts that the returned dictionary matches the expected \ncontext.\n\"\"\"",
                "test_prompt_for_config_with_human_prompts": "\"\"\"Verify call `read_user_variable` on request when human-readable prompts.\n\nThis test ensures that the `prompt_for_config` function correctly calls the \n`read_user_variable`, `read_user_yes_no`, and `read_user_choice` functions \nwhen human-readable prompts are provided in the context.\n\nArgs:\n    monkeypatch: pytest fixture to modify or mock objects.\n    context: Dictionary containing the context for the cookiecutter template.\n\nThe test mocks the `read_user_variable`, `read_user_yes_no`, and \n`read_user_choice` functions to return the default values provided in the \ncontext. It then verifies that the `prompt_for_config` function returns the \nexpected dictionary.\n\"\"\"",
                "test_prompt_for_config_with_human_choices": "\"\"\"\nTest prompts when human-readable labels for user choices.\n\nThis test verifies that the `prompt_for_config` function correctly handles\ncontexts where human-readable labels are provided for user choices. It uses\nthe `click.testing.CliRunner` to simulate user input and checks that the\nresulting configuration dictionary matches the expected values.\n\nArgs:\n    context (dict): The context dictionary containing the configuration\n                    options and their human-readable labels.\n\nAsserts:\n    The resulting configuration dictionary matches the expected values.\n\"\"\"\n",
                "test_prompt_for_config_dict": "\"\"\"Verify `prompt_for_config` calls `read_user_variable` on dict request.\n\nThis test ensures that when `prompt_for_config` is called with a context containing a dictionary, it correctly invokes the `read_user_variable` function to handle the dictionary input.\n\nArgs:\n    monkeypatch: A pytest fixture that allows modifying or mocking objects for the duration of the test.\n\"\"\"",
                "test_should_render_dict": "```python\n\"\"\"Verify template inside dictionary variable rendered.\"\"\"\n```",
                "test_should_render_deep_dict": "\"\"\"Verify nested structures like dict in dict, rendered correctly.\"\"\"",
                "test_should_render_deep_dict_with_human_prompts": "\"\"\"Verify dict rendered correctly when human-readable prompts are provided.\n\nThis test ensures that when a dictionary contains human-readable prompts, the \n`prompt_for_config` function correctly renders the dictionary values, including \nnested structures, using the provided context.\n\nThe context includes a project name and details with various nested structures \nlike dictionaries and lists. The function is expected to replace template \nplaceholders with actual values from the context.\n\nAssertions:\n- The rendered dictionary should match the expected output with all template \n  placeholders replaced by their corresponding values from the context.\n\"\"\"",
                "test_internal_use_no_human_prompts": "\"\"\"Verify dict rendered correctly when human-readable prompts empty.\"\"\"\n",
                "test_prompt_for_templated_config": "\"\"\"Verify Jinja2 templating works in unicode prompts.\n\nThis test ensures that the `prompt_for_config` function correctly processes\nJinja2 templating within unicode prompts. It mocks the `read_user_variable`\nfunction to return default values and checks that the templated configuration\nis rendered as expected.\n\nArgs:\n    monkeypatch: pytest fixture to modify or mock objects.\n\nRaises:\n    AssertionError: If the rendered configuration does not match the expected\n    output.\n\"\"\"",
                "test_dont_prompt_for_private_context_var": "\"\"\"\nVerify `read_user_variable` not called for private context variables.\n\nThis test ensures that the `read_user_variable` function is not invoked when \nthe context contains private variables (variables starting with an underscore).\nIt sets up a context with a private variable and checks that the function \n`prompt_for_config` processes the context without attempting to read a user \nresponse for the private variable.\n\"\"\"",
                "test_should_render_private_variables_with_two_underscores": "\"\"\"Test rendering of private variables with two underscores.\n\nThere are three cases:\n1. Variables beginning with a single underscore are private and not rendered.\n2. Variables beginning with a double underscore are private and are rendered.\n3. Variables beginning with anything other than underscores are not private and\n   are rendered.\n\"\"\"",
                "test_should_not_render_private_variables": "\"\"\"Verify private(underscored) variables not rendered by `prompt_for_config`.\n\nPrivate variables designed to be raw, same as context input.\n\"\"\"",
                "TestPrompt": "\"\"\"\nTestPrompt class contains a suite of unit tests designed to verify the functionality and correctness of the `prompt_for_config` function and its interactions with various user input handling functions. The tests cover a range of scenarios including:\n\n- Ensuring `prompt_for_config` correctly invokes `read_user_variable` for text and dictionary requests.\n- Verifying the handling of human-readable prompts and choices.\n- Testing the rendering of templates within dictionaries, including nested structures.\n- Checking the correct processing of Jinja2 templating within unicode prompts.\n- Ensuring private context variables (variables starting with an underscore) are not processed for user input.\n- Verifying the correct rendering behavior for private variables with single and double underscores.\n\nThese tests utilize fixtures like `monkeypatch` and `click.testing.CliRunner` to mock and simulate user inputs, ensuring that the `prompt_for_config` function behaves as expected under various conditions.\n\"\"\""
            }
        },
        {
            "TestReadUserChoice": {
                "```plaintext\ntest_should_invoke_read_user_choice": "\"\"\"Verify correct function called for select(list) variables.\n\nThis test ensures that the `read_user_choice` function is invoked when the context contains a list of choices for a variable. It mocks the necessary functions and verifies that the correct function is called and the expected value is returned.\n\nArgs:\n    mocker: A pytest fixture used to mock objects.\n\"\"\"",
                "test_should_invoke_read_user_variable": "\"\"\"Verify correct function called for string input variables.\n\nThis test ensures that the `read_user_variable` function is invoked when the context contains a string input variable. It mocks the `read_user_variable`, `prompt_choice_for_config`, and `read_user_choice` functions to verify their calls and expected behavior.\n\nArgs:\n    mocker: A pytest fixture used to mock objects.\n\nAsserts:\n    - `prompt_choice_for_config` is not called.\n    - `read_user_choice` is not called.\n    - `read_user_variable` is called once with the expected arguments.\n    - The returned dictionary matches the expected context.\n\"\"\"",
                "test_should_render_choices\n```": "\"\"\"\nVerify Jinja2 templating engine works inside choices variables.\n\nThis test ensures that the Jinja2 templating engine correctly processes\ntemplate variables within a list of choices. It mocks the user input\nfor both the project name and the package name, and verifies that the\nrendered choices are correctly processed and selected.\n\nArgs:\n    mocker: A pytest fixture that allows for mocking objects.\n\"\"\"",
                "TestReadUserChoice": "\"\"\"\nTestReadUserChoice class contains unit tests to verify the correct behavior of functions that handle user input choices and variables in a configuration context.\n\nThe class includes tests to:\n- Ensure the `read_user_choice` function is invoked correctly when the context contains a list of choices.\n- Verify that the `read_user_variable` function is called appropriately for string input variables.\n- Confirm that the Jinja2 templating engine processes template variables within a list of choices correctly.\n\nEach test uses the `mocker` fixture to mock necessary functions and objects, ensuring the expected behavior and interactions are validated.\n\"\"\""
            }
        },
        {
            "TestPromptChoiceForConfig": {
                "test_should_return_first_option_if_no_input": "\"\"\"Verify `prompt_choice_for_config` returns the first list option when no_input is True.\n\nArgs:\n    mocker: Mocking framework object.\n    choices: List of available choices.\n    context: Dictionary containing the context for the prompt.\n\nReturns:\n    The first option from the choices list when no_input is True.\n\"\"\"",
                "test_should_read_user_choice": "\"\"\"\nVerify correct function called for select(list) variables.\n\nThis test ensures that the `read_user_choice` function is invoked when the context contains a list of choices for a variable. It mocks the necessary functions and verifies that the correct function is called and the expected value is returned.\n\nArgs:\n    mocker: The mocker fixture to mock functions.\n\nRaises:\n    AssertionError: If the expected function is not called or the returned value is incorrect.\n\"\"\"",
                "TestPromptChoiceForConfig": "\"\"\"\nTest suite for the `prompt_choice_for_config` function.\n\nThis class contains unit tests to verify the behavior of the `prompt_choice_for_config` function, which is responsible for handling user choices in a configuration prompt. The tests ensure that the function correctly returns the first option when no input is provided and that it properly reads and processes user choices from a list of available options.\n\nFunctions:\n    - test_should_return_first_option_if_no_input: Verify `prompt_choice_for_config` returns the first list option when no_input is True.\n    - test_should_read_user_choice: Verify correct function called for select(list) variables and ensure the expected value is returned.\n\"\"\""
            }
        },
        {
            "TestReadUserYesNo": {
                "[]": "\"\"\"\nPrompt the user to delete a specified repository directory or file.\n\nArgs:\n    repo_dir (str): The path to the repository directory or file to be deleted.\n    no_input (bool, optional): If True, suppresses user input and deletes the repository automatically. Defaults to False.\n\nReturns:\n    bool: True if the repository was deleted, False otherwise.\n\"\"\"",
                "TestReadUserYesNo": "\"\"\"\nA class to handle user prompts for deleting a specified repository directory or file.\n\nThis class provides functionality to prompt the user for confirmation before deleting a specified repository directory or file. It also supports an option to suppress user input and delete the repository automatically.\n\"\"\""
            }
        },
        {
            "global": {
                "patch_readline_on_win": "\"\"\"\nFixture to overwrite the end-of-line character on Windows to the Linux standard.\n\nThis fixture is automatically used in all tests to ensure consistent behavior\nof the `readline` function across different operating systems. On Windows, it\nreplaces the `readline` function to return a newline character (`\\n`) instead\nof the default carriage return and newline (`\\r\\n`).\n\nArgs:\n    monkeypatch: A pytest fixture that allows you to safely set/delete an attribute,\n                 dictionary item or environment variable, or modify sys.path for the\n                 duration of a test.\n\"\"\"",
                "test_convert_to_str": "\"\"\"\nVerify tree items correctly rendered.\n\"\"\"",
                "test_convert_to_str_complex_variables": "\"\"\"\n        Verify complex data structures (like dictionaries and lists) are correctly rendered to strings.\n\n        Args:\n            raw_var (Any): The raw variable to be rendered.\n            rendered_var (Any): The expected rendered variable.\n\n        Asserts:\n            The rendered variable matches the expected rendered variable.\n        \"\"\"",
                "test_prompt_for_config": "\"\"\"Verify `prompt_for_config` calls `read_user_variable` on text request.\"\"\"\n",
                "test_prompt_for_config_with_human_prompts": "\"\"\"Verify call `read_user_variable` on request when human-readable prompts.\n\nThis test ensures that the `prompt_for_config` function correctly calls the \n`read_user_variable`, `read_user_yes_no`, and `read_user_choice` functions \nwhen human-readable prompts are provided in the context.\n\nArgs:\n    monkeypatch: pytest fixture for modifying or mocking objects.\n    context: Dictionary containing the context for the cookiecutter template.\n\nThe test mocks the `read_user_variable`, `read_user_yes_no`, and \n`read_user_choice` functions to return the default values provided in the \ncontext. It then verifies that the `prompt_for_config` function returns the \nexpected dictionary.\n\"\"\"",
                "test_prompt_for_config_with_human_choices": "\"\"\"Test prompts when human-readable labels for user choices.\n\n    Args:\n        context (dict): The context dictionary containing the configuration \n                        and prompts for the cookiecutter template.\n\n    Asserts:\n        The function asserts that the returned dictionary from \n        `prompt.prompt_for_config` matches the expected dictionary with \n        human-readable labels for user choices.\n    \"\"\"",
                "test_prompt_for_config_dict": "\"\"\"Verify `prompt_for_config` call `read_user_variable` on dict request.\"\"\"",
                "test_should_render_dict": "\"\"\"\nVerify template inside dictionary variable rendered.\n\nThis test checks that the `prompt.prompt_for_config` function correctly renders\nJinja2 templates within dictionary variables. It ensures that the placeholders\nin the dictionary are replaced with the appropriate values from the context.\n\"\"\"",
                "test_should_render_deep_dict": "\"\"\"\nVerify nested structures like dict in dict, rendered correctly.\n\nThis test ensures that deeply nested dictionary structures are correctly rendered\nusing the provided context. It checks that all levels of the nested dictionary,\nincluding lists and sub-dictionaries, are properly processed and rendered.\n\"\"\"",
                "test_should_render_deep_dict_with_human_prompts": "```python\n        \"\"\"\n        Verify dict rendered correctly when human-readable prompts.\n\n        This test ensures that when human-readable prompts are provided in the context,\n        the dictionary is rendered correctly with the appropriate values.\n\n        The context includes a project name and details with nested structures, and\n        human-readable prompts for the project name. The test verifies that the\n        rendered dictionary matches the expected output.\n        \"\"\"\n```",
                "test_internal_use_no_human_prompts": "\"\"\"Verify dict rendered correctly when human-readable prompts empty.\n\nThis test ensures that the `prompt_for_config` function correctly renders\nthe dictionary when the human-readable prompts are empty.\n\nThe context dictionary contains a `cookiecutter` key with a nested dictionary\nthat includes a `project_name` key and an empty `__prompts__` dictionary.\n\nThe expected output is a dictionary with the `project_name` key and its value\nunchanged.\n\nAssertions:\n- The rendered dictionary should match the expected output.\n\"\"\"\n",
                "test_prompt_for_templated_config": "\"\"\"Verify Jinja2 templating works in unicode prompts.\n\n    This test ensures that the `prompt_for_config` function correctly processes\n    Jinja2 templating within the context of unicode prompts. It uses a mock\n    to simulate user input and verifies that the templated configuration is\n    rendered as expected.\n\n    Args:\n        monkeypatch: A pytest fixture used to modify or mock the behavior of\n                     objects during testing.\n\n    Raises:\n        AssertionError: If the rendered configuration does not match the\n                        expected output.\n    \"\"\"",
                "test_dont_prompt_for_private_context_var": "\"\"\"\nVerify `read_user_variable` not called for private context variables.\n\nThis test ensures that the `read_user_variable` function is not invoked when \nthe context contains private variables (variables starting with an underscore).\nIt sets up a context with a private variable and checks that the function \n`prompt_for_config` processes the context correctly without attempting to \nread a user response for the private variable.\n\"\"\"",
                "test_should_render_private_variables_with_two_underscores": "\"\"\"Test rendering of private variables with two underscores.\n\nThere are three cases:\n1. Variables beginning with a single underscore are private and not rendered.\n2. Variables beginning with a double underscore are private and are rendered.\n3. Variables beginning with anything other than underscores are not private and\n   are rendered.\n\"\"\"",
                "test_should_not_render_private_variables": "\"\"\"Verify private(underscored) variables not rendered by `prompt_for_config`.\n\nPrivate variables designed to be raw, same as context input.\n\"\"\"",
                "test_should_invoke_read_user_choice": "\"\"\"Verify correct function called for select(list) variables.\n\nThis test ensures that the `read_user_choice` function is invoked when the context contains a list of choices. It mocks the necessary functions and verifies that the correct function is called and the expected value is returned.\n\nArgs:\n    mocker: A fixture for mocking objects.\n\nReturns:\n    None\n\"\"\"",
                "test_should_invoke_read_user_variable": "\"\"\"\nVerify correct function called for string input variables.\n\nThis test ensures that the `read_user_variable` function is invoked when the context contains a string input variable.\n\"\"\"",
                "test_should_render_choices": "\"\"\"\nVerify Jinja2 templating engine works inside choices variables.\n\nThis test ensures that the Jinja2 templating engine correctly processes\ntemplate variables within a list of choices. It mocks the user input\nfor both the project name and the package name, and verifies that the\nrendered choices are as expected.\n\nArgs:\n    mocker: A pytest fixture that allows mocking of objects.\n\nReturns:\n    None\n\"\"\"",
                "test_should_return_first_option_if_no_input": "\"\"\"\nVerify prompt_choice_for_config returns the first list option when no_input is True.\n\nArgs:\n    mocker: The mocker fixture.\n    choices: The list of choices to prompt the user with.\n    context: The context dictionary containing the choices.\n\nReturns:\n    None\n\"\"\"",
                "test_should_read_user_choice": "\"\"\"\nVerify that the `read_user_choice` function is called correctly for select (list) variables.\n\nThis test ensures that when a context dictionary containing a list of choices is passed to the \n`prompt_for_config` function, the `read_user_choice` function is invoked to handle the selection \nof a choice from the list. The test mocks the `read_user_choice` function to return a specific \nchoice and verifies that the function is called with the correct parameters and that the returned \nchoice is correctly assigned in the resulting dictionary.\n\nArgs:\n    mocker: A pytest fixture used to mock objects for testing.\n\nRaises:\n    AssertionError: If the `read_user_choice` function is not called with the expected parameters \n                    or if the resulting dictionary does not contain the expected choice.\n\"\"\"\n",
                "test_should_invoke_read_user_yes_no": "\"\"\"\nVerify correct function called for boolean variables.\n\nThis test ensures that the `read_user_yes_no` function is invoked when \nboolean variables are encountered in the context. It mocks the \n`read_user_yes_no` function to return the value of `run_as_docker` and \nchecks that the `read_user_variable` function is not called. The test \nasserts that the `read_user_yes_no` function is called with the correct \nparameters and that the resulting `cookiecutter_dict` contains the \nexpected boolean value.\n\"\"\"",
                "test_boolean_parameter_no_input": "\"\"\"Verify boolean parameter sent to prompt for config with no input.\"\"\"\n",
                "test_undefined_variable": "\"\"\"Verify `prompt.prompt_for_config` raises correct error when encountering an undefined variable in the context.\n\nArgs:\n    context (dict): The context dictionary containing the variables to be rendered.\n\nRaises:\n    exceptions.UndefinedVariableInTemplate: If an undefined variable is encountered during rendering.\n\"\"\"",
                "test_cookiecutter_nested_templates": "\"\"\"\nTest nested_templates generation.\n\nThis function tests the generation of nested templates by the `cookiecutter` library.\nIt verifies that the correct output directory is chosen based on the provided template\ndirectory and expected output.\n\nArgs:\n    template_dir (str): The directory containing the nested templates.\n    expected (Path | str): The expected output directory.\n\nAsserts:\n    The output directory generated by `choose_nested_template` matches the expected directory.\n\"\"\"\n",
                "test_cookiecutter_nested_templates_invalid_paths": "\"\"\"\nTest nested_templates generation with invalid paths.\n\nThis test verifies that the `choose_nested_template` function raises a `ValueError`\nwhen provided with invalid paths in the `cookiecutter` context. It ensures that\nthe function correctly identifies and rejects illegal template paths.\n\nArgs:\n    path (str): The invalid path to be tested.\n\nRaises:\n    ValueError: If the provided path is illegal.\n\"\"\"\n",
                "test_cookiecutter_nested_templates_invalid_win_paths": "\"\"\"\nTest nested_templates generation on Windows.\n\nThis test verifies that the `choose_nested_template` function raises a `ValueError`\nwhen provided with invalid paths on Windows. The paths tested include an empty string,\n\"C:/tmp\", and \"D:/tmp\". The test ensures that the function correctly identifies and\nrejects illegal template paths.\n\nArgs:\n    path (str): The path to be tested.\n\nRaises:\n    ValueError: If the provided path is deemed illegal.\n\"\"\"\n",
                "test_prompt_should_ask_and_rm_repo_dir": "\"\"\"\nIn `prompt_and_delete()`, if the user agrees to delete/reclone the repo, the repo should be deleted.\n\nArgs:\n    mocker: Mock object to simulate user input.\n    tmp_path: Temporary directory path for creating a mock repository.\n\nReturns:\n    None\n\"\"\"",
                "test_prompt_should_ask_and_exit_on_user_no_answer": "\"\"\"In `prompt_and_delete()`, if the user declines to delete/reclone the repo, cookiecutter should exit.\n\n    Args:\n        mocker: Mock object to simulate user input and system exit.\n        tmp_path: Temporary path for creating a mock repository directory.\n\n    Returns:\n        None\n    \"\"\"",
                "test_prompt_should_ask_and_rm_repo_file": "\"\"\"In `prompt_and_delete()`, if the user agrees to delete/reclone a \nrepo file, the repo should be deleted.\"\"\"",
                "test_prompt_should_ask_and_keep_repo_on_no_reuse": "\"\"\"\nIn `prompt_and_delete()`, if the user wants to keep their old cloned template repo, it should not be deleted.\n\nArgs:\n    mocker: Mock object to simulate user input.\n    tmp_path: Temporary directory path for testing.\n\nRaises:\n    SystemExit: If the user chooses not to delete the repo.\n\nAsserts:\n    The user is prompted to confirm whether to delete the repo.\n    The repo directory exists if the user chooses not to delete it.\n\"\"\"\n",
                "test_prompt_should_ask_and_keep_repo_on_reuse": "\"\"\"\nIn `prompt_and_delete()`, if the user wants to keep their old \ncloned template repo, it should not be deleted.\n\nArgs:\n    mocker: Mock object to simulate user input.\n    tmp_path: Temporary directory path for testing.\n\nReturns:\n    None\n\"\"\"",
                "test_prompt_should_not_ask_if_no_input_and_rm_repo_dir": "\"\"\"\nPrompt should not ask if no input and rm dir.\n\nIn `prompt_and_delete()`, if `no_input` is True, the call to\n`prompt.read_user_yes_no()` should be suppressed.\n\"\"\"",
                "test_prompt_should_not_ask_if_no_input_and_rm_repo_file": "\"\"\"\nPrompt should not ask if no input and rm file.\n\nIn `prompt_and_delete()`, if `no_input` is True, the call to\n`prompt.read_user_yes_no()` should be suppressed.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_read_repo_password.py": [
        {
            "global": {
                "test_click_invocation": "\"\"\"\nTest click function called correctly by cookiecutter.\n\nThis test verifies that the `read_repo_password` function correctly invokes \nthe `Prompt.ask` method from the `rich.prompt` module with the appropriate \nparameters for a password (hidden input) type prompt.\n\nArgs:\n    mocker: A fixture for mocking objects in tests.\n\nAsserts:\n    The `read_repo_password` function returns the expected password.\n    The `Prompt.ask` method is called once with the correct arguments.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_read_user_choice.py": [
        {
            "global": {
                "test_click_invocation": "\"\"\"Test click function called correctly by cookiecutter.\n\nTest for choice type invocation.\n\"\"\"",
                "test_raise_if_options_is_not_a_non_empty_list": "\"\"\"Test function to ensure read_user_choice raises ValueError for empty options list.\n\n    This test verifies that the read_user_choice function raises a ValueError\n    when provided with an empty list of options.\n    \"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_read_user_dict.py": [
        {
            "global": {
                "test_process_json_invalid_json": "\"\"\"Test `process_json` for correct error on malformed input.\"\"\"",
                "test_process_json_non_dict": "\"\"\"Test `process_json` for correct error on non-dict JSON input.\"\"\"",
                "test_process_json_valid_json": "\"\"\"Test `process_json` for correct output on valid JSON input.\n\nTest for simple dict with list.\n\"\"\"",
                "test_process_json_deep_dict": "\"\"\"Test `process_json` for correct output on JSON input.\n\nTest for dict in dict case.\n\"\"\"",
                "test_should_raise_type_error": "\"\"\"Test `default_value` arg verification in `read_user_dict` function.\"\"\"",
                "test_should_call_prompt_with_process_json": "\"\"\"Test to make sure that `process_json` is actually being used.\n\nVerifies generation of a processor for the user input.\n\"\"\"",
                "test_should_not_load_json_from_sentinel": "\"\"\"Ensure that `json.loads` is not called when using the default value in `read_user_dict`.\n\nThis test verifies that the `json.loads` function is not invoked when the `read_user_dict` function is called with a default value, ensuring that the default value is used directly without attempting to parse it as JSON.\n\"\"\"",
                "test_read_user_dict_default_value": "\"\"\"Make sure that `read_user_dict` returns the default value.\n\nVerify return of a dict variable rather than the display value.\n\"\"\"",
                "test_json_prompt_process_response": "\"\"\"Test `JsonPrompt` process_response to convert str to json.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_read_user_variable.py": [
        {
            "global": {
                "test_click_invocation": "\"\"\"Test click function called correctly by cookiecutter.\n\nTest for string type invocation.\n\"\"\"",
                "test_input_loop_with_null_default_value": "\"\"\"Test `Prompt.ask` is run repeatedly until a valid answer is provided.\n\nTest for `default_value` parameter equal to None.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_read_user_yes_no.py": [
        {
            "YesNoPrompt": {
                "process_response": "\"\"\"Test `YesNoPrompt` process_response to convert str to bool.\n\nArgs:\n    response (str): The response string to be processed.\n\nReturns:\n    bool: True if the response is affirmative, False if negative.\n\nRaises:\n    InvalidResponse: If the response is not recognized as valid.\n\"\"\"",
                "YesNoPrompt": "\"\"\"\nThe YesNoPrompt class provides functionality to process and interpret yes/no responses.\n\nThis class includes methods to:\n- Convert a string response into a boolean value indicating an affirmative or negative response.\n- Raise an error if the response is not recognized as valid.\n\"\"\""
            }
        },
        {
            "global": {
                "test_click_invocation": "\"\"\"Test click function called correctly by cookiecutter.\n\nTest for boolean type invocation.\n\"\"\"",
                "test_yesno_prompt_process_response": "\"\"\"Test `YesNoPrompt` process_response to convert str to bool.\n\nThis function tests the `process_response` method of the `YesNoPrompt` class to ensure it correctly converts string inputs to boolean values. It also verifies that an `InvalidResponse` exception is raised for invalid inputs.\n\nRaises:\n    InvalidResponse: If the input string is not a valid response.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_repo_not_found.py": [
        {
            "global": {
                "test_should_raise_error_if_repo_does_not_exist": "\"\"\"Test that Cookiecutter raises an error when the repository does not exist.\n\nThis test ensures that invoking Cookiecutter with a non-existent repository \nraises the appropriate RepositoryNotFound exception.\n\nRaises:\n    RepositoryNotFound: If the specified repository does not exist.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_specify_output_dir.py": [
        {
            "global": {
                "test_api_invocation": "\"\"\"Verify output dir location is correctly passed.\"\"\"",
                "test_default_output_dir": "\"\"\"Verify that the default output directory is the current working directory.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_templates.py": [
        {
            "global": {
                "test_build_templates": "\"\"\"\nVerify Templates Design keywords.\n\nno-templates is a compatibility test for repos without a `templates` directory.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_time_extension.py": [
        {
            "global": {
                "environment": "\"\"\"Fixture. Add tested extension to environment.\"\"\"",
                "freeze": "\"\"\"Fixture. Freeze time for all tests.\"\"\"",
                "test_tz_is_required": "\"\"\"Verify template parsing fails without a timezone.\"\"\"",
                "test_utc_default_datetime_format": "\"\"\"Verify that the default datetime format is correctly parsed when using 'utc' timezone.\"\"\"\n",
                "test_accept_valid_timezones": "\"\"\"Verify that valid timezones are accepted.\"\"\"",
                "test_environment_datetime_format": "\"\"\"Verify datetime format can be parsed from the environment.\"\"\"",
                "test_add_time": "\"\"\"Verify that added time offset can be parsed.\"\"\"",
                "test_substract_time": "\"\"\"Verify that subtracted time offset can be parsed.\"\"\"",
                "test_offset_with_format": "\"\"\"Verify that offset works together with a specified datetime format.\"\"\"\n"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test_utils.py": [
        {
            "global": {
                "make_readonly": "\"\"\"Change the access permissions to readonly for a given file.\n\nArgs:\n    path (Path): The path to the file whose permissions will be changed.\n\"\"\"",
                "test_force_delete": "\"\"\"Verify `utils.force_delete` makes files writable.\n\nThis test creates a read-only file, then uses the `utils.force_delete` function \nto ensure the file is made writable before attempting to delete it. It verifies \nthat the file's permissions are correctly modified and that the deletion \nfunction is called as expected.\n\"\"\"",
                "test_rmtree": "\"\"\"Verify `utils.rmtree` remove files marked as read-only.\"\"\"",
                "test_make_sure_path_exists": "\"\"\"Verify correct True/False response from `utils.make_sure_path_exists`.\n\nShould return True if directory exists or is created.\nShould return False if it is impossible to create the directory (for example, if it is protected).\n\"\"\"",
                "test_make_sure_path_exists_correctly_handle_os_error": "\"\"\"Test that `utils.make_sure_path_exists` correctly handles OSError.\n\nShould raise an OSError if the directory cannot be created (e.g., due to protection).\n\"\"\"",
                "test_work_in": "\"\"\"Verify returning to original folder after `utils.work_in` use.\n\nArgs:\n    tmp_path (pathlib.Path): Temporary directory path provided by pytest.\n\nAsserts:\n    The current working directory changes to `tmp_path` within the context manager.\n    The current working directory reverts to the original directory after the context manager.\n\"\"\"",
                "test_work_in_without_path": "\"\"\"Folder is not changed if no path provided.\"\"\"",
                "test_create_tmp_repo_dir": "\"\"\"Verify `utils.create_tmp_repo_dir` creates a temporary repository directory.\n\nThis function tests that `utils.create_tmp_repo_dir` correctly creates a copy of \nthe given repository directory, including all its subdirectories.\n\nArgs:\n    tmp_path: A temporary directory path provided by pytest.\n\nAsserts:\n    The new repository directory exists.\n    The new repository directory contains the expected subdirectories.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\__init__.py": [
        {
            "global": {
                "Empty list": "\"DONE\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\hooks-abort-render\\hooks\\post_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code. Therefore, the list is empty.\n\n[]": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\hooks-abort-render\\hooks\\pre_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code. Therefore, the list is empty.\n\n[]": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\replay\\conftest.py": [
        {
            "global": {
                "context": "\"\"\"Fixture to return a valid context as known from a cookiecutter.json.\"\"\"",
                "replay_test_dir": "\"\"\"\nFixture to provide the directory path for replay tests.\n\"\"\"",
                "mock_user_config": "\"\"\"Fixture to mock user config.\n\nArgs:\n    mocker: The mocker fixture used to patch the get_user_config method.\n\nReturns:\n    Mock object for the get_user_config method.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\replay\\test_dump.py": [
        {
            "global": {
                "test_value_error_if_key_missing_in_context": "\"\"\"\nTest that replay.dump raises if the context does not contain a key named 'cookiecutter'.\n\nArgs:\n    replay_test_dir (str): The directory where the replay file is stored.\n    template_name (str): The name of the template.\n\nRaises:\n    ValueError: If the context does not contain a key named 'cookiecutter'.\n\"\"\"",
                "test_ioerror_if_replay_dir_creation_fails": "\"\"\"Test that replay.dump raises when the replay_dir cannot be created.\"\"\"",
                "test_run_json_dump": "\"\"\"\nTest that replay.dump runs json.dump under the hood and that the context \nis correctly written to the expected file in the replay_dir.\n\nArgs:\n    mocker: pytest fixture for mocking.\n    mock_ensure_success: Mocked function to ensure replay directory creation.\n    mock_user_config: Mocked user configuration.\n    template_name: Name of the template.\n    context: Context dictionary to be dumped.\n    replay_test_dir: Directory where the replay file is stored.\n    replay_file: Path to the replay file.\n\nAsserts:\n    - The user configuration is not called.\n    - The replay directory creation is attempted once.\n    - The replay file name is retrieved once.\n    - The json.dump function is called once with the correct arguments.\n    - The output file handler's name matches the expected replay file.\n    - The dumped context matches the provided context.\n\"\"\"\n"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\replay\\test_load.py": [
        {
            "global": {
                "test_value_error_if_key_missing_in_context": "\"\"\"Test that replay.load raises a ValueError if the loaded context does not contain 'cookiecutter'.\"\"\"",
                "test_io_error_if_no_replay_file": "\"\"\"Test that replay.load raises if it cannot find a replay file.\"\"\"",
                "test_run_json_load": "\"\"\"Test that replay.load runs json.load under the hood and that the context is correctly loaded from the file in replay_dir.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\replay\\test_replay.py": [
        {
            "global": {
                "test_get_replay_file_name": "\"\"\"Make sure that replay.get_file_name generates a valid json file path.\"\"\"",
                "test_raise_on_invalid_mode": "\"\"\"Test that `cookiecutter` raises an `InvalidModeException` when given invalid arguments in replay mode.\"\"\"",
                "test_main_does_not_invoke_dump_but_load": "\"\"\"Test that `cookiecutter` does not invoke `dump` but invokes `load` when replay is enabled.\"\"\"",
                "test_main_does_not_invoke_load_but_dump": "\"\"\"Test `cookiecutter` calling correct functions on non-replay launch.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_abbreviation_expansion.py": [
        {
            "global": {
                "test_abbreviation_expansion": "\"\"\"Verify abbreviation unpacking.\"\"\"",
                "test_abbreviation_expansion_prefix_not_0_in_braces": "\"\"\"Verify that abbreviation unpacking raises an IndexError when the placeholder index is not 0.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_determine_repository_should_use_local_repo.py": [
        {
            "global": {
                "test_finds_local_repo": "\"\"\"Test that a valid local repository is correctly identified and returned.\"\"\"",
                "test_local_repo_with_no_context_raises": "\"\"\"A local repository without a cookiecutter.json should raise a `RepositoryNotFound` exception.\"\"\"",
                "test_local_repo_typo": "\"\"\"An unknown local repository should raise a `RepositoryNotFound` exception.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_determine_repo_dir_clones_repo.py": [
        {
            "global": {
                "test_zipfile_unzip": "\"\"\"Verify zip files correctly handled for different source locations.\n\n`unzip()` should be called with correct args when `determine_repo_dir()`\nis passed a zipfile, or a URL to a zipfile.\n\"\"\"",
                "test_repository_url_should_clone": "\"\"\"Verify repository url triggers clone function.\n\n`clone()` should be called with correct args when `determine_repo_dir()` is\npassed a repository template url.\n\"\"\"",
                "test_repository_url_with_no_context_file": "\"\"\"Verify cloned repository without `cookiecutter.json` file raises error.\n\nThis test ensures that when a repository is cloned and it does not contain\na `cookiecutter.json` file, an appropriate `RepositoryNotFound` exception is raised.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_determine_repo_dir_finds_existing_cookiecutter.py": [
        {
            "global": {
                "test_should_find_existing_cookiecutter": "\"\"\"\nShould find folder created by `cloned_cookiecutter_path` and return it.\n\nThis folder is considered like previously cloned project directory.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_determine_repo_dir_finds_subdirectories.py": [
        {
            "global": {
                "test_should_find_existing_cookiecutter": "\"\"\"Find `cookiecutter.json` in sub folder created by `cloned_cookiecutter_path`.\"\"\"",
                "test_local_repo_typo": "\"\"\"Wrong pointing to `cookiecutter.json` sub-directory should raise an exception.\n\nArgs:\n    template (str): The name of the template.\n    user_config_data (dict): User configuration data containing paths.\n    cloned_cookiecutter_path (str): Path to the cloned cookiecutter template.\n\nRaises:\n    exceptions.RepositoryNotFound: If the specified sub-directory does not contain a valid `cookiecutter.json`.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_is_repo_url.py": [
        {
            "global": {
                "test_is_zip_file": "\"\"\"Verify is_zip_file correctly identifies zip file paths.\"\"\"",
                "test_is_repo_url_for_remote_urls": "\"\"\"Test that `is_repo_url` correctly identifies remote repository URLs.\"\"\"",
                "test_is_repo_url_for_local_urls": "\"\"\"Verify is_repo_url correctly identifies local repository URLs as invalid.\"\"\"",
                "test_expand_abbreviations": "\"\"\"Validate `repository.expand_abbreviations` correctly translates an abbreviated URL to a full repository URL.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\repository\\test_repository_has_cookiecutter_json.py": [
        {
            "global": {
                "test_valid_repository": "\"\"\"Validate correct response if `cookiecutter.json` file exist.\"\"\"",
                "test_invalid_repository": "\"\"\"Validate correct response if `cookiecutter.json` file not exist.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\custom-extension-post\\hooks\\post_gen_project.py": [
        {
            "global": {
                "sys.exit": "\"\"\"\nExit the program with a status code.\n\nExits with status code 0 if the condition is met, otherwise exits with status code 1.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\custom-extension-pre\\hooks\\pre_gen_project.py": [
        {
            "global": {
                "sys.exit": "\"\"\"\nExit the program with a status code.\n\nExits with status code 0 if the condition is met, otherwise exits with status code 1.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\hello_extension\\hello_extension.py": [
        {
            "HelloExtension": {
                "__init__": "\"\"\"Initialize the HelloExtension with the given Jinja2 environment.\"\"\"",
                "_hello": "\"\"\"Do actual tag replace when invoked by parser.\n\nArgs:\n    name (str): The name to be included in the greeting.\n\nReturns:\n    str: A greeting string in the format 'Hello {name}!'.\n\"\"\"",
                "parse": "        \"\"\"Parses the template and returns the output node for the 'hello' tag.\n\n        Args:\n            parser (Parser): The Jinja2 parser instance.\n\n        Returns:\n            nodes.Output: The output node containing the result of the 'hello' tag.\n        \"\"\"",
                "HelloExtension": "\"\"\"\nHelloExtension is a Jinja2 extension that provides a custom 'hello' tag for templates.\n\nThis class allows users to include personalized greeting messages within their Jinja2 templates. It initializes with a Jinja2 environment and provides functionality to parse and replace the 'hello' tag with a greeting message.\n\nAttributes:\n    environment (Environment): The Jinja2 environment in which the extension is initialized.\n\nMethods:\n    __init__: Initializes the HelloExtension with the given Jinja2 environment.\n    _hello: Generates a greeting string in the format 'Hello {name}!' when invoked by the parser.\n    parse: Parses the template and returns the output node for the 'hello' tag.\n\"\"\""
            }
        },
        {
            "global": {
                "[]": "\"\"\"Work when something match `tags` variable.\n\nArgs:\n    parser (Parser): The parser instance that is used to parse the template.\n\nReturns:\n    nodes.Output: The output node containing the result of the `_hello` method call.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\hello_extension\\__init__.py": [
        {
            "global": {
                "```[]```": "\"DONE\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\local_extension\\local_extensions\\main.py": [
        {
            "FoobarExtension": {
                "__init__": "        \"\"\"Initialize the FoobarExtension with the given Jinja2 environment.\n\n        Args:\n            environment (Environment): The Jinja2 environment to which the 'foobar' filter will be added.\n        \"\"\"",
                "FoobarExtension": "\"\"\"\nFoobarExtension is a class designed to integrate a custom 'foobar' filter into a Jinja2 environment. \n\nThis class is initialized with a Jinja2 environment and adds the 'foobar' filter to it, allowing users to utilize the custom filter within their Jinja2 templates.\n\"\"\""
            }
        },
        {
            "global": {
                "simplefilterextension": "\"\"\"\nConvert the input string to uppercase.\n\nArgs:\n    v (str): The input string to be converted.\n\nReturns:\n    str: The input string in uppercase.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-extensions\\local_extension\\local_extensions\\__init__.py": [
        {
            "global": {
                "[]": "\"DONE\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-generate-files-line-end\\{{cookiecutter.test_name}}\\{{cookiecutter.folder_name}}\\{{cookiecutter.filename}}.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-output-folder\\{{cookiecutter.test_name}}\\{{cookiecutter.folder_name}}\\{{cookiecutter.filename}}.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code. Therefore, the list is empty.\n\n[]": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-pyhooks\\hooks\\post_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "DONE"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-pyhooks\\hooks\\pre_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "\"\"\"Pre-generation hook that prints a message and creates an empty file named 'python_pre.txt'.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-pyhooks\\hooks\\pre_prompt.py": [
        {
            "global": {
                "backup_configuration": "\"\"\"\nCreate a backup of the 'cookiecutter.json' file in the current working directory.\n\nArgs:\n    cwd (Path): The current working directory as a Path object.\n\nReturns:\n    Path: The path to the backup file created.\n\"\"\"",
                "main": "\"\"\"Check if we can run the cookiecutter.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-pyshellhooks\\hooks\\post_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "```python\n\"\"\"Creates a file named 'python_post.txt' and closes it immediately after.\"\"\"\n```"
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\test-pyshellhooks\\hooks\\pre_gen_project.py": [
        {
            "global": {
                "There are no methods or functions defined in the global scope in the provided code.\n\n[]": "\"\"\"Pre-generation hook that prints a message and creates an empty file named 'python_pre.txt'.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\undefined-variable\\dir-name\\{{cookiecutter.project_slug}}\\{{cookiecutter.foobar}}\\helloworld.py": [
        {
            "global": {
                "Understood. Please provide the source code from which you would like me to extract the method or function names.": "Understood. Please provide the source code from which you would like me to extract the method or function names."
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\vcs\\test_clone.py": [
        {
            "global": {
                "test_clone_should_raise_if_vcs_not_installed": "\"\"\"In `clone()`, a `VCSNotInstalled` exception should be raised if no VCS is installed.\"\"\"",
                "test_clone_should_rstrip_trailing_slash_in_repo_url": "\"\"\"In `clone()`, repo URL's trailing slash should be stripped if one is present.\"\"\"",
                "test_clone_should_abort_if_user_does_not_want_to_reclone": "\"\"\"In `clone()`, if user doesn't want to reclone, Cookiecutter should exit \\\nwithout cloning anything.\"\"\"",
                "test_clone_should_silent_exit_if_ok_to_reuse": "\"\"\"In `clone()`, if the repository already exists and the user agrees to reuse it, Cookiecutter should exit without cloning anything.\"\"\"",
                "test_clone_should_invoke_vcs_command": "\"\"\"\nWhen `clone()` is called with a git/hg repo, the corresponding VCS command should be run via `subprocess.check_output()`.\n\nThis should take place:\n* In the correct dir\n* With the correct args.\n\"\"\"",
                "test_clone_handles_repo_typo": "\"\"\"In `clone()`, repository not found errors should raise an \\\nappropriate exception.\"\"\"",
                "test_clone_handles_branch_typo": "\"\"\"In `clone()`, branch not found errors should raise an appropriate exception.\"\"\"",
                "test_clone_unknown_subprocess_error": "\"\"\"In `clone()`, unknown subprocess errors should be raised.\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\vcs\\test_identify_repo.py": [
        {
            "global": {
                "test_identify_known_repo": "\"\"\"\nVerify different correct repositories url syntax is correctly transformed.\n\nArgs:\n    repo_url (str): The URL of the repository to be identified.\n    exp_repo_type (str): The expected type of the repository (e.g., 'git', 'hg').\n    exp_repo_url (str): The expected URL of the repository after transformation.\n\nAsserts:\n    The identified repository type and URL match the expected values.\n\"\"\"",
                "unknown_repo_type_url": "\"\"\"Fixture. Return a repository URL with an unknown or incorrect format for testing purposes.\"\"\"",
                "test_identify_raise_on_unknown_repo": "\"\"\"Verify that an unknown repository URL raises an UnknownRepoType exception.\n\nArgs:\n    unknown_repo_type_url (str): A repository URL with an unknown or incorrect format.\n\nRaises:\n    exceptions.UnknownRepoType: If the repository URL format is not recognized.\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\vcs\\test_is_vcs_installed.py": [
        {
            "global": {
                "test_is_vcs_installed": "\"\"\"Verify `is_vcs_installed` function correctly handles `which` answer.\n\nArgs:\n    mocker: A mocker object to patch dependencies.\n    which_return: The return value of the `which` function being mocked.\n    result: The expected result from the `is_vcs_installed` function.\n\nReturns:\n    None\n\"\"\""
            }
        }
    ],
    "C:\\Users\\t.kubera\\dev\\workshop\\chat-with-your-sw-project\\resources\\cookiecutter\\tests\\zipfile\\test_unzip.py": [
        {
            "global": {
                "mock_download": "\"\"\"Simulates downloading a file by yielding chunks of bytes from a local file.\n\nYields:\n    Iterator[bytes]: An iterator that yields chunks of bytes read from a local file.\n\"\"\"",
                "mock_download_with_empty_chunks": "\"\"\"Fake download function that yields an initial empty chunk followed by chunks of data from a zip file.\n\nYields:\n    None: An initial empty chunk.\n    bytes: Subsequent chunks of data read from the zip file.\n\"\"\"",
                "test_unzip_local_file": "\"\"\"Local file reference can be unzipped.\n\nArgs:\n    mocker: A mocker object to patch functions.\n    clone_dir: Directory where the zip file will be cloned.\n\nAsserts:\n    The output directory starts with the system's temporary directory.\n    The prompt_and_delete function is not called.\n\"\"\"",
                "test_unzip_protected_local_file_environment_password": "\"\"\"\nTest the `unzip()` function to ensure that the environment can be used to provide a password for a protected local zip file.\n\nArgs:\n    mocker: A fixture for mocking objects.\n    clone_dir: A fixture providing a temporary directory for cloning.\n\nAsserts:\n    The output directory starts with the system's temporary directory path.\n    The `prompt_and_delete` function is not called.\n\"\"\"",
                "test_unzip_protected_local_file_bad_environment_password": "\"\"\"\nIn `unzip()`, an error occurs if the environment has a bad password.\n\nThis test verifies that the `unzip` function raises an `InvalidZipRepository` \nexception when attempting to unzip a password-protected local file with an \nincorrect password provided by the environment.\n\"\"\"",
                "test_unzip_protected_local_file_user_password_with_noinput": "\"\"\"Test that a password-protected repository cannot be unpacked in no_input mode.\n\nThis test verifies that attempting to unzip a password-protected repository\nwith the `no_input` flag set to True raises an `InvalidZipRepository` exception.\n\nArgs:\n    mocker: A fixture for mocking objects.\n    clone_dir: A fixture providing a temporary directory for cloning.\n\nRaises:\n    InvalidZipRepository: If the repository cannot be unpacked due to the\n    password protection and no_input mode.\n\"\"\"",
                "test_unzip_protected_local_file_user_password": "\"\"\"A password-protected local file reference can be unzipped.\n\nThis test verifies that the `unzip` function can successfully unzip a \npassword-protected local file when the correct password is provided by the user.\n\nArgs:\n    mocker: A fixture for mocking objects.\n    clone_dir: A fixture providing a temporary directory for cloning.\n\nRaises:\n    InvalidZipRepository: If the zip file cannot be unzipped due to an invalid password.\n\"\"\"",
                "test_unzip_protected_local_file_user_bad_password": "\"\"\"Test that an error is raised in `unzip()` if the user cannot provide a valid password for a password-protected local file.\"\"\"",
                "test_empty_zip_file": "\"\"\"In `unzip()`, an empty file raises an error.\"\"\"",
                "test_non_repo_zip_file": "\"\"\"\nIn `unzip()`, a repository must have a top level directory.\n\nThis test verifies that attempting to unzip a file that does not contain a top-level directory raises an `InvalidZipRepository` exception.\n\"\"\"",
                "test_bad_zip_file": "\"\"\"In `unzip()`, a corrupted zip file raises an error.\"\"\"",
                "test_unzip_url": "\"\"\"In `unzip()`, a URL will be downloaded and unzipped.\"\"\"",
                "test_unzip_url_with_empty_chunks": "\"\"\"Test that the `unzip()` function correctly ignores empty chunks when downloading and unzipping a file from a URL.\"\"\"",
                "test_unzip_url_existing_cache": "\"\"\"\nUrl should be downloaded and unzipped, old zip file will be removed.\n\nArgs:\n    mocker: pytest fixture for mocking.\n    clone_dir: Directory where the zip file will be cloned.\n\nAsserts:\n    The output directory starts with the system's temporary directory.\n    The prompt and delete function is called once.\n\"\"\"",
                "test_unzip_url_existing_cache_no_input": "\"\"\"If no_input is provided, the existing file should be removed.\n\nArgs:\n    mocker: The mocker object used to patch functions and methods.\n    clone_dir: The directory where the zip file will be cloned.\n\nAsserts:\n    The output directory starts with the system's temporary directory path.\n\"\"\"",
                "test_unzip_should_abort_if_no_redownload": "\"\"\"\nShould exit without cloning anything if no redownload is allowed.\n\nThis test verifies that the `unzip` function will abort the operation and exit \nwithout attempting to download or unzip the file if the user does not allow \nredownloading of an existing cached zip file.\n\nArgs:\n    mocker: The mocker fixture for patching.\n    clone_dir: The directory where the zip file will be cloned.\n\nRaises:\n    SystemExit: If the function exits as expected when no redownload is allowed.\n\"\"\"",
                "test_unzip_is_ok_to_reuse": "\"\"\"Test that an already downloaded zip file is not downloaded again.\n\nThis test verifies that if a zip file has already been downloaded and exists\nin the specified directory, the `unzip` function will not attempt to download\nit again. Instead, it will reuse the existing file.\n\nArgs:\n    mocker: A fixture for mocking objects.\n    clone_dir: A fixture providing a temporary directory for cloning.\n\nAsserts:\n    - The output directory starts with the system's temporary directory path.\n    - The `prompt_and_delete` function is called exactly once.\n    - The `iter_content` method of the request object is not called, indicating\n      that no new download occurred.\n\"\"\""
            }
        }
    ]
}